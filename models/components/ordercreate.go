// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"ascend-sdk/internal/utils"
	"encoding/json"
	"fmt"
	"time"
)

// AssetType - The type of the asset in this order
type AssetType string

const (
	AssetTypeAssetTypeUnspecified AssetType = "ASSET_TYPE_UNSPECIFIED"
	AssetTypeEquity               AssetType = "EQUITY"
	AssetTypeFixedIncome          AssetType = "FIXED_INCOME"
	AssetTypeMutualFund           AssetType = "MUTUAL_FUND"
)

func (e AssetType) ToPointer() *AssetType {
	return &e
}
func (e *AssetType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ASSET_TYPE_UNSPECIFIED":
		fallthrough
	case "EQUITY":
		fallthrough
	case "FIXED_INCOME":
		fallthrough
	case "MUTUAL_FUND":
		*e = AssetType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AssetType: %v", v)
	}
}

// BrokerCapacity - Defaults to "AGENCY" if not specified. For Equities: Only "AGENCY" is allowed. For Mutual Funds: Only "AGENCY" is allowed. For Fixed Income: Either "AGENCY" or "PRINCIPAL" are allowed.
type BrokerCapacity string

const (
	BrokerCapacityBrokerCapacityUnspecified BrokerCapacity = "BROKER_CAPACITY_UNSPECIFIED"
	BrokerCapacityAgency                    BrokerCapacity = "AGENCY"
	BrokerCapacityPrincipal                 BrokerCapacity = "PRINCIPAL"
)

func (e BrokerCapacity) ToPointer() *BrokerCapacity {
	return &e
}
func (e *BrokerCapacity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "BROKER_CAPACITY_UNSPECIFIED":
		fallthrough
	case "AGENCY":
		fallthrough
	case "PRINCIPAL":
		*e = BrokerCapacity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BrokerCapacity: %v", v)
	}
}

// IdentifierType - The identifier type of the asset being ordered. For Equities: only SYMBOL is supported For Mutual Funds: only SYMBOL and CUSIP are supported For Fixed Income: only CUSIP and ISIN are supported
type IdentifierType string

const (
	IdentifierTypeSymbol IdentifierType = "SYMBOL"
	IdentifierTypeCusip  IdentifierType = "CUSIP"
	IdentifierTypeIsin   IdentifierType = "ISIN"
)

func (e IdentifierType) ToPointer() *IdentifierType {
	return &e
}
func (e *IdentifierType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SYMBOL":
		fallthrough
	case "CUSIP":
		fallthrough
	case "ISIN":
		*e = IdentifierType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for IdentifierType: %v", v)
	}
}

// OrderType - The execution type of this order. For Equities: MARKET, LIMIT, or STOP are supported. For Mutual Funds: only MARKET is supported. For Fixed Income: only LIMIT is supported.
type OrderType string

const (
	OrderTypeOrderTypeUnspecified OrderType = "ORDER_TYPE_UNSPECIFIED"
	OrderTypeLimit                OrderType = "LIMIT"
	OrderTypeMarket               OrderType = "MARKET"
	OrderTypeStop                 OrderType = "STOP"
)

func (e OrderType) ToPointer() *OrderType {
	return &e
}
func (e *OrderType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ORDER_TYPE_UNSPECIFIED":
		fallthrough
	case "LIMIT":
		fallthrough
	case "MARKET":
		fallthrough
	case "STOP":
		*e = OrderType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderType: %v", v)
	}
}

// Side - The side of this order.
type Side string

const (
	SideSideUnspecified Side = "SIDE_UNSPECIFIED"
	SideBuy             Side = "BUY"
	SideSell            Side = "SELL"
)

func (e Side) ToPointer() *Side {
	return &e
}
func (e *Side) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SIDE_UNSPECIFIED":
		fallthrough
	case "BUY":
		fallthrough
	case "SELL":
		*e = Side(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Side: %v", v)
	}
}

type SpecialReportingInstructions string

const (
	SpecialReportingInstructionsSpecialReportingInstructionsUnspecified SpecialReportingInstructions = "SPECIAL_REPORTING_INSTRUCTIONS_UNSPECIFIED"
	SpecialReportingInstructionsCustomerDirected                        SpecialReportingInstructions = "CUSTOMER_DIRECTED"
	SpecialReportingInstructionsWithDividend                            SpecialReportingInstructions = "WITH_DIVIDEND"
	SpecialReportingInstructionsWithRights                              SpecialReportingInstructions = "WITH_RIGHTS"
	SpecialReportingInstructionsDiscretionExercised                     SpecialReportingInstructions = "DISCRETION_EXERCISED"
	SpecialReportingInstructionsDiscretionNotExercised                  SpecialReportingInstructions = "DISCRETION_NOT_EXERCISED"
	SpecialReportingInstructionsBrokerDealerOrder                       SpecialReportingInstructions = "BROKER_DEALER_ORDER"
	SpecialReportingInstructionsFullyRegistered                         SpecialReportingInstructions = "FULLY_REGISTERED"
	SpecialReportingInstructionsOddlotDiffOnRequest                     SpecialReportingInstructions = "ODDLOT_DIFF_ON_REQUEST"
	SpecialReportingInstructionsProspectusEnclosed                      SpecialReportingInstructions = "PROSPECTUS_ENCLOSED"
	SpecialReportingInstructionsProspectusSeparateMail                  SpecialReportingInstructions = "PROSPECTUS_SEPARATE_MAIL"
	SpecialReportingInstructionsSolicited                               SpecialReportingInstructions = "SOLICITED"
	SpecialReportingInstructionsUnsolicited                             SpecialReportingInstructions = "UNSOLICITED"
	SpecialReportingInstructionsXDividend                               SpecialReportingInstructions = "X_DIVIDEND"
	SpecialReportingInstructionsActingAsPrincipal                       SpecialReportingInstructions = "ACTING_AS_PRINCIPAL"
	SpecialReportingInstructionsAveragePrice                            SpecialReportingInstructions = "AVERAGE_PRICE"
	SpecialReportingInstructionsBrokerLiquidation                       SpecialReportingInstructions = "BROKER_LIQUIDATION"
	SpecialReportingInstructionsInternetOrder                           SpecialReportingInstructions = "INTERNET_ORDER"
	SpecialReportingInstructionsMarginSellout                           SpecialReportingInstructions = "MARGIN_SELLOUT"
	SpecialReportingInstructionsNegativeNetProceed                      SpecialReportingInstructions = "NEGATIVE_NET_PROCEED"
	SpecialReportingInstructionsRisklessPrincipal                       SpecialReportingInstructions = "RISKLESS_PRINCIPAL"
	SpecialReportingInstructionsThirdMarket                             SpecialReportingInstructions = "THIRD_MARKET"
	SpecialReportingInstructionsSuppressTraceReporting                  SpecialReportingInstructions = "SUPPRESS_TRACE_REPORTING"
	SpecialReportingInstructionsWhenDistributed                         SpecialReportingInstructions = "WHEN_DISTRIBUTED"
)

func (e SpecialReportingInstructions) ToPointer() *SpecialReportingInstructions {
	return &e
}
func (e *SpecialReportingInstructions) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SPECIAL_REPORTING_INSTRUCTIONS_UNSPECIFIED":
		fallthrough
	case "CUSTOMER_DIRECTED":
		fallthrough
	case "WITH_DIVIDEND":
		fallthrough
	case "WITH_RIGHTS":
		fallthrough
	case "DISCRETION_EXERCISED":
		fallthrough
	case "DISCRETION_NOT_EXERCISED":
		fallthrough
	case "BROKER_DEALER_ORDER":
		fallthrough
	case "FULLY_REGISTERED":
		fallthrough
	case "ODDLOT_DIFF_ON_REQUEST":
		fallthrough
	case "PROSPECTUS_ENCLOSED":
		fallthrough
	case "PROSPECTUS_SEPARATE_MAIL":
		fallthrough
	case "SOLICITED":
		fallthrough
	case "UNSOLICITED":
		fallthrough
	case "X_DIVIDEND":
		fallthrough
	case "ACTING_AS_PRINCIPAL":
		fallthrough
	case "AVERAGE_PRICE":
		fallthrough
	case "BROKER_LIQUIDATION":
		fallthrough
	case "INTERNET_ORDER":
		fallthrough
	case "MARGIN_SELLOUT":
		fallthrough
	case "NEGATIVE_NET_PROCEED":
		fallthrough
	case "RISKLESS_PRINCIPAL":
		fallthrough
	case "THIRD_MARKET":
		fallthrough
	case "SUPPRESS_TRACE_REPORTING":
		fallthrough
	case "WHEN_DISTRIBUTED":
		*e = SpecialReportingInstructions(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SpecialReportingInstructions: %v", v)
	}
}

// TimeInForce - Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
type TimeInForce string

const (
	TimeInForceTimeInForceUnspecified TimeInForce = "TIME_IN_FORCE_UNSPECIFIED"
	TimeInForceDay                    TimeInForce = "DAY"
)

func (e TimeInForce) ToPointer() *TimeInForce {
	return &e
}
func (e *TimeInForce) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TIME_IN_FORCE_UNSPECIFIED":
		fallthrough
	case "DAY":
		*e = TimeInForce(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TimeInForce: %v", v)
	}
}

// OrderCreate - The message describing an order
type OrderCreate struct {
	// The type of the asset in this order
	AssetType AssetType `json:"asset_type"`
	// Defaults to "AGENCY" if not specified. For Equities: Only "AGENCY" is allowed. For Mutual Funds: Only "AGENCY" is allowed. For Fixed Income: Either "AGENCY" or "PRINCIPAL" are allowed.
	BrokerCapacity *BrokerCapacity `json:"broker_capacity,omitempty"`
	// User-supplied unique order ID. Cannot be more than 40 characters long.
	ClientOrderID string `json:"client_order_id"`
	// Required for Equity Orders for any client who is having Apex do CAT reporting on their behalf. A value may be provided for non-Equity orders, and will be remembered, but valid timestamps will have no impact on how they are processed.
	ClientReceivedTime *time.Time `json:"client_received_time,omitempty"`
	// A custom commission applied to an order
	Commission *CommissionCreate `json:"commission,omitempty"`
	// Defaults to "USD". Only "USD" is supported. Full list of currency codes is defined at: https://en.wikipedia.org/wiki/ISO_4217
	CurrencyCode *string `json:"currency_code,omitempty"`
	// Identifier of the asset (of the type specified in `identifier_type`).
	Identifier string `json:"identifier"`
	// The identifier type of the asset being ordered. For Equities: only SYMBOL is supported For Mutual Funds: only SYMBOL and CUSIP are supported For Fixed Income: only CUSIP and ISIN are supported
	IdentifierType IdentifierType `json:"identifier_type"`
	// A limit price definition
	LimitPrice *LimitPriceCreate `json:"limit_price,omitempty"`
	// A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java's [BigDecimal][] or Python's [decimal.Decimal][].
	//
	//  [BigDecimal]:
	//  https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html
	//  [decimal.Decimal]: https://docs.python.org/3/library/decimal.html
	MaxSellQuantity *DecimalCreate `json:"max_sell_quantity,omitempty"`
	// A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java's [BigDecimal][] or Python's [decimal.Decimal][].
	//
	//  [BigDecimal]:
	//  https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html
	//  [decimal.Decimal]: https://docs.python.org/3/library/decimal.html
	NotionalValue *DecimalCreate `json:"notional_value,omitempty"`
	// Represents a whole or partial calendar date, such as a birthday. The time of day and time zone are either specified elsewhere or are insignificant. The date is relative to the Gregorian Calendar. This can represent one of the following:
	//
	//  * A full date, with non-zero year, month, and day values * A month and day value, with a zero year, such as an anniversary * A year on its own, with zero month and day values * A year and month value, with a zero day, such as a credit card expiration date
	//
	//  Related types are [google.type.TimeOfDay][google.type.TimeOfDay] and `google.protobuf.Timestamp`.
	OrderDate DateCreate `json:"order_date"`
	// The execution type of this order. For Equities: MARKET, LIMIT, or STOP are supported. For Mutual Funds: only MARKET is supported. For Fixed Income: only LIMIT is supported.
	OrderType OrderType `json:"order_type"`
	// A representation of a decimal value, such as 2.5. Clients may convert values into language-native decimal formats, such as Java's [BigDecimal][] or Python's [decimal.Decimal][].
	//
	//  [BigDecimal]:
	//  https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html
	//  [decimal.Decimal]: https://docs.python.org/3/library/decimal.html
	Quantity *DecimalCreate `json:"quantity,omitempty"`
	// The side of this order.
	Side Side `json:"side"`
	// Special Reporting Instructions to be applied to this order. Can include multiple Instructions.
	SpecialReportingInstructions []SpecialReportingInstructions `json:"special_reporting_instructions,omitempty"`
	// A stop price definition
	StopPrice *StopPriceCreate `json:"stop_price,omitempty"`
	// Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
	TimeInForce TimeInForce `json:"time_in_force"`
}

func (o OrderCreate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OrderCreate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *OrderCreate) GetAssetType() AssetType {
	if o == nil {
		return AssetType("")
	}
	return o.AssetType
}

func (o *OrderCreate) GetBrokerCapacity() *BrokerCapacity {
	if o == nil {
		return nil
	}
	return o.BrokerCapacity
}

func (o *OrderCreate) GetClientOrderID() string {
	if o == nil {
		return ""
	}
	return o.ClientOrderID
}

func (o *OrderCreate) GetClientReceivedTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.ClientReceivedTime
}

func (o *OrderCreate) GetCommission() *CommissionCreate {
	if o == nil {
		return nil
	}
	return o.Commission
}

func (o *OrderCreate) GetCurrencyCode() *string {
	if o == nil {
		return nil
	}
	return o.CurrencyCode
}

func (o *OrderCreate) GetIdentifier() string {
	if o == nil {
		return ""
	}
	return o.Identifier
}

func (o *OrderCreate) GetIdentifierType() IdentifierType {
	if o == nil {
		return IdentifierType("")
	}
	return o.IdentifierType
}

func (o *OrderCreate) GetLimitPrice() *LimitPriceCreate {
	if o == nil {
		return nil
	}
	return o.LimitPrice
}

func (o *OrderCreate) GetMaxSellQuantity() *DecimalCreate {
	if o == nil {
		return nil
	}
	return o.MaxSellQuantity
}

func (o *OrderCreate) GetNotionalValue() *DecimalCreate {
	if o == nil {
		return nil
	}
	return o.NotionalValue
}

func (o *OrderCreate) GetOrderDate() DateCreate {
	if o == nil {
		return DateCreate{}
	}
	return o.OrderDate
}

func (o *OrderCreate) GetOrderType() OrderType {
	if o == nil {
		return OrderType("")
	}
	return o.OrderType
}

func (o *OrderCreate) GetQuantity() *DecimalCreate {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *OrderCreate) GetSide() Side {
	if o == nil {
		return Side("")
	}
	return o.Side
}

func (o *OrderCreate) GetSpecialReportingInstructions() []SpecialReportingInstructions {
	if o == nil {
		return nil
	}
	return o.SpecialReportingInstructions
}

func (o *OrderCreate) GetStopPrice() *StopPriceCreate {
	if o == nil {
		return nil
	}
	return o.StopPrice
}

func (o *OrderCreate) GetTimeInForce() TimeInForce {
	if o == nil {
		return TimeInForce("")
	}
	return o.TimeInForce
}
