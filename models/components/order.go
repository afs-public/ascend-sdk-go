// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/afs-public/ascend-sdk-go/internal/utils"
)

// OrderAssetType - The type of the asset in this order
type OrderAssetType string

const (
	OrderAssetTypeAssetTypeUnspecified OrderAssetType = "ASSET_TYPE_UNSPECIFIED"
	OrderAssetTypeEquity               OrderAssetType = "EQUITY"
	OrderAssetTypeFixedIncome          OrderAssetType = "FIXED_INCOME"
	OrderAssetTypeMutualFund           OrderAssetType = "MUTUAL_FUND"
)

func (e OrderAssetType) ToPointer() *OrderAssetType {
	return &e
}
func (e *OrderAssetType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ASSET_TYPE_UNSPECIFIED":
		fallthrough
	case "EQUITY":
		fallthrough
	case "FIXED_INCOME":
		fallthrough
	case "MUTUAL_FUND":
		*e = OrderAssetType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderAssetType: %v", v)
	}
}

// OrderBrokerCapacity - Defaults to "AGENCY" if not specified. For Equities: Only "AGENCY" is allowed. For Mutual Funds: Only "AGENCY" is allowed. For Fixed Income: Either "AGENCY" or "PRINCIPAL" are allowed.
type OrderBrokerCapacity string

const (
	OrderBrokerCapacityBrokerCapacityUnspecified OrderBrokerCapacity = "BROKER_CAPACITY_UNSPECIFIED"
	OrderBrokerCapacityAgency                    OrderBrokerCapacity = "AGENCY"
	OrderBrokerCapacityPrincipal                 OrderBrokerCapacity = "PRINCIPAL"
)

func (e OrderBrokerCapacity) ToPointer() *OrderBrokerCapacity {
	return &e
}
func (e *OrderBrokerCapacity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "BROKER_CAPACITY_UNSPECIFIED":
		fallthrough
	case "AGENCY":
		fallthrough
	case "PRINCIPAL":
		*e = OrderBrokerCapacity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderBrokerCapacity: %v", v)
	}
}

// CancelRejectedReason - Used to denote when a cancel request has been rejected.
type CancelRejectedReason string

const (
	CancelRejectedReasonCancelRejectReasonUnspecified                     CancelRejectedReason = "CANCEL_REJECT_REASON_UNSPECIFIED"
	CancelRejectedReasonTooLateToCancel                                   CancelRejectedReason = "TOO_LATE_TO_CANCEL"
	CancelRejectedReasonCancellationUnknownOrder                          CancelRejectedReason = "CANCELLATION_UNKNOWN_ORDER"
	CancelRejectedReasonBrokerExchangeOption                              CancelRejectedReason = "BROKER_EXCHANGE_OPTION"
	CancelRejectedReasonOrderAlreadyInPendingCancelOrPendingReplaceStatus CancelRejectedReason = "ORDER_ALREADY_IN_PENDING_CANCEL_OR_PENDING_REPLACE_STATUS"
	CancelRejectedReasonDuplicate                                         CancelRejectedReason = "DUPLICATE"
	CancelRejectedReasonCancellationSystemError                           CancelRejectedReason = "CANCELLATION_SYSTEM_ERROR"
	CancelRejectedReasonOrderAlreadyCanceled                              CancelRejectedReason = "ORDER_ALREADY_CANCELED"
	CancelRejectedReasonCancellationMisconfiguredClient                   CancelRejectedReason = "CANCELLATION_MISCONFIGURED_CLIENT"
)

func (e CancelRejectedReason) ToPointer() *CancelRejectedReason {
	return &e
}
func (e *CancelRejectedReason) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CANCEL_REJECT_REASON_UNSPECIFIED":
		fallthrough
	case "TOO_LATE_TO_CANCEL":
		fallthrough
	case "CANCELLATION_UNKNOWN_ORDER":
		fallthrough
	case "BROKER_EXCHANGE_OPTION":
		fallthrough
	case "ORDER_ALREADY_IN_PENDING_CANCEL_OR_PENDING_REPLACE_STATUS":
		fallthrough
	case "DUPLICATE":
		fallthrough
	case "CANCELLATION_SYSTEM_ERROR":
		fallthrough
	case "ORDER_ALREADY_CANCELED":
		fallthrough
	case "CANCELLATION_MISCONFIGURED_CLIENT":
		*e = CancelRejectedReason(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CancelRejectedReason: %v", v)
	}
}

// OrderCommissionType - The type of commission value being specified. Only the type of "AMOUNT" is supported.
type OrderCommissionType string

const (
	OrderCommissionTypeCommissionTypeUnspecified OrderCommissionType = "COMMISSION_TYPE_UNSPECIFIED"
	OrderCommissionTypeAmount                    OrderCommissionType = "AMOUNT"
)

func (e OrderCommissionType) ToPointer() *OrderCommissionType {
	return &e
}
func (e *OrderCommissionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "COMMISSION_TYPE_UNSPECIFIED":
		fallthrough
	case "AMOUNT":
		*e = OrderCommissionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderCommissionType: %v", v)
	}
}

// Value - The value of this commission. If type = `AMOUNT`, then this expresses a monetary value in same currency denoted on the order itself.
type Value struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *Value) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OrderCommission - A custom commission to be applied to this order. When specifying an AMOUNT type, the value represents a notional amount measured in the currency of the order.
type OrderCommission struct {
	// The type of commission value being specified. Only the type of "AMOUNT" is supported.
	Type *OrderCommissionType `json:"type,omitempty"`
	// The value of this commission. If type = `AMOUNT`, then this expresses a monetary value in same currency denoted on the order itself.
	Value *Value `json:"value,omitempty"`
}

func (o *OrderCommission) GetType() *OrderCommissionType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderCommission) GetValue() *Value {
	if o == nil {
		return nil
	}
	return o.Value
}

// CumulativeNotionalValue - The sum of order quantity & price, across all fills, reported in the currency specified in the order. (This will be rounded to 2 decimal places for USD currencies). Will be absent if an order has no fill information.
type CumulativeNotionalValue struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *CumulativeNotionalValue) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// FilledQuantity - The summed quantity value across all fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no fill information.
type FilledQuantity struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *FilledQuantity) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OrderIdentifierType - The identifier type of the asset being ordered. For Equities: only SYMBOL is supported For Mutual Funds: only SYMBOL and CUSIP are supported For Fixed Income: only CUSIP and ISIN are supported
type OrderIdentifierType string

const (
	OrderIdentifierTypeSymbol OrderIdentifierType = "SYMBOL"
	OrderIdentifierTypeCusip  OrderIdentifierType = "CUSIP"
	OrderIdentifierTypeIsin   OrderIdentifierType = "ISIN"
)

func (e OrderIdentifierType) ToPointer() *OrderIdentifierType {
	return &e
}
func (e *OrderIdentifierType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SYMBOL":
		fallthrough
	case "CUSIP":
		fallthrough
	case "ISIN":
		*e = OrderIdentifierType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderIdentifierType: %v", v)
	}
}

// OrderPrice - The limit price which must be greater than zero if provided. For equity orders in the USD currency, up to 2 decimal places are allowed for prices above $1 and up to 4 decimal places for prices at or below $1. For fixed income orders this is expressed as a percentage of par, which allows up to 4 decimal places in the USD currency.
type OrderPrice struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *OrderPrice) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OrderLimitPriceType - The type of this price, which must be PRICE_PER_UNIT for equity orders, or PERCENTAGE_OF_PAR for fixed income orders.
type OrderLimitPriceType string

const (
	OrderLimitPriceTypeLimitPriceTypeUnspecified OrderLimitPriceType = "LIMIT_PRICE_TYPE_UNSPECIFIED"
	OrderLimitPriceTypePricePerUnit              OrderLimitPriceType = "PRICE_PER_UNIT"
	OrderLimitPriceTypePercentageOfPar           OrderLimitPriceType = "PERCENTAGE_OF_PAR"
)

func (e OrderLimitPriceType) ToPointer() *OrderLimitPriceType {
	return &e
}
func (e *OrderLimitPriceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "LIMIT_PRICE_TYPE_UNSPECIFIED":
		fallthrough
	case "PRICE_PER_UNIT":
		fallthrough
	case "PERCENTAGE_OF_PAR":
		*e = OrderLimitPriceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderLimitPriceType: %v", v)
	}
}

// LimitPrice - The limit price for this order.
type LimitPrice struct {
	// The limit price which must be greater than zero if provided. For equity orders in the USD currency, up to 2 decimal places are allowed for prices above $1 and up to 4 decimal places for prices at or below $1. For fixed income orders this is expressed as a percentage of par, which allows up to 4 decimal places in the USD currency.
	Price *OrderPrice `json:"price,omitempty"`
	// The type of this price, which must be PRICE_PER_UNIT for equity orders, or PERCENTAGE_OF_PAR for fixed income orders.
	Type *OrderLimitPriceType `json:"type,omitempty"`
}

func (o *LimitPrice) GetPrice() *OrderPrice {
	if o == nil {
		return nil
	}
	return o.Price
}

func (o *LimitPrice) GetType() *OrderLimitPriceType {
	if o == nil {
		return nil
	}
	return o.Type
}

// MaxSellQuantity - The maximum number of shares to be sold if this is a notional SELL order of an Equity asset type. (Prohibited for other side or asset_type inputs.)
//
//	This will only be recognized for clients configured not to use OMS checks. When specified, must be greater than 0 and can't exceed 5 decimal places.
type MaxSellQuantity struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *MaxSellQuantity) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// NotionalValue - Notional quantity of the order, measured in USD. Maximum 2 decimal place precision. For Equities: This represents the maximum amount to be spent. The final order may may have a smaller notional amount. For Mutual Funds: Only supported for BUY orders. The order will be transacted at the full notional amount specified. For Fixed Income: Not supported, you must specify a `quantity` value.
type NotionalValue struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *NotionalValue) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OrderDate - The date on which the order will go to the market: must either be "today" or the next valid trading day. If the current day is not a valid trading day, then the next valid market day must be specified. If the current time is within 5 minutes prior to market close, the next valid market day may be specified. If the current time is after market close, and before midnight Eastern, then the next valid market day must be specified. In all other cases, the current day, Eastern must be specified.
type OrderDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *OrderDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *OrderDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *OrderDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// OrderRejectedReason - When an order has the REJECTED status, this will be populated with a system code describing the rejection.
type OrderRejectedReason string

const (
	OrderRejectedReasonOrderRejectReasonUnspecified                      OrderRejectedReason = "ORDER_REJECT_REASON_UNSPECIFIED"
	OrderRejectedReasonBrokerOption                                      OrderRejectedReason = "BROKER_OPTION"
	OrderRejectedReasonUnknownSecurity                                   OrderRejectedReason = "UNKNOWN_SECURITY"
	OrderRejectedReasonExchangeClosed                                    OrderRejectedReason = "EXCHANGE_CLOSED"
	OrderRejectedReasonOrderExceedsLimit                                 OrderRejectedReason = "ORDER_EXCEEDS_LIMIT"
	OrderRejectedReasonTooLateToEnter                                    OrderRejectedReason = "TOO_LATE_TO_ENTER"
	OrderRejectedReasonUnknownOrder                                      OrderRejectedReason = "UNKNOWN_ORDER"
	OrderRejectedReasonDuplicateOrder                                    OrderRejectedReason = "DUPLICATE_ORDER"
	OrderRejectedReasonStaleOrder                                        OrderRejectedReason = "STALE_ORDER"
	OrderRejectedReasonBelowNotionalMinimum                              OrderRejectedReason = "BELOW_NOTIONAL_MINIMUM"
	OrderRejectedReasonOrderDateUnavailable                              OrderRejectedReason = "ORDER_DATE_UNAVAILABLE"
	OrderRejectedReasonAggressiveLimitPrice                              OrderRejectedReason = "AGGRESSIVE_LIMIT_PRICE"
	OrderRejectedReasonAccountNotEntitled                                OrderRejectedReason = "ACCOUNT_NOT_ENTITLED"
	OrderRejectedReasonSystemError                                       OrderRejectedReason = "SYSTEM_ERROR"
	OrderRejectedReasonBlockingCorporateAction                           OrderRejectedReason = "BLOCKING_CORPORATE_ACTION"
	OrderRejectedReasonUnavailablePriceQuote                             OrderRejectedReason = "UNAVAILABLE_PRICE_QUOTE"
	OrderRejectedReasonExecutionMisconfiguredClient                      OrderRejectedReason = "EXECUTION_MISCONFIGURED_CLIENT"
	OrderRejectedReasonNotionalQuantityNotAllowedForSecurity             OrderRejectedReason = "NOTIONAL_QUANTITY_NOT_ALLOWED_FOR_SECURITY"
	OrderRejectedReasonFractionalQuantityNotAllowedForSecurity           OrderRejectedReason = "FRACTIONAL_QUANTITY_NOT_ALLOWED_FOR_SECURITY"
	OrderRejectedReasonOnlyFractionalSellOrWholeOrdersAllowedForSecurity OrderRejectedReason = "ONLY_FRACTIONAL_SELL_OR_WHOLE_ORDERS_ALLOWED_FOR_SECURITY"
	OrderRejectedReasonSymbolNotTradeable                                OrderRejectedReason = "SYMBOL_NOT_TRADEABLE"
	OrderRejectedReasonAboveNotionalMaximum                              OrderRejectedReason = "ABOVE_NOTIONAL_MAXIMUM"
	OrderRejectedReasonAboveShareMaximum                                 OrderRejectedReason = "ABOVE_SHARE_MAXIMUM"
	OrderRejectedReasonFailedBuyingPower                                 OrderRejectedReason = "FAILED_BUYING_POWER"
	OrderRejectedReasonInsufficientPosition                              OrderRejectedReason = "INSUFFICIENT_POSITION"
	OrderRejectedReasonMaxSellQuantityRequired                           OrderRejectedReason = "MAX_SELL_QUANTITY_REQUIRED"
	OrderRejectedReasonMaxSellQuantityProhibited                         OrderRejectedReason = "MAX_SELL_QUANTITY_PROHIBITED"
	OrderRejectedReasonStopPriceExceedsMarketPrice                       OrderRejectedReason = "STOP_PRICE_EXCEEDS_MARKET_PRICE"
	OrderRejectedReasonTradesDisabledForAssetType                        OrderRejectedReason = "TRADES_DISABLED_FOR_ASSET_TYPE"
	OrderRejectedReasonCommissionNotAllowedForNonBrokerDealer            OrderRejectedReason = "COMMISSION_NOT_ALLOWED_FOR_NON_BROKER_DEALER"
	OrderRejectedReasonAssetNotSetUpToTrade                              OrderRejectedReason = "ASSET_NOT_SET_UP_TO_TRADE"
	OrderRejectedReasonInvalidOrderQuantity                              OrderRejectedReason = "INVALID_ORDER_QUANTITY"
	OrderRejectedReasonClientReceivedTimeRequired                        OrderRejectedReason = "CLIENT_RECEIVED_TIME_REQUIRED"
)

func (e OrderRejectedReason) ToPointer() *OrderRejectedReason {
	return &e
}
func (e *OrderRejectedReason) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ORDER_REJECT_REASON_UNSPECIFIED":
		fallthrough
	case "BROKER_OPTION":
		fallthrough
	case "UNKNOWN_SECURITY":
		fallthrough
	case "EXCHANGE_CLOSED":
		fallthrough
	case "ORDER_EXCEEDS_LIMIT":
		fallthrough
	case "TOO_LATE_TO_ENTER":
		fallthrough
	case "UNKNOWN_ORDER":
		fallthrough
	case "DUPLICATE_ORDER":
		fallthrough
	case "STALE_ORDER":
		fallthrough
	case "BELOW_NOTIONAL_MINIMUM":
		fallthrough
	case "ORDER_DATE_UNAVAILABLE":
		fallthrough
	case "AGGRESSIVE_LIMIT_PRICE":
		fallthrough
	case "ACCOUNT_NOT_ENTITLED":
		fallthrough
	case "SYSTEM_ERROR":
		fallthrough
	case "BLOCKING_CORPORATE_ACTION":
		fallthrough
	case "UNAVAILABLE_PRICE_QUOTE":
		fallthrough
	case "EXECUTION_MISCONFIGURED_CLIENT":
		fallthrough
	case "NOTIONAL_QUANTITY_NOT_ALLOWED_FOR_SECURITY":
		fallthrough
	case "FRACTIONAL_QUANTITY_NOT_ALLOWED_FOR_SECURITY":
		fallthrough
	case "ONLY_FRACTIONAL_SELL_OR_WHOLE_ORDERS_ALLOWED_FOR_SECURITY":
		fallthrough
	case "SYMBOL_NOT_TRADEABLE":
		fallthrough
	case "ABOVE_NOTIONAL_MAXIMUM":
		fallthrough
	case "ABOVE_SHARE_MAXIMUM":
		fallthrough
	case "FAILED_BUYING_POWER":
		fallthrough
	case "INSUFFICIENT_POSITION":
		fallthrough
	case "MAX_SELL_QUANTITY_REQUIRED":
		fallthrough
	case "MAX_SELL_QUANTITY_PROHIBITED":
		fallthrough
	case "STOP_PRICE_EXCEEDS_MARKET_PRICE":
		fallthrough
	case "TRADES_DISABLED_FOR_ASSET_TYPE":
		fallthrough
	case "COMMISSION_NOT_ALLOWED_FOR_NON_BROKER_DEALER":
		fallthrough
	case "ASSET_NOT_SET_UP_TO_TRADE":
		fallthrough
	case "INVALID_ORDER_QUANTITY":
		fallthrough
	case "CLIENT_RECEIVED_TIME_REQUIRED":
		*e = OrderRejectedReason(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderRejectedReason: %v", v)
	}
}

// OrderStatus - The processing status of the order
type OrderStatus string

const (
	OrderStatusOrderStatusUnspecified OrderStatus = "ORDER_STATUS_UNSPECIFIED"
	OrderStatusPendingNew             OrderStatus = "PENDING_NEW"
	OrderStatusNew                    OrderStatus = "NEW"
	OrderStatusPendingQueued          OrderStatus = "PENDING_QUEUED"
	OrderStatusQueued                 OrderStatus = "QUEUED"
	OrderStatusPartiallyFilled        OrderStatus = "PARTIALLY_FILLED"
	OrderStatusFilled                 OrderStatus = "FILLED"
	OrderStatusPendingCancel          OrderStatus = "PENDING_CANCEL"
	OrderStatusCanceled               OrderStatus = "CANCELED"
	OrderStatusRejected               OrderStatus = "REJECTED"
)

func (e OrderStatus) ToPointer() *OrderStatus {
	return &e
}
func (e *OrderStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ORDER_STATUS_UNSPECIFIED":
		fallthrough
	case "PENDING_NEW":
		fallthrough
	case "NEW":
		fallthrough
	case "PENDING_QUEUED":
		fallthrough
	case "QUEUED":
		fallthrough
	case "PARTIALLY_FILLED":
		fallthrough
	case "FILLED":
		fallthrough
	case "PENDING_CANCEL":
		fallthrough
	case "CANCELED":
		fallthrough
	case "REJECTED":
		*e = OrderStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderStatus: %v", v)
	}
}

// OrderOrderType - The execution type of this order. For Equities: MARKET, LIMIT, or STOP are supported. For Mutual Funds: only MARKET is supported. For Fixed Income: only LIMIT is supported.
type OrderOrderType string

const (
	OrderOrderTypeOrderTypeUnspecified OrderOrderType = "ORDER_TYPE_UNSPECIFIED"
	OrderOrderTypeLimit                OrderOrderType = "LIMIT"
	OrderOrderTypeMarket               OrderOrderType = "MARKET"
	OrderOrderTypeStop                 OrderOrderType = "STOP"
)

func (e OrderOrderType) ToPointer() *OrderOrderType {
	return &e
}
func (e *OrderOrderType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ORDER_TYPE_UNSPECIFIED":
		fallthrough
	case "LIMIT":
		fallthrough
	case "MARKET":
		fallthrough
	case "STOP":
		*e = OrderOrderType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderOrderType: %v", v)
	}
}

// OrderPrevailingMarketPrice - The prevailing market price, calculated as a weighted average of the fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no executions.
type OrderPrevailingMarketPrice struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *OrderPrevailingMarketPrice) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OrderQuantity - Numeric quantity of the order. For Equities: Represents the number of shares, must be greater than zero and may not exceed 5 decimal places. For Mutual Funds: Only supported for SELL orders. Represents the number of shares, up to a maximum of 3 decimal places. For Fixed Income: Represents the par (face-value) amount being ordered, and may not exceed two decimal places for USD-based currencies. Either a quantity or notional_value MUST be specified (but not both).
type OrderQuantity struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *OrderQuantity) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OrderSide - The side of this order.
type OrderSide string

const (
	OrderSideSideUnspecified OrderSide = "SIDE_UNSPECIFIED"
	OrderSideBuy             OrderSide = "BUY"
	OrderSideSell            OrderSide = "SELL"
)

func (e OrderSide) ToPointer() *OrderSide {
	return &e
}
func (e *OrderSide) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SIDE_UNSPECIFIED":
		fallthrough
	case "BUY":
		fallthrough
	case "SELL":
		*e = OrderSide(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderSide: %v", v)
	}
}

type OrderSpecialReportingInstructions string

const (
	OrderSpecialReportingInstructionsSpecialReportingInstructionsUnspecified OrderSpecialReportingInstructions = "SPECIAL_REPORTING_INSTRUCTIONS_UNSPECIFIED"
	OrderSpecialReportingInstructionsCustomerDirected                        OrderSpecialReportingInstructions = "CUSTOMER_DIRECTED"
	OrderSpecialReportingInstructionsWithDividend                            OrderSpecialReportingInstructions = "WITH_DIVIDEND"
	OrderSpecialReportingInstructionsWithRights                              OrderSpecialReportingInstructions = "WITH_RIGHTS"
	OrderSpecialReportingInstructionsDiscretionExercised                     OrderSpecialReportingInstructions = "DISCRETION_EXERCISED"
	OrderSpecialReportingInstructionsDiscretionNotExercised                  OrderSpecialReportingInstructions = "DISCRETION_NOT_EXERCISED"
	OrderSpecialReportingInstructionsBrokerDealerOrder                       OrderSpecialReportingInstructions = "BROKER_DEALER_ORDER"
	OrderSpecialReportingInstructionsFullyRegistered                         OrderSpecialReportingInstructions = "FULLY_REGISTERED"
	OrderSpecialReportingInstructionsOddlotDiffOnRequest                     OrderSpecialReportingInstructions = "ODDLOT_DIFF_ON_REQUEST"
	OrderSpecialReportingInstructionsProspectusEnclosed                      OrderSpecialReportingInstructions = "PROSPECTUS_ENCLOSED"
	OrderSpecialReportingInstructionsProspectusSeparateMail                  OrderSpecialReportingInstructions = "PROSPECTUS_SEPARATE_MAIL"
	OrderSpecialReportingInstructionsSolicited                               OrderSpecialReportingInstructions = "SOLICITED"
	OrderSpecialReportingInstructionsUnsolicited                             OrderSpecialReportingInstructions = "UNSOLICITED"
	OrderSpecialReportingInstructionsXDividend                               OrderSpecialReportingInstructions = "X_DIVIDEND"
	OrderSpecialReportingInstructionsActingAsPrincipal                       OrderSpecialReportingInstructions = "ACTING_AS_PRINCIPAL"
	OrderSpecialReportingInstructionsAveragePrice                            OrderSpecialReportingInstructions = "AVERAGE_PRICE"
	OrderSpecialReportingInstructionsBrokerLiquidation                       OrderSpecialReportingInstructions = "BROKER_LIQUIDATION"
	OrderSpecialReportingInstructionsInternetOrder                           OrderSpecialReportingInstructions = "INTERNET_ORDER"
	OrderSpecialReportingInstructionsMarginSellout                           OrderSpecialReportingInstructions = "MARGIN_SELLOUT"
	OrderSpecialReportingInstructionsNegativeNetProceed                      OrderSpecialReportingInstructions = "NEGATIVE_NET_PROCEED"
	OrderSpecialReportingInstructionsRisklessPrincipal                       OrderSpecialReportingInstructions = "RISKLESS_PRINCIPAL"
	OrderSpecialReportingInstructionsThirdMarket                             OrderSpecialReportingInstructions = "THIRD_MARKET"
	OrderSpecialReportingInstructionsSuppressTraceReporting                  OrderSpecialReportingInstructions = "SUPPRESS_TRACE_REPORTING"
	OrderSpecialReportingInstructionsWhenDistributed                         OrderSpecialReportingInstructions = "WHEN_DISTRIBUTED"
)

func (e OrderSpecialReportingInstructions) ToPointer() *OrderSpecialReportingInstructions {
	return &e
}
func (e *OrderSpecialReportingInstructions) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SPECIAL_REPORTING_INSTRUCTIONS_UNSPECIFIED":
		fallthrough
	case "CUSTOMER_DIRECTED":
		fallthrough
	case "WITH_DIVIDEND":
		fallthrough
	case "WITH_RIGHTS":
		fallthrough
	case "DISCRETION_EXERCISED":
		fallthrough
	case "DISCRETION_NOT_EXERCISED":
		fallthrough
	case "BROKER_DEALER_ORDER":
		fallthrough
	case "FULLY_REGISTERED":
		fallthrough
	case "ODDLOT_DIFF_ON_REQUEST":
		fallthrough
	case "PROSPECTUS_ENCLOSED":
		fallthrough
	case "PROSPECTUS_SEPARATE_MAIL":
		fallthrough
	case "SOLICITED":
		fallthrough
	case "UNSOLICITED":
		fallthrough
	case "X_DIVIDEND":
		fallthrough
	case "ACTING_AS_PRINCIPAL":
		fallthrough
	case "AVERAGE_PRICE":
		fallthrough
	case "BROKER_LIQUIDATION":
		fallthrough
	case "INTERNET_ORDER":
		fallthrough
	case "MARGIN_SELLOUT":
		fallthrough
	case "NEGATIVE_NET_PROCEED":
		fallthrough
	case "RISKLESS_PRINCIPAL":
		fallthrough
	case "THIRD_MARKET":
		fallthrough
	case "SUPPRESS_TRACE_REPORTING":
		fallthrough
	case "WHEN_DISTRIBUTED":
		*e = OrderSpecialReportingInstructions(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderSpecialReportingInstructions: %v", v)
	}
}

// OrderStopPricePrice - The stop price which must be greater than zero if provided. For equity orders in the USD currency, up to 2 decimal places are allowed for prices above $1 and up to 4 decimal places for prices at or below $1.
type OrderStopPricePrice struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *OrderStopPricePrice) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OrderStopPriceType - The type of this price, which must PRICE_PER_UNIT for equity orders. (Fixed income and mutual fund assets do not support stop orders.)
type OrderStopPriceType string

const (
	OrderStopPriceTypeStopPriceTypeUnspecified OrderStopPriceType = "STOP_PRICE_TYPE_UNSPECIFIED"
	OrderStopPriceTypePricePerUnit             OrderStopPriceType = "PRICE_PER_UNIT"
)

func (e OrderStopPriceType) ToPointer() *OrderStopPriceType {
	return &e
}
func (e *OrderStopPriceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STOP_PRICE_TYPE_UNSPECIFIED":
		fallthrough
	case "PRICE_PER_UNIT":
		*e = OrderStopPriceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderStopPriceType: %v", v)
	}
}

// StopPrice - The stop price for this order. Only allowed for equities, when the side is SELL.
type StopPrice struct {
	// The stop price which must be greater than zero if provided. For equity orders in the USD currency, up to 2 decimal places are allowed for prices above $1 and up to 4 decimal places for prices at or below $1.
	Price *OrderStopPricePrice `json:"price,omitempty"`
	// The type of this price, which must PRICE_PER_UNIT for equity orders. (Fixed income and mutual fund assets do not support stop orders.)
	Type *OrderStopPriceType `json:"type,omitempty"`
}

func (o *StopPrice) GetPrice() *OrderStopPricePrice {
	if o == nil {
		return nil
	}
	return o.Price
}

func (o *StopPrice) GetType() *OrderStopPriceType {
	if o == nil {
		return nil
	}
	return o.Type
}

// OrderTimeInForce - Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
type OrderTimeInForce string

const (
	OrderTimeInForceTimeInForceUnspecified OrderTimeInForce = "TIME_IN_FORCE_UNSPECIFIED"
	OrderTimeInForceDay                    OrderTimeInForce = "DAY"
)

func (e OrderTimeInForce) ToPointer() *OrderTimeInForce {
	return &e
}
func (e *OrderTimeInForce) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TIME_IN_FORCE_UNSPECIFIED":
		fallthrough
	case "DAY":
		*e = OrderTimeInForce(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OrderTimeInForce: %v", v)
	}
}

// Order - The message describing an order
type Order struct {
	// The identifier of the account transacting this order
	AccountID *string `json:"account_id,omitempty"`
	// Apex Asset ID for this asset. This will not be returned in the initial CreateOrder response and will be available after an order completes validation. If the provided identifier does not match any Apex asset available for trading, an OrderRejectReason of "UNKNOWN_SECURITY" will be returned and the asset_id will not be set.
	AssetID *string `json:"asset_id,omitempty"`
	// The type of the asset in this order
	AssetType *OrderAssetType `json:"asset_type,omitempty"`
	// The average prices, as weighted averages, across all executions in this order. Will be absent if an order has no executions.
	//
	//  When asset_type = EQUITY or MUTUAL_FUND, there will be at most one value present, with a type of PRICE_PER_UNIT. This will have up to 4 decimal places for USD amounts less than $1, and a maximum of two for larger USD amounts.
	//
	//  When asset_type = FIXED_INCOME, there may be more than one value present which would have a type other than PRICE_PER_UNIT. Price values in PERCENTAGE_OF_PAR will have up to 4 decimal places of precision, and price values measured in yields will support up to 5 decimal places.
	AveragePrices []ExecutedPrice `json:"average_prices,omitempty"`
	// Defaults to "AGENCY" if not specified. For Equities: Only "AGENCY" is allowed. For Mutual Funds: Only "AGENCY" is allowed. For Fixed Income: Either "AGENCY" or "PRINCIPAL" are allowed.
	BrokerCapacity *OrderBrokerCapacity `json:"broker_capacity,omitempty"`
	// Used to explain why an order is canceled
	CancelReason *string `json:"cancel_reason,omitempty"`
	// Used to denote when a cancel request has been rejected.
	CancelRejectedReason *CancelRejectedReason `json:"cancel_rejected_reason,omitempty"`
	// User-supplied unique order ID. Cannot be more than 40 characters long.
	ClientOrderID *string `json:"client_order_id,omitempty"`
	// Required for Equity Orders for any client who is having Apex do CAT reporting on their behalf. A value may be provided for non-Equity orders, and will be remembered, but valid timestamps will have no impact on how they are processed.
	ClientReceivedTime *time.Time `json:"client_received_time,omitempty"`
	// A custom commission to be applied to this order. When specifying an AMOUNT type, the value represents a notional amount measured in the currency of the order.
	Commission *OrderCommission `json:"commission,omitempty"`
	// Time of the order creation
	CreateTime *time.Time `json:"create_time,omitempty"`
	// The sum of order quantity & price, across all fills, reported in the currency specified in the order. (This will be rounded to 2 decimal places for USD currencies). Will be absent if an order has no fill information.
	CumulativeNotionalValue *CumulativeNotionalValue `json:"cumulative_notional_value,omitempty"`
	// Defaults to "USD". Only "USD" is supported. Full list of currency codes is defined at: https://en.wikipedia.org/wiki/ISO_4217
	CurrencyCode *string `json:"currency_code,omitempty"`
	// The execution-level details that compose this order
	Executions []Executions `json:"executions,omitempty"`
	// The summed quantity value across all fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no fill information.
	FilledQuantity *FilledQuantity `json:"filled_quantity,omitempty"`
	// Identifier of the asset (of the type specified in `identifier_type`).
	Identifier *string `json:"identifier,omitempty"`
	// The identifier type of the asset being ordered. For Equities: only SYMBOL is supported For Mutual Funds: only SYMBOL and CUSIP are supported For Fixed Income: only CUSIP and ISIN are supported
	IdentifierType *OrderIdentifierType `json:"identifier_type,omitempty"`
	// Time of the last order update
	LastUpdateTime *time.Time `json:"last_update_time,omitempty"`
	// The limit price for this order.
	LimitPrice *LimitPrice `json:"limit_price,omitempty"`
	// The maximum number of shares to be sold if this is a notional SELL order of an Equity asset type. (Prohibited for other side or asset_type inputs.)
	//
	//  This will only be recognized for clients configured not to use OMS checks. When specified, must be greater than 0 and can't exceed 5 decimal places.
	MaxSellQuantity *MaxSellQuantity `json:"max_sell_quantity,omitempty"`
	// System generated name of the order.
	Name *string `json:"name,omitempty"`
	// Notional quantity of the order, measured in USD. Maximum 2 decimal place precision. For Equities: This represents the maximum amount to be spent. The final order may may have a smaller notional amount. For Mutual Funds: Only supported for BUY orders. The order will be transacted at the full notional amount specified. For Fixed Income: Not supported, you must specify a `quantity` value.
	NotionalValue *NotionalValue `json:"notional_value,omitempty"`
	// The date on which the order will go to the market: must either be "today" or the next valid trading day. If the current day is not a valid trading day, then the next valid market day must be specified. If the current time is within 5 minutes prior to market close, the next valid market day may be specified. If the current time is after market close, and before midnight Eastern, then the next valid market day must be specified. In all other cases, the current day, Eastern must be specified.
	OrderDate *OrderDate `json:"order_date,omitempty"`
	// System generated unique id for the order.
	OrderID *string `json:"order_id,omitempty"`
	// When an order has the REJECTED status, this will be populated with a system code describing the rejection.
	OrderRejectedReason *OrderRejectedReason `json:"order_rejected_reason,omitempty"`
	// The processing status of the order
	OrderStatus *OrderStatus `json:"order_status,omitempty"`
	// The execution type of this order. For Equities: MARKET, LIMIT, or STOP are supported. For Mutual Funds: only MARKET is supported. For Fixed Income: only LIMIT is supported.
	OrderType *OrderOrderType `json:"order_type,omitempty"`
	// The prevailing market price, calculated as a weighted average of the fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no executions.
	PrevailingMarketPrice *OrderPrevailingMarketPrice `json:"prevailing_market_price,omitempty"`
	// Numeric quantity of the order. For Equities: Represents the number of shares, must be greater than zero and may not exceed 5 decimal places. For Mutual Funds: Only supported for SELL orders. Represents the number of shares, up to a maximum of 3 decimal places. For Fixed Income: Represents the par (face-value) amount being ordered, and may not exceed two decimal places for USD-based currencies. Either a quantity or notional_value MUST be specified (but not both).
	Quantity *OrderQuantity `json:"quantity,omitempty"`
	// The side of this order.
	Side *OrderSide `json:"side,omitempty"`
	// Special Reporting Instructions to be applied to this order. Can include multiple Instructions.
	SpecialReportingInstructions []OrderSpecialReportingInstructions `json:"special_reporting_instructions,omitempty"`
	// The stop price for this order. Only allowed for equities, when the side is SELL.
	StopPrice *StopPrice `json:"stop_price,omitempty"`
	// Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
	TimeInForce *OrderTimeInForce `json:"time_in_force,omitempty"`
}

func (o Order) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *Order) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *Order) GetAccountID() *string {
	if o == nil {
		return nil
	}
	return o.AccountID
}

func (o *Order) GetAssetID() *string {
	if o == nil {
		return nil
	}
	return o.AssetID
}

func (o *Order) GetAssetType() *OrderAssetType {
	if o == nil {
		return nil
	}
	return o.AssetType
}

func (o *Order) GetAveragePrices() []ExecutedPrice {
	if o == nil {
		return nil
	}
	return o.AveragePrices
}

func (o *Order) GetBrokerCapacity() *OrderBrokerCapacity {
	if o == nil {
		return nil
	}
	return o.BrokerCapacity
}

func (o *Order) GetCancelReason() *string {
	if o == nil {
		return nil
	}
	return o.CancelReason
}

func (o *Order) GetCancelRejectedReason() *CancelRejectedReason {
	if o == nil {
		return nil
	}
	return o.CancelRejectedReason
}

func (o *Order) GetClientOrderID() *string {
	if o == nil {
		return nil
	}
	return o.ClientOrderID
}

func (o *Order) GetClientReceivedTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.ClientReceivedTime
}

func (o *Order) GetCommission() *OrderCommission {
	if o == nil {
		return nil
	}
	return o.Commission
}

func (o *Order) GetCreateTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreateTime
}

func (o *Order) GetCumulativeNotionalValue() *CumulativeNotionalValue {
	if o == nil {
		return nil
	}
	return o.CumulativeNotionalValue
}

func (o *Order) GetCurrencyCode() *string {
	if o == nil {
		return nil
	}
	return o.CurrencyCode
}

func (o *Order) GetExecutions() []Executions {
	if o == nil {
		return nil
	}
	return o.Executions
}

func (o *Order) GetFilledQuantity() *FilledQuantity {
	if o == nil {
		return nil
	}
	return o.FilledQuantity
}

func (o *Order) GetIdentifier() *string {
	if o == nil {
		return nil
	}
	return o.Identifier
}

func (o *Order) GetIdentifierType() *OrderIdentifierType {
	if o == nil {
		return nil
	}
	return o.IdentifierType
}

func (o *Order) GetLastUpdateTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.LastUpdateTime
}

func (o *Order) GetLimitPrice() *LimitPrice {
	if o == nil {
		return nil
	}
	return o.LimitPrice
}

func (o *Order) GetMaxSellQuantity() *MaxSellQuantity {
	if o == nil {
		return nil
	}
	return o.MaxSellQuantity
}

func (o *Order) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Order) GetNotionalValue() *NotionalValue {
	if o == nil {
		return nil
	}
	return o.NotionalValue
}

func (o *Order) GetOrderDate() *OrderDate {
	if o == nil {
		return nil
	}
	return o.OrderDate
}

func (o *Order) GetOrderID() *string {
	if o == nil {
		return nil
	}
	return o.OrderID
}

func (o *Order) GetOrderRejectedReason() *OrderRejectedReason {
	if o == nil {
		return nil
	}
	return o.OrderRejectedReason
}

func (o *Order) GetOrderStatus() *OrderStatus {
	if o == nil {
		return nil
	}
	return o.OrderStatus
}

func (o *Order) GetOrderType() *OrderOrderType {
	if o == nil {
		return nil
	}
	return o.OrderType
}

func (o *Order) GetPrevailingMarketPrice() *OrderPrevailingMarketPrice {
	if o == nil {
		return nil
	}
	return o.PrevailingMarketPrice
}

func (o *Order) GetQuantity() *OrderQuantity {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *Order) GetSide() *OrderSide {
	if o == nil {
		return nil
	}
	return o.Side
}

func (o *Order) GetSpecialReportingInstructions() []OrderSpecialReportingInstructions {
	if o == nil {
		return nil
	}
	return o.SpecialReportingInstructions
}

func (o *Order) GetStopPrice() *StopPrice {
	if o == nil {
		return nil
	}
	return o.StopPrice
}

func (o *Order) GetTimeInForce() *OrderTimeInForce {
	if o == nil {
		return nil
	}
	return o.TimeInForce
}
