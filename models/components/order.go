// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"time"

	"github.com/afs-public/ascend-sdk-go/internal/utils"
)

// OrderAssetType - The type of the asset in this order, which must be one of the following:
//
//	EQUITY, MUTUAL_FUND, and FIXED_INCOME.
type OrderAssetType string

const (
	OrderAssetTypeEquity      OrderAssetType = "EQUITY"
	OrderAssetTypeFixedIncome OrderAssetType = "FIXED_INCOME"
	OrderAssetTypeMutualFund  OrderAssetType = "MUTUAL_FUND"
)

func (e OrderAssetType) ToPointer() *OrderAssetType {
	return &e
}

// OrderBrokerCapacity - Defaults to "AGENCY" if not specified. For Equities: Only "AGENCY" is allowed. For Mutual Funds: Only "AGENCY" is allowed. For Fixed Income: Either "AGENCY" or "PRINCIPAL" are allowed.
type OrderBrokerCapacity string

const (
	OrderBrokerCapacityBrokerCapacityUnspecified OrderBrokerCapacity = "BROKER_CAPACITY_UNSPECIFIED"
	OrderBrokerCapacityAgency                    OrderBrokerCapacity = "AGENCY"
	OrderBrokerCapacityPrincipal                 OrderBrokerCapacity = "PRINCIPAL"
)

func (e OrderBrokerCapacity) ToPointer() *OrderBrokerCapacity {
	return &e
}

// CancelInitiator - Output only field that is required for Equity Orders for any client who is having Apex do CAT reporting on their behalf. This field denotes the initiator of the cancel request. This field will be present when provided on the CancelOrderRequest
type CancelInitiator string

const (
	CancelInitiatorInitiatorUnspecified CancelInitiator = "INITIATOR_UNSPECIFIED"
	CancelInitiatorFirm                 CancelInitiator = "FIRM"
	CancelInitiatorClient               CancelInitiator = "CLIENT"
)

func (e CancelInitiator) ToPointer() *CancelInitiator {
	return &e
}

// CancelRejectedReason - Used to denote when a cancel request has been rejected.
type CancelRejectedReason string

const (
	CancelRejectedReasonCancelRejectReasonUnspecified                     CancelRejectedReason = "CANCEL_REJECT_REASON_UNSPECIFIED"
	CancelRejectedReasonTooLateToCancel                                   CancelRejectedReason = "TOO_LATE_TO_CANCEL"
	CancelRejectedReasonCancellationUnknownOrder                          CancelRejectedReason = "CANCELLATION_UNKNOWN_ORDER"
	CancelRejectedReasonBrokerExchangeOption                              CancelRejectedReason = "BROKER_EXCHANGE_OPTION"
	CancelRejectedReasonOrderAlreadyInPendingCancelOrPendingReplaceStatus CancelRejectedReason = "ORDER_ALREADY_IN_PENDING_CANCEL_OR_PENDING_REPLACE_STATUS"
	CancelRejectedReasonDuplicate                                         CancelRejectedReason = "DUPLICATE"
	CancelRejectedReasonCancellationSystemError                           CancelRejectedReason = "CANCELLATION_SYSTEM_ERROR"
	CancelRejectedReasonOrderAlreadyCanceled                              CancelRejectedReason = "ORDER_ALREADY_CANCELED"
	CancelRejectedReasonCancellationMisconfiguredClient                   CancelRejectedReason = "CANCELLATION_MISCONFIGURED_CLIENT"
)

func (e CancelRejectedReason) ToPointer() *CancelRejectedReason {
	return &e
}

// OrderCommissionType - The type of commission value being specified. Only the type of "AMOUNT" is supported.
type OrderCommissionType string

const (
	OrderCommissionTypeCommissionTypeUnspecified OrderCommissionType = "COMMISSION_TYPE_UNSPECIFIED"
	OrderCommissionTypeAmount                    OrderCommissionType = "AMOUNT"
)

func (e OrderCommissionType) ToPointer() *OrderCommissionType {
	return &e
}

// Value - The value of this commission. If type = `AMOUNT`, then this expresses a monetary value in same currency denoted on the order itself.
type Value struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *Value) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OrderCommission - A custom commission to be applied to this order. When specifying an AMOUNT type, the value represents a notional amount measured in the currency of the order.
type OrderCommission struct {
	// The type of commission value being specified. Only the type of "AMOUNT" is supported.
	Type *OrderCommissionType `json:"type,omitempty"`
	// The value of this commission. If type = `AMOUNT`, then this expresses a monetary value in same currency denoted on the order itself.
	Value *Value `json:"value,omitempty"`
}

func (o *OrderCommission) GetType() *OrderCommissionType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *OrderCommission) GetValue() *Value {
	if o == nil {
		return nil
	}
	return o.Value
}

// CumulativeNotionalValue - The sum of order quantity & price, across all fills, reported in the currency specified in the order. (This will be rounded to 2 decimal places for USD currencies). Will be absent if an order has no fill information.
type CumulativeNotionalValue struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *CumulativeNotionalValue) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// ExtraReportingData - Any reporting data provided by the SetExtraReportingData endpoint.
type ExtraReportingData struct {
	CancelConfirmedTime *time.Time `json:"cancel_confirmed_time,omitempty"`
}

func (e ExtraReportingData) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ExtraReportingData) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ExtraReportingData) GetCancelConfirmedTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.CancelConfirmedTime
}

// FilledQuantity - The summed quantity value across all fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no fill information.
type FilledQuantity struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *FilledQuantity) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OrderIdentifierType - The identifier type of the asset being ordered. For Equities: only SYMBOL is supported For Mutual Funds: only SYMBOL and CUSIP are supported For Fixed Income: only CUSIP and ISIN are supported
type OrderIdentifierType string

const (
	OrderIdentifierTypeSymbol OrderIdentifierType = "SYMBOL"
	OrderIdentifierTypeCusip  OrderIdentifierType = "CUSIP"
	OrderIdentifierTypeIsin   OrderIdentifierType = "ISIN"
)

func (e OrderIdentifierType) ToPointer() *OrderIdentifierType {
	return &e
}

// OrderAmount - The amount of the LOI. This is a monetary value in the same currency as the order.
type OrderAmount struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *OrderAmount) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// PeriodStartDate - The period start date, specific to the US Eastern Time Zone, of the LOI. Date range: 90 days in the past and 13 months in the future from the order_date.
type PeriodStartDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PeriodStartDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PeriodStartDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PeriodStartDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// LetterOfIntent - Letter of Intent (LOI). An LOI allows investors to receive sales charge discounts based on a commitment to buy a specified monetary amount of shares over a period of time, usually 13 months.
type LetterOfIntent struct {
	// The amount of the LOI. This is a monetary value in the same currency as the order.
	Amount *OrderAmount `json:"amount,omitempty"`
	// The period start date, specific to the US Eastern Time Zone, of the LOI. Date range: 90 days in the past and 13 months in the future from the order_date.
	PeriodStartDate *PeriodStartDate `json:"period_start_date,omitempty"`
}

func (o *LetterOfIntent) GetAmount() *OrderAmount {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *LetterOfIntent) GetPeriodStartDate() *PeriodStartDate {
	if o == nil {
		return nil
	}
	return o.PeriodStartDate
}

// OrderPrice - The limit price which must be greater than zero if provided. For equity orders in the USD currency, up to 2 decimal places are allowed for prices above $1 and up to 4 decimal places for prices at or below $1. For fixed income orders this is expressed as a percentage of par, which allows up to 4 decimal places in the USD currency.
type OrderPrice struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *OrderPrice) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OrderLimitPriceType - The type of this price, which must be PRICE_PER_UNIT for equity orders, or PERCENTAGE_OF_PAR for fixed income orders.
type OrderLimitPriceType string

const (
	OrderLimitPriceTypeLimitPriceTypeUnspecified OrderLimitPriceType = "LIMIT_PRICE_TYPE_UNSPECIFIED"
	OrderLimitPriceTypePricePerUnit              OrderLimitPriceType = "PRICE_PER_UNIT"
	OrderLimitPriceTypePercentageOfPar           OrderLimitPriceType = "PERCENTAGE_OF_PAR"
)

func (e OrderLimitPriceType) ToPointer() *OrderLimitPriceType {
	return &e
}

// LimitPrice - The limit price for this order.
type LimitPrice struct {
	// The limit price which must be greater than zero if provided. For equity orders in the USD currency, up to 2 decimal places are allowed for prices above $1 and up to 4 decimal places for prices at or below $1. For fixed income orders this is expressed as a percentage of par, which allows up to 4 decimal places in the USD currency.
	Price *OrderPrice `json:"price,omitempty"`
	// The type of this price, which must be PRICE_PER_UNIT for equity orders, or PERCENTAGE_OF_PAR for fixed income orders.
	Type *OrderLimitPriceType `json:"type,omitempty"`
}

func (o *LimitPrice) GetPrice() *OrderPrice {
	if o == nil {
		return nil
	}
	return o.Price
}

func (o *LimitPrice) GetType() *OrderLimitPriceType {
	if o == nil {
		return nil
	}
	return o.Type
}

// MaxSellQuantity - The maximum number of shares to be sold if this is a notional SELL order of an Equity asset type. (Prohibited for other side or asset_type inputs.)
//
//	This will only be recognized for clients configured not to use OMS checks. When specified, must be greater than 0 and can't exceed 5 decimal places.
type MaxSellQuantity struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *MaxSellQuantity) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// NotionalValue - Notional quantity of the order, measured in USD. Maximum 2 decimal place precision. For Equities: This represents the maximum amount to be spent. The final order may may have a smaller notional amount. For Mutual Funds: Only supported for BUY orders. The order will be transacted at the full notional amount specified. For Fixed Income: Not supported, you must specify a `quantity` value.
type NotionalValue struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *NotionalValue) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OrderDate - The date on which the order will go to the market: must either be "today" or the next valid trading day. If the current day is not a valid trading day, then the next valid market day must be specified. If the current time is within 5 minutes prior to market close, the next valid market day may be specified. If the current time is after market close, and before midnight Eastern, then the next valid market day must be specified. In all other cases, the current day, Eastern must be specified.
type OrderDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *OrderDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *OrderDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *OrderDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// OrderRejectedReason - When an order has the REJECTED status, this will be populated with a system code describing the rejection.
type OrderRejectedReason string

const (
	OrderRejectedReasonOrderRejectReasonUnspecified                      OrderRejectedReason = "ORDER_REJECT_REASON_UNSPECIFIED"
	OrderRejectedReasonBrokerOption                                      OrderRejectedReason = "BROKER_OPTION"
	OrderRejectedReasonUnknownSecurity                                   OrderRejectedReason = "UNKNOWN_SECURITY"
	OrderRejectedReasonExchangeClosed                                    OrderRejectedReason = "EXCHANGE_CLOSED"
	OrderRejectedReasonOrderExceedsLimit                                 OrderRejectedReason = "ORDER_EXCEEDS_LIMIT"
	OrderRejectedReasonTooLateToEnter                                    OrderRejectedReason = "TOO_LATE_TO_ENTER"
	OrderRejectedReasonUnknownOrder                                      OrderRejectedReason = "UNKNOWN_ORDER"
	OrderRejectedReasonDuplicateOrder                                    OrderRejectedReason = "DUPLICATE_ORDER"
	OrderRejectedReasonStaleOrder                                        OrderRejectedReason = "STALE_ORDER"
	OrderRejectedReasonBelowNotionalMinimum                              OrderRejectedReason = "BELOW_NOTIONAL_MINIMUM"
	OrderRejectedReasonOrderDateUnavailable                              OrderRejectedReason = "ORDER_DATE_UNAVAILABLE"
	OrderRejectedReasonAggressiveLimitPrice                              OrderRejectedReason = "AGGRESSIVE_LIMIT_PRICE"
	OrderRejectedReasonAccountNotEntitled                                OrderRejectedReason = "ACCOUNT_NOT_ENTITLED"
	OrderRejectedReasonSystemError                                       OrderRejectedReason = "SYSTEM_ERROR"
	OrderRejectedReasonBlockingCorporateAction                           OrderRejectedReason = "BLOCKING_CORPORATE_ACTION"
	OrderRejectedReasonUnavailablePriceQuote                             OrderRejectedReason = "UNAVAILABLE_PRICE_QUOTE"
	OrderRejectedReasonExecutionMisconfiguredClient                      OrderRejectedReason = "EXECUTION_MISCONFIGURED_CLIENT"
	OrderRejectedReasonNotionalQuantityNotAllowedForSecurity             OrderRejectedReason = "NOTIONAL_QUANTITY_NOT_ALLOWED_FOR_SECURITY"
	OrderRejectedReasonFractionalQuantityNotAllowedForSecurity           OrderRejectedReason = "FRACTIONAL_QUANTITY_NOT_ALLOWED_FOR_SECURITY"
	OrderRejectedReasonOnlyFractionalSellOrWholeOrdersAllowedForSecurity OrderRejectedReason = "ONLY_FRACTIONAL_SELL_OR_WHOLE_ORDERS_ALLOWED_FOR_SECURITY"
	OrderRejectedReasonSymbolNotTradeable                                OrderRejectedReason = "SYMBOL_NOT_TRADEABLE"
	OrderRejectedReasonAboveNotionalMaximum                              OrderRejectedReason = "ABOVE_NOTIONAL_MAXIMUM"
	OrderRejectedReasonAboveShareMaximum                                 OrderRejectedReason = "ABOVE_SHARE_MAXIMUM"
	OrderRejectedReasonFailedBuyingPower                                 OrderRejectedReason = "FAILED_BUYING_POWER"
	OrderRejectedReasonInsufficientPosition                              OrderRejectedReason = "INSUFFICIENT_POSITION"
	OrderRejectedReasonMaxSellQuantityRequired                           OrderRejectedReason = "MAX_SELL_QUANTITY_REQUIRED"
	OrderRejectedReasonMaxSellQuantityProhibited                         OrderRejectedReason = "MAX_SELL_QUANTITY_PROHIBITED"
	OrderRejectedReasonStopPriceExceedsMarketPrice                       OrderRejectedReason = "STOP_PRICE_EXCEEDS_MARKET_PRICE"
	OrderRejectedReasonTradesDisabledForAssetType                        OrderRejectedReason = "TRADES_DISABLED_FOR_ASSET_TYPE"
	OrderRejectedReasonCommissionNotAllowedForNonBrokerDealer            OrderRejectedReason = "COMMISSION_NOT_ALLOWED_FOR_NON_BROKER_DEALER"
	OrderRejectedReasonAssetNotSetUpToTrade                              OrderRejectedReason = "ASSET_NOT_SET_UP_TO_TRADE"
	OrderRejectedReasonInvalidOrderQuantity                              OrderRejectedReason = "INVALID_ORDER_QUANTITY"
	OrderRejectedReasonClientReceivedTimeRequired                        OrderRejectedReason = "CLIENT_RECEIVED_TIME_REQUIRED"
	OrderRejectedReasonClientNotPermittedToUseTradingSession             OrderRejectedReason = "CLIENT_NOT_PERMITTED_TO_USE_TRADING_SESSION"
	OrderRejectedReasonStopPriceBelowMarketPrice                         OrderRejectedReason = "STOP_PRICE_BELOW_MARKET_PRICE"
)

func (e OrderRejectedReason) ToPointer() *OrderRejectedReason {
	return &e
}

// OrderStatus - The processing status of the order
type OrderStatus string

const (
	OrderStatusOrderStatusUnspecified OrderStatus = "ORDER_STATUS_UNSPECIFIED"
	OrderStatusPendingNew             OrderStatus = "PENDING_NEW"
	OrderStatusNew                    OrderStatus = "NEW"
	OrderStatusPendingQueued          OrderStatus = "PENDING_QUEUED"
	OrderStatusQueued                 OrderStatus = "QUEUED"
	OrderStatusPartiallyFilled        OrderStatus = "PARTIALLY_FILLED"
	OrderStatusFilled                 OrderStatus = "FILLED"
	OrderStatusPendingCancel          OrderStatus = "PENDING_CANCEL"
	OrderStatusCanceled               OrderStatus = "CANCELED"
	OrderStatusRejected               OrderStatus = "REJECTED"
)

func (e OrderStatus) ToPointer() *OrderStatus {
	return &e
}

// OrderOrderType - The execution type of this order. For Equities: MARKET, and LIMIT are supported. For Mutual Funds: only MARKET is supported. For Fixed Income: only LIMIT is supported.
type OrderOrderType string

const (
	OrderOrderTypeLimit  OrderOrderType = "LIMIT"
	OrderOrderTypeMarket OrderOrderType = "MARKET"
)

func (e OrderOrderType) ToPointer() *OrderOrderType {
	return &e
}

// OrderPrevailingMarketPrice - The prevailing market price, calculated as a weighted average of the fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no executions.
type OrderPrevailingMarketPrice struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *OrderPrevailingMarketPrice) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OrderQuantity - Numeric quantity of the order. For Equities: Represents the number of shares, must be greater than zero and may not exceed 5 decimal places. For Mutual Funds: Only supported for SELL orders. Represents the number of shares, up to a maximum of 3 decimal places. For Fixed Income: Represents the par (face-value) amount being ordered, and may not exceed two decimal places for USD-based currencies. Either a quantity or notional_value MUST be specified (but not both).
type OrderQuantity struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *OrderQuantity) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OrderRightsOfAccumulationAmount - The amount of the ROA. This is a monetary value in the same currency as the order. Only 9999999.99 is supported.
type OrderRightsOfAccumulationAmount struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *OrderRightsOfAccumulationAmount) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// RightsOfAccumulation - Rights of Accumulation (ROA). An ROA allows an investor to aggregate their own fund shares with the holdings of certain related parties toward achieving the investment thresholds at which sales charge discounts become available.
type RightsOfAccumulation struct {
	// The amount of the ROA. This is a monetary value in the same currency as the order. Only 9999999.99 is supported.
	Amount *OrderRightsOfAccumulationAmount `json:"amount,omitempty"`
}

func (o *RightsOfAccumulation) GetAmount() *OrderRightsOfAccumulationAmount {
	if o == nil {
		return nil
	}
	return o.Amount
}

// OrderSide - The side of this order.
type OrderSide string

const (
	OrderSideSideUnspecified OrderSide = "SIDE_UNSPECIFIED"
	OrderSideBuy             OrderSide = "BUY"
	OrderSideSell            OrderSide = "SELL"
)

func (e OrderSide) ToPointer() *OrderSide {
	return &e
}

type OrderSpecialReportingInstructions string

const (
	OrderSpecialReportingInstructionsSpecialReportingInstructionsUnspecified OrderSpecialReportingInstructions = "SPECIAL_REPORTING_INSTRUCTIONS_UNSPECIFIED"
	OrderSpecialReportingInstructionsCustomerDirected                        OrderSpecialReportingInstructions = "CUSTOMER_DIRECTED"
	OrderSpecialReportingInstructionsWithDividend                            OrderSpecialReportingInstructions = "WITH_DIVIDEND"
	OrderSpecialReportingInstructionsWithRights                              OrderSpecialReportingInstructions = "WITH_RIGHTS"
	OrderSpecialReportingInstructionsDiscretionExercised                     OrderSpecialReportingInstructions = "DISCRETION_EXERCISED"
	OrderSpecialReportingInstructionsDiscretionNotExercised                  OrderSpecialReportingInstructions = "DISCRETION_NOT_EXERCISED"
	OrderSpecialReportingInstructionsBrokerDealerOrder                       OrderSpecialReportingInstructions = "BROKER_DEALER_ORDER"
	OrderSpecialReportingInstructionsFullyRegistered                         OrderSpecialReportingInstructions = "FULLY_REGISTERED"
	OrderSpecialReportingInstructionsOddlotDiffOnRequest                     OrderSpecialReportingInstructions = "ODDLOT_DIFF_ON_REQUEST"
	OrderSpecialReportingInstructionsProspectusEnclosed                      OrderSpecialReportingInstructions = "PROSPECTUS_ENCLOSED"
	OrderSpecialReportingInstructionsProspectusSeparateMail                  OrderSpecialReportingInstructions = "PROSPECTUS_SEPARATE_MAIL"
	OrderSpecialReportingInstructionsSolicited                               OrderSpecialReportingInstructions = "SOLICITED"
	OrderSpecialReportingInstructionsUnsolicited                             OrderSpecialReportingInstructions = "UNSOLICITED"
	OrderSpecialReportingInstructionsXDividend                               OrderSpecialReportingInstructions = "X_DIVIDEND"
	OrderSpecialReportingInstructionsActingAsPrincipal                       OrderSpecialReportingInstructions = "ACTING_AS_PRINCIPAL"
	OrderSpecialReportingInstructionsAveragePrice                            OrderSpecialReportingInstructions = "AVERAGE_PRICE"
	OrderSpecialReportingInstructionsBrokerLiquidation                       OrderSpecialReportingInstructions = "BROKER_LIQUIDATION"
	OrderSpecialReportingInstructionsInternetOrder                           OrderSpecialReportingInstructions = "INTERNET_ORDER"
	OrderSpecialReportingInstructionsMarginSellout                           OrderSpecialReportingInstructions = "MARGIN_SELLOUT"
	OrderSpecialReportingInstructionsNegativeNetProceed                      OrderSpecialReportingInstructions = "NEGATIVE_NET_PROCEED"
	OrderSpecialReportingInstructionsRisklessPrincipal                       OrderSpecialReportingInstructions = "RISKLESS_PRINCIPAL"
	OrderSpecialReportingInstructionsThirdMarket                             OrderSpecialReportingInstructions = "THIRD_MARKET"
	OrderSpecialReportingInstructionsSuppressTraceReporting                  OrderSpecialReportingInstructions = "SUPPRESS_TRACE_REPORTING"
	OrderSpecialReportingInstructionsWhenDistributed                         OrderSpecialReportingInstructions = "WHEN_DISTRIBUTED"
)

func (e OrderSpecialReportingInstructions) ToPointer() *OrderSpecialReportingInstructions {
	return &e
}

// OrderStopPricePrice - The stop price which must be greater than zero if provided. For equity orders in the USD currency, up to 2 decimal places are allowed for prices above $1 and up to 4 decimal places for prices at or below $1.
type OrderStopPricePrice struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *OrderStopPricePrice) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OrderStopPriceType - The type of this price, which must PRICE_PER_UNIT for equity orders. (Fixed income and mutual fund assets do not support stop orders.)
type OrderStopPriceType string

const (
	OrderStopPriceTypeStopPriceTypeUnspecified OrderStopPriceType = "STOP_PRICE_TYPE_UNSPECIFIED"
	OrderStopPriceTypePricePerUnit             OrderStopPriceType = "PRICE_PER_UNIT"
)

func (e OrderStopPriceType) ToPointer() *OrderStopPriceType {
	return &e
}

// StopPrice - The stop price for this order. Only allowed for equities, when the side is SELL.
type StopPrice struct {
	// The stop price which must be greater than zero if provided. For equity orders in the USD currency, up to 2 decimal places are allowed for prices above $1 and up to 4 decimal places for prices at or below $1.
	Price *OrderStopPricePrice `json:"price,omitempty"`
	// The type of this price, which must PRICE_PER_UNIT for equity orders. (Fixed income and mutual fund assets do not support stop orders.)
	Type *OrderStopPriceType `json:"type,omitempty"`
}

func (o *StopPrice) GetPrice() *OrderStopPricePrice {
	if o == nil {
		return nil
	}
	return o.Price
}

func (o *StopPrice) GetType() *OrderStopPriceType {
	if o == nil {
		return nil
	}
	return o.Type
}

// OrderTimeInForce - Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
type OrderTimeInForce string

const (
	OrderTimeInForceDay OrderTimeInForce = "DAY"
)

func (e OrderTimeInForce) ToPointer() *OrderTimeInForce {
	return &e
}

// OrderTradingSession - Which TradingSession to trade in, defaults to 'CORE'. Only available for Equity orders.
type OrderTradingSession string

const (
	OrderTradingSessionTradingSessionUnspecified OrderTradingSession = "TRADING_SESSION_UNSPECIFIED"
	OrderTradingSessionCore                      OrderTradingSession = "CORE"
	OrderTradingSessionPre                       OrderTradingSession = "PRE"
	OrderTradingSessionPost                      OrderTradingSession = "POST"
	OrderTradingSessionOvernight                 OrderTradingSession = "OVERNIGHT"
	OrderTradingSessionApex24                    OrderTradingSession = "APEX24"
	OrderTradingSessionGtx                       OrderTradingSession = "GTX"
)

func (e OrderTradingSession) ToPointer() *OrderTradingSession {
	return &e
}

// Order - The message describing an order
type Order struct {
	// The identifier of the account transacting this order
	AccountID *string `json:"account_id,omitempty"`
	// Apex Asset ID for this asset. This will not be returned in the initial CreateOrder response and will be available after an order completes validation. If the provided identifier does not match any Apex asset available for trading, an OrderRejectReason of "UNKNOWN_SECURITY" will be returned and the asset_id will not be set.
	AssetID *string `json:"asset_id,omitempty"`
	// The type of the asset in this order, which must be one of the following:
	//  EQUITY, MUTUAL_FUND, and FIXED_INCOME.
	AssetType *OrderAssetType `json:"asset_type,omitempty"`
	// The average prices, as weighted averages, across all executions in this order. Will be absent if an order has no executions.
	//
	//  When asset_type = EQUITY or MUTUAL_FUND, there will be at most one value present, with a type of PRICE_PER_UNIT. This will have up to 4 decimal places for USD amounts less than $1, and a maximum of two for larger USD amounts.
	//
	//  When asset_type = FIXED_INCOME, there may be more than one value present which would have a type other than PRICE_PER_UNIT. Price values in PERCENTAGE_OF_PAR will have up to 4 decimal places of precision, and price values measured in yields will support up to 5 decimal places.
	AveragePrices []TradingExecutedPrice `json:"average_prices,omitempty"`
	// Defaults to "AGENCY" if not specified. For Equities: Only "AGENCY" is allowed. For Mutual Funds: Only "AGENCY" is allowed. For Fixed Income: Either "AGENCY" or "PRINCIPAL" are allowed.
	BrokerCapacity *OrderBrokerCapacity `json:"broker_capacity,omitempty"`
	// Output only field that is required for Equity Orders for any client who is having Apex do CAT reporting on their behalf. This field denotes the initiator of the cancel request. This field will be present when provided on the CancelOrderRequest
	CancelInitiator *CancelInitiator `json:"cancel_initiator,omitempty"`
	// Used to explain why an order is canceled
	CancelReason *string `json:"cancel_reason,omitempty"`
	// Used to denote when a cancel request has been rejected.
	CancelRejectedReason *CancelRejectedReason `json:"cancel_rejected_reason,omitempty"`
	// Output only field for Equity Orders related to CAT reporting on behalf of clients. This field will be present when provided on the CancelOrderRequest
	ClientCancelReceivedTime *time.Time `json:"client_cancel_received_time,omitempty"`
	// User-supplied unique order ID. Cannot be more than 40 characters long.
	ClientOrderID *string `json:"client_order_id,omitempty"`
	// Required for Equity Orders for any client who is having Apex do CAT reporting on their behalf. A value may be provided for non-Equity orders, and will be remembered, but valid timestamps will have no impact on how they are processed.
	ClientReceivedTime *time.Time `json:"client_received_time,omitempty"`
	// A custom commission to be applied to this order. When specifying an AMOUNT type, the value represents a notional amount measured in the currency of the order.
	Commission *OrderCommission `json:"commission,omitempty"`
	// Time of the order creation
	CreateTime *time.Time `json:"create_time,omitempty"`
	// The sum of order quantity & price, across all fills, reported in the currency specified in the order. (This will be rounded to 2 decimal places for USD currencies). Will be absent if an order has no fill information.
	CumulativeNotionalValue *CumulativeNotionalValue `json:"cumulative_notional_value,omitempty"`
	// Defaults to "USD". Only "USD" is supported. Full list of currency codes is defined at: https://en.wikipedia.org/wiki/ISO_4217
	CurrencyCode *string `json:"currency_code,omitempty"`
	// The execution-level details that compose this order
	Executions []TradingExecutions `json:"executions,omitempty"`
	// Any reporting data provided by the SetExtraReportingData endpoint.
	ExtraReportingData *ExtraReportingData `json:"extra_reporting_data,omitempty"`
	// Fees that will be applied to this order. Only the BROKER_FEE type is supported.
	Fees []TradingFee `json:"fees,omitempty"`
	// The summed quantity value across all fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no fill information.
	FilledQuantity *FilledQuantity `json:"filled_quantity,omitempty"`
	// Identifier of the asset (of the type specified in `identifier_type`).
	Identifier *string `json:"identifier,omitempty"`
	// A string attribute denoting the country of issuance or where the asset is trading. Only available for Mutual Fund orders. Defaults to US, when trading non US mutual funds this field must be provided Complies with ISO-3166 Alpha-2 Codes
	IdentifierIssuingRegionCode *string `json:"identifier_issuing_region_code,omitempty"`
	// The identifier type of the asset being ordered. For Equities: only SYMBOL is supported For Mutual Funds: only SYMBOL and CUSIP are supported For Fixed Income: only CUSIP and ISIN are supported
	IdentifierType *OrderIdentifierType `json:"identifier_type,omitempty"`
	// Time of the last order update
	LastUpdateTime *time.Time `json:"last_update_time,omitempty"`
	// Letter of Intent (LOI). An LOI allows investors to receive sales charge discounts based on a commitment to buy a specified monetary amount of shares over a period of time, usually 13 months.
	LetterOfIntent *LetterOfIntent `json:"letter_of_intent,omitempty"`
	// The limit price for this order.
	LimitPrice *LimitPrice `json:"limit_price,omitempty"`
	// The maximum number of shares to be sold if this is a notional SELL order of an Equity asset type. (Prohibited for other side or asset_type inputs.)
	//
	//  This will only be recognized for clients configured not to use OMS checks. When specified, must be greater than 0 and can't exceed 5 decimal places.
	MaxSellQuantity *MaxSellQuantity `json:"max_sell_quantity,omitempty"`
	// System generated name of the order.
	Name *string `json:"name,omitempty"`
	// Notional quantity of the order, measured in USD. Maximum 2 decimal place precision. For Equities: This represents the maximum amount to be spent. The final order may may have a smaller notional amount. For Mutual Funds: Only supported for BUY orders. The order will be transacted at the full notional amount specified. For Fixed Income: Not supported, you must specify a `quantity` value.
	NotionalValue *NotionalValue `json:"notional_value,omitempty"`
	// The date on which the order will go to the market: must either be "today" or the next valid trading day. If the current day is not a valid trading day, then the next valid market day must be specified. If the current time is within 5 minutes prior to market close, the next valid market day may be specified. If the current time is after market close, and before midnight Eastern, then the next valid market day must be specified. In all other cases, the current day, Eastern must be specified.
	OrderDate *OrderDate `json:"order_date,omitempty"`
	// System generated unique id for the order.
	OrderID *string `json:"order_id,omitempty"`
	// When an order has the REJECTED status, this will be populated with a system code describing the rejection.
	OrderRejectedReason *OrderRejectedReason `json:"order_rejected_reason,omitempty"`
	// The processing status of the order
	OrderStatus *OrderStatus `json:"order_status,omitempty"`
	// The execution type of this order. For Equities: MARKET, and LIMIT are supported. For Mutual Funds: only MARKET is supported. For Fixed Income: only LIMIT is supported.
	OrderType *OrderOrderType `json:"order_type,omitempty"`
	// The prevailing market price, calculated as a weighted average of the fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no executions.
	PrevailingMarketPrice *OrderPrevailingMarketPrice `json:"prevailing_market_price,omitempty"`
	// Numeric quantity of the order. For Equities: Represents the number of shares, must be greater than zero and may not exceed 5 decimal places. For Mutual Funds: Only supported for SELL orders. Represents the number of shares, up to a maximum of 3 decimal places. For Fixed Income: Represents the par (face-value) amount being ordered, and may not exceed two decimal places for USD-based currencies. Either a quantity or notional_value MUST be specified (but not both).
	Quantity *OrderQuantity `json:"quantity,omitempty"`
	// Rights of Accumulation (ROA). An ROA allows an investor to aggregate their own fund shares with the holdings of certain related parties toward achieving the investment thresholds at which sales charge discounts become available.
	RightsOfAccumulation *RightsOfAccumulation `json:"rights_of_accumulation,omitempty"`
	// The side of this order.
	Side *OrderSide `json:"side,omitempty"`
	// Special Reporting Instructions to be applied to this order. Can include multiple Instructions.
	SpecialReportingInstructions []OrderSpecialReportingInstructions `json:"special_reporting_instructions,omitempty"`
	// The stop price for this order. Only allowed for equities, when the side is SELL.
	StopPrice *StopPrice `json:"stop_price,omitempty"`
	// Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
	TimeInForce *OrderTimeInForce `json:"time_in_force,omitempty"`
	// Which TradingSession to trade in, defaults to 'CORE'. Only available for Equity orders.
	TradingSession *OrderTradingSession `json:"trading_session,omitempty"`
}

func (o Order) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *Order) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *Order) GetAccountID() *string {
	if o == nil {
		return nil
	}
	return o.AccountID
}

func (o *Order) GetAssetID() *string {
	if o == nil {
		return nil
	}
	return o.AssetID
}

func (o *Order) GetAssetType() *OrderAssetType {
	if o == nil {
		return nil
	}
	return o.AssetType
}

func (o *Order) GetAveragePrices() []TradingExecutedPrice {
	if o == nil {
		return nil
	}
	return o.AveragePrices
}

func (o *Order) GetBrokerCapacity() *OrderBrokerCapacity {
	if o == nil {
		return nil
	}
	return o.BrokerCapacity
}

func (o *Order) GetCancelInitiator() *CancelInitiator {
	if o == nil {
		return nil
	}
	return o.CancelInitiator
}

func (o *Order) GetCancelReason() *string {
	if o == nil {
		return nil
	}
	return o.CancelReason
}

func (o *Order) GetCancelRejectedReason() *CancelRejectedReason {
	if o == nil {
		return nil
	}
	return o.CancelRejectedReason
}

func (o *Order) GetClientCancelReceivedTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.ClientCancelReceivedTime
}

func (o *Order) GetClientOrderID() *string {
	if o == nil {
		return nil
	}
	return o.ClientOrderID
}

func (o *Order) GetClientReceivedTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.ClientReceivedTime
}

func (o *Order) GetCommission() *OrderCommission {
	if o == nil {
		return nil
	}
	return o.Commission
}

func (o *Order) GetCreateTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreateTime
}

func (o *Order) GetCumulativeNotionalValue() *CumulativeNotionalValue {
	if o == nil {
		return nil
	}
	return o.CumulativeNotionalValue
}

func (o *Order) GetCurrencyCode() *string {
	if o == nil {
		return nil
	}
	return o.CurrencyCode
}

func (o *Order) GetExecutions() []TradingExecutions {
	if o == nil {
		return nil
	}
	return o.Executions
}

func (o *Order) GetExtraReportingData() *ExtraReportingData {
	if o == nil {
		return nil
	}
	return o.ExtraReportingData
}

func (o *Order) GetFees() []TradingFee {
	if o == nil {
		return nil
	}
	return o.Fees
}

func (o *Order) GetFilledQuantity() *FilledQuantity {
	if o == nil {
		return nil
	}
	return o.FilledQuantity
}

func (o *Order) GetIdentifier() *string {
	if o == nil {
		return nil
	}
	return o.Identifier
}

func (o *Order) GetIdentifierIssuingRegionCode() *string {
	if o == nil {
		return nil
	}
	return o.IdentifierIssuingRegionCode
}

func (o *Order) GetIdentifierType() *OrderIdentifierType {
	if o == nil {
		return nil
	}
	return o.IdentifierType
}

func (o *Order) GetLastUpdateTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.LastUpdateTime
}

func (o *Order) GetLetterOfIntent() *LetterOfIntent {
	if o == nil {
		return nil
	}
	return o.LetterOfIntent
}

func (o *Order) GetLimitPrice() *LimitPrice {
	if o == nil {
		return nil
	}
	return o.LimitPrice
}

func (o *Order) GetMaxSellQuantity() *MaxSellQuantity {
	if o == nil {
		return nil
	}
	return o.MaxSellQuantity
}

func (o *Order) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Order) GetNotionalValue() *NotionalValue {
	if o == nil {
		return nil
	}
	return o.NotionalValue
}

func (o *Order) GetOrderDate() *OrderDate {
	if o == nil {
		return nil
	}
	return o.OrderDate
}

func (o *Order) GetOrderID() *string {
	if o == nil {
		return nil
	}
	return o.OrderID
}

func (o *Order) GetOrderRejectedReason() *OrderRejectedReason {
	if o == nil {
		return nil
	}
	return o.OrderRejectedReason
}

func (o *Order) GetOrderStatus() *OrderStatus {
	if o == nil {
		return nil
	}
	return o.OrderStatus
}

func (o *Order) GetOrderType() *OrderOrderType {
	if o == nil {
		return nil
	}
	return o.OrderType
}

func (o *Order) GetPrevailingMarketPrice() *OrderPrevailingMarketPrice {
	if o == nil {
		return nil
	}
	return o.PrevailingMarketPrice
}

func (o *Order) GetQuantity() *OrderQuantity {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *Order) GetRightsOfAccumulation() *RightsOfAccumulation {
	if o == nil {
		return nil
	}
	return o.RightsOfAccumulation
}

func (o *Order) GetSide() *OrderSide {
	if o == nil {
		return nil
	}
	return o.Side
}

func (o *Order) GetSpecialReportingInstructions() []OrderSpecialReportingInstructions {
	if o == nil {
		return nil
	}
	return o.SpecialReportingInstructions
}

func (o *Order) GetStopPrice() *StopPrice {
	if o == nil {
		return nil
	}
	return o.StopPrice
}

func (o *Order) GetTimeInForce() *OrderTimeInForce {
	if o == nil {
		return nil
	}
	return o.TimeInForce
}

func (o *Order) GetTradingSession() *OrderTradingSession {
	if o == nil {
		return nil
	}
	return o.TradingSession
}
