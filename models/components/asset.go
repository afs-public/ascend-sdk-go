// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

// CurrencyType - Indicates the type of currency
type CurrencyType string

const (
	CurrencyTypeCurrencyTypeUnspecified CurrencyType = "CURRENCY_TYPE_UNSPECIFIED"
	CurrencyTypeCurrency                CurrencyType = "CURRENCY"
	CurrencyTypeCurrencyEquivalent      CurrencyType = "CURRENCY_EQUIVALENT"
)

func (e CurrencyType) ToPointer() *CurrencyType {
	return &e
}

// Currency specific asset details
type Currency struct {
	// Indicates the type of currency
	CurrencyType *CurrencyType `json:"currency_type,omitempty"`
	// Indicates the name of asset for the underlying payment_currency when the `currency_type` is `CURRENCY_EQUIVALENT`
	PaymentCurrency *string `json:"payment_currency,omitempty"`
}

func (o *Currency) GetCurrencyType() *CurrencyType {
	if o == nil {
		return nil
	}
	return o.CurrencyType
}

func (o *Currency) GetPaymentCurrency() *string {
	if o == nil {
		return nil
	}
	return o.PaymentCurrency
}

// AssetEquityType - the code indicating the type of associated security.
type AssetEquityType string

const (
	AssetEquityTypeEquityTypeUnspecified      AssetEquityType = "EQUITY_TYPE_UNSPECIFIED"
	AssetEquityTypeCommonStock                AssetEquityType = "COMMON_STOCK"
	AssetEquityTypePreferredStock             AssetEquityType = "PREFERRED_STOCK"
	AssetEquityTypePreferredAdr               AssetEquityType = "PREFERRED_ADR"
	AssetEquityTypeSpecialStock               AssetEquityType = "SPECIAL_STOCK"
	AssetEquityTypeIndex                      AssetEquityType = "INDEX"
	AssetEquityTypeWarrant                    AssetEquityType = "WARRANT"
	AssetEquityTypeAdr                        AssetEquityType = "ADR"
	AssetEquityTypeRights                     AssetEquityType = "RIGHTS"
	AssetEquityTypeSharesOfBeneficialInterest AssetEquityType = "SHARES_OF_BENEFICIAL_INTEREST"
	AssetEquityTypeCertificates               AssetEquityType = "CERTIFICATES"
	AssetEquityTypeUnits                      AssetEquityType = "UNITS"
	AssetEquityTypeDebtIssue                  AssetEquityType = "DEBT_ISSUE"
	AssetEquityTypeEquityTypeOption           AssetEquityType = "EQUITY_TYPE_OPTION"
	AssetEquityTypeEtf                        AssetEquityType = "ETF"
)

func (e AssetEquityType) ToPointer() *AssetEquityType {
	return &e
}

// Equity specific asset details
type Equity struct {
	// Indicates whether the symbol is eligible for fractional or notional execution for orders at Apex
	Fractionable *bool `json:"fractionable,omitempty"`
	// Indicates whether the symbol is designated as “Liquidate Only,” and, if so, the system rejects purchases
	Liquidate *bool `json:"liquidate,omitempty"`
	// the code indicating the type of associated security.
	Type *AssetEquityType `json:"type,omitempty"`
}

func (o *Equity) GetFractionable() *bool {
	if o == nil {
		return nil
	}
	return o.Fractionable
}

func (o *Equity) GetLiquidate() *bool {
	if o == nil {
		return nil
	}
	return o.Liquidate
}

func (o *Equity) GetType() *AssetEquityType {
	if o == nil {
		return nil
	}
	return o.Type
}

// CallType - The type of call
type CallType string

const (
	CallTypeCallTypeUnspecified CallType = "CALL_TYPE_UNSPECIFIED"
	CallTypeOrdinary            CallType = "ORDINARY"
	CallTypeSpecial             CallType = "SPECIAL"
	CallTypeMakeWhole           CallType = "MAKE_WHOLE"
	CallTypeRegulatory          CallType = "REGULATORY"
)

func (e CallType) ToPointer() *CallType {
	return &e
}

// CouponFrequency - Frequency of payments
type CouponFrequency string

const (
	CouponFrequencyCouponFrequencyUnspecified CouponFrequency = "COUPON_FREQUENCY_UNSPECIFIED"
	CouponFrequencySemiAnnual                 CouponFrequency = "SEMI_ANNUAL"
	CouponFrequencyMonthly                    CouponFrequency = "MONTHLY"
	CouponFrequencyAtMaturity                 CouponFrequency = "AT_MATURITY"
	CouponFrequencyZero                       CouponFrequency = "ZERO"
	CouponFrequencyQuarterly                  CouponFrequency = "QUARTERLY"
	CouponFrequencyAnnual                     CouponFrequency = "ANNUAL"
)

func (e CouponFrequency) ToPointer() *CouponFrequency {
	return &e
}

// CouponRate - A measure of income an investor can expect to receive expressed as a percent
type CouponRate struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *CouponRate) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// CouponType - Type of coupon rate
type CouponType string

const (
	CouponTypeCouponTypeUnspecified CouponType = "COUPON_TYPE_UNSPECIFIED"
	CouponTypeCouponTypeFixed       CouponType = "COUPON_TYPE_FIXED"
	CouponTypeCouponTypeZero        CouponType = "COUPON_TYPE_ZERO"
)

func (e CouponType) ToPointer() *CouponType {
	return &e
}

// Duration - Weighted average time until a bond’s cash flows are received in years
//
// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
type Duration struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *Duration) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// FirstCouponDate - date of first coupon
type FirstCouponDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *FirstCouponDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *FirstCouponDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *FirstCouponDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// FixedIncomeStatus - The status of the fixed income
type FixedIncomeStatus string

const (
	FixedIncomeStatusFixedIncomeStatusUnspecified FixedIncomeStatus = "FIXED_INCOME_STATUS_UNSPECIFIED"
	FixedIncomeStatusOutstanding                  FixedIncomeStatus = "OUTSTANDING"
	FixedIncomeStatusMatured                      FixedIncomeStatus = "MATURED"
	FixedIncomeStatusCalled                       FixedIncomeStatus = "CALLED"
	FixedIncomeStatusUnknown                      FixedIncomeStatus = "UNKNOWN"
	FixedIncomeStatusDefaulted                    FixedIncomeStatus = "DEFAULTED"
	FixedIncomeStatusConverted                    FixedIncomeStatus = "CONVERTED"
	FixedIncomeStatusTendered                     FixedIncomeStatus = "TENDERED"
	FixedIncomeStatusPreIssuance                  FixedIncomeStatus = "PRE_ISSUANCE"
	FixedIncomeStatusLiquidated                   FixedIncomeStatus = "LIQUIDATED"
	FixedIncomeStatusRepurchased                  FixedIncomeStatus = "REPURCHASED"
	FixedIncomeStatusRepaid                       FixedIncomeStatus = "REPAID"
	FixedIncomeStatusRestructured                 FixedIncomeStatus = "RESTRUCTURED"
	FixedIncomeStatusPut                          FixedIncomeStatus = "PUT"
	FixedIncomeStatusFunged                       FixedIncomeStatus = "FUNGED"
)

func (e FixedIncomeStatus) ToPointer() *FixedIncomeStatus {
	return &e
}

// FixedIncomeSubtype - The type of treasury
type FixedIncomeSubtype string

const (
	FixedIncomeSubtypeFixedIncomeSubtypeUnspecified FixedIncomeSubtype = "FIXED_INCOME_SUBTYPE_UNSPECIFIED"
	FixedIncomeSubtypeBond                          FixedIncomeSubtype = "BOND"
	FixedIncomeSubtypeStrips                        FixedIncomeSubtype = "STRIPS"
	FixedIncomeSubtypeBill                          FixedIncomeSubtype = "BILL"
	FixedIncomeSubtypeNote                          FixedIncomeSubtype = "NOTE"
	FixedIncomeSubtypeTips                          FixedIncomeSubtype = "TIPS"
)

func (e FixedIncomeSubtype) ToPointer() *FixedIncomeSubtype {
	return &e
}

// FixedIncomeType - Type of fixed income security
type FixedIncomeType string

const (
	FixedIncomeTypeFixedIncomeTypeUnspecified FixedIncomeType = "FIXED_INCOME_TYPE_UNSPECIFIED"
	FixedIncomeTypeMunicipal                  FixedIncomeType = "MUNICIPAL"
	FixedIncomeTypeCorporate                  FixedIncomeType = "CORPORATE"
	FixedIncomeTypeCd                         FixedIncomeType = "CD"
	FixedIncomeTypeAgency                     FixedIncomeType = "AGENCY"
	FixedIncomeTypeTreasury                   FixedIncomeType = "TREASURY"
	FixedIncomeTypeGovernment                 FixedIncomeType = "GOVERNMENT"
	FixedIncomeTypeForeignGovernment          FixedIncomeType = "FOREIGN_GOVERNMENT"
)

func (e FixedIncomeType) ToPointer() *FixedIncomeType {
	return &e
}

// AssetIssueDate - The date of issuance
type AssetIssueDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *AssetIssueDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *AssetIssueDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *AssetIssueDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// IssueSize - Total size of the bond issue in the issuing currency
type IssueSize struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *IssueSize) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// LastCouponDate - date of last coupon
type LastCouponDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *LastCouponDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *LastCouponDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *LastCouponDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// MaturityDate - The date the fixed income security matures
type MaturityDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *MaturityDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *MaturityDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *MaturityDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// NextCallDate - The date of the next call
type NextCallDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *NextCallDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *NextCallDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *NextCallDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// NextCouponDate - Date of next coupon payment
type NextCouponDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *NextCouponDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *NextCouponDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *NextCouponDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// ParValue - The amount the issuer agrees to pay the investor upon maturity
type ParValue struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *ParValue) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// PriceAtIssuance - The price at which fixed income security was issued as a percentage of par value in %
type PriceAtIssuance struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *PriceAtIssuance) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// SpRating - Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field.
type SpRating string

const (
	SpRatingSpRatingUnspecified SpRating = "SP_RATING_UNSPECIFIED"
	SpRatingAaa                 SpRating = "AAA"
	SpRatingAaPlus              SpRating = "AA_PLUS"
	SpRatingAa                  SpRating = "AA"
	SpRatingAaMinus             SpRating = "AA_MINUS"
	SpRatingAPlus               SpRating = "A_PLUS"
	SpRatingA                   SpRating = "A"
	SpRatingAMinus              SpRating = "A_MINUS"
	SpRatingBbbPlus             SpRating = "BBB_PLUS"
	SpRatingBbb                 SpRating = "BBB"
	SpRatingBbbMinus            SpRating = "BBB_MINUS"
	SpRatingBbPlus              SpRating = "BB_PLUS"
	SpRatingBb                  SpRating = "BB"
	SpRatingBbMinus             SpRating = "BB_MINUS"
	SpRatingBPlus               SpRating = "B_PLUS"
	SpRatingB                   SpRating = "B"
	SpRatingBMinus              SpRating = "B_MINUS"
	SpRatingCccPlus             SpRating = "CCC_PLUS"
	SpRatingCcc                 SpRating = "CCC"
	SpRatingCccMinus            SpRating = "CCC_MINUS"
	SpRatingCc                  SpRating = "CC"
	SpRatingC                   SpRating = "C"
	SpRatingD                   SpRating = "D"
	SpRatingNr                  SpRating = "NR"
	SpRatingSp1Plus             SpRating = "SP_1_PLUS"
	SpRatingSp1                 SpRating = "SP_1"
	SpRatingSp1Minus            SpRating = "SP_1_MINUS"
	SpRatingA1Plus              SpRating = "A_1_PLUS"
	SpRatingA1                  SpRating = "A_1"
	SpRatingA1Minus             SpRating = "A_1_MINUS"
)

func (e SpRating) ToPointer() *SpRating {
	return &e
}

// SpRatingDate - The date of Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field.
type SpRatingDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *SpRatingDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *SpRatingDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *SpRatingDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// FixedIncome specific asset details
type FixedIncome struct {
	// The type of call
	CallType *CallType `json:"call_type,omitempty"`
	// Boolean that indicates whether an issuer may redeem the security before its maturity date
	Callable *bool `json:"callable,omitempty"`
	// Boolean that indicates whether an investor may convert to a number of shares of issuer common stock
	Convertible *bool `json:"convertible,omitempty"`
	// Frequency of payments
	CouponFrequency *CouponFrequency `json:"coupon_frequency,omitempty"`
	// A measure of income an investor can expect to receive expressed as a percent
	CouponRate *CouponRate `json:"coupon_rate,omitempty"`
	// Type of coupon rate
	CouponType *CouponType `json:"coupon_type,omitempty"`
	// Weighted average time until a bond’s cash flows are received in years
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	Duration *Duration `json:"duration,omitempty"`
	// date of first coupon
	FirstCouponDate *FirstCouponDate `json:"first_coupon_date,omitempty"`
	// The status of the fixed income
	FixedIncomeStatus *FixedIncomeStatus `json:"fixed_income_status,omitempty"`
	// The type of treasury
	FixedIncomeSubtype *FixedIncomeSubtype `json:"fixed_income_subtype,omitempty"`
	// Type of fixed income security
	FixedIncomeType *FixedIncomeType `json:"fixed_income_type,omitempty"`
	// Boolean that indicates whether a security is backed by an insurance policy
	Insured *bool `json:"insured,omitempty"`
	// The date of issuance
	IssueDate *AssetIssueDate `json:"issue_date,omitempty"`
	// Total size of the bond issue in the issuing currency
	IssueSize *IssueSize `json:"issue_size,omitempty"`
	// Name of the bond issuer
	Issuer *string `json:"issuer,omitempty"`
	// date of last coupon
	LastCouponDate *LastCouponDate `json:"last_coupon_date,omitempty"`
	// The date the fixed income security matures
	MaturityDate *MaturityDate `json:"maturity_date,omitempty"`
	// The date of the next call
	NextCallDate *NextCallDate `json:"next_call_date,omitempty"`
	// Date of next coupon payment
	NextCouponDate *NextCouponDate `json:"next_coupon_date,omitempty"`
	// The amount the issuer agrees to pay the investor upon maturity
	ParValue *ParValue `json:"par_value,omitempty"`
	// Indicates whether the bond is perpetual
	Perpetual *bool `json:"perpetual,omitempty"`
	// The price at which fixed income security was issued as a percentage of par value in %
	PriceAtIssuance *PriceAtIssuance `json:"price_at_issuance,omitempty"`
	// Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field.
	SpRating *SpRating `json:"sp_rating,omitempty"`
	// The date of Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field.
	SpRatingDate *SpRatingDate `json:"sp_rating_date,omitempty"`
	// The symbol for the issuer’s equity
	UnderlyingSymbol *string `json:"underlying_symbol,omitempty"`
}

func (o *FixedIncome) GetCallType() *CallType {
	if o == nil {
		return nil
	}
	return o.CallType
}

func (o *FixedIncome) GetCallable() *bool {
	if o == nil {
		return nil
	}
	return o.Callable
}

func (o *FixedIncome) GetConvertible() *bool {
	if o == nil {
		return nil
	}
	return o.Convertible
}

func (o *FixedIncome) GetCouponFrequency() *CouponFrequency {
	if o == nil {
		return nil
	}
	return o.CouponFrequency
}

func (o *FixedIncome) GetCouponRate() *CouponRate {
	if o == nil {
		return nil
	}
	return o.CouponRate
}

func (o *FixedIncome) GetCouponType() *CouponType {
	if o == nil {
		return nil
	}
	return o.CouponType
}

func (o *FixedIncome) GetDuration() *Duration {
	if o == nil {
		return nil
	}
	return o.Duration
}

func (o *FixedIncome) GetFirstCouponDate() *FirstCouponDate {
	if o == nil {
		return nil
	}
	return o.FirstCouponDate
}

func (o *FixedIncome) GetFixedIncomeStatus() *FixedIncomeStatus {
	if o == nil {
		return nil
	}
	return o.FixedIncomeStatus
}

func (o *FixedIncome) GetFixedIncomeSubtype() *FixedIncomeSubtype {
	if o == nil {
		return nil
	}
	return o.FixedIncomeSubtype
}

func (o *FixedIncome) GetFixedIncomeType() *FixedIncomeType {
	if o == nil {
		return nil
	}
	return o.FixedIncomeType
}

func (o *FixedIncome) GetInsured() *bool {
	if o == nil {
		return nil
	}
	return o.Insured
}

func (o *FixedIncome) GetIssueDate() *AssetIssueDate {
	if o == nil {
		return nil
	}
	return o.IssueDate
}

func (o *FixedIncome) GetIssueSize() *IssueSize {
	if o == nil {
		return nil
	}
	return o.IssueSize
}

func (o *FixedIncome) GetIssuer() *string {
	if o == nil {
		return nil
	}
	return o.Issuer
}

func (o *FixedIncome) GetLastCouponDate() *LastCouponDate {
	if o == nil {
		return nil
	}
	return o.LastCouponDate
}

func (o *FixedIncome) GetMaturityDate() *MaturityDate {
	if o == nil {
		return nil
	}
	return o.MaturityDate
}

func (o *FixedIncome) GetNextCallDate() *NextCallDate {
	if o == nil {
		return nil
	}
	return o.NextCallDate
}

func (o *FixedIncome) GetNextCouponDate() *NextCouponDate {
	if o == nil {
		return nil
	}
	return o.NextCouponDate
}

func (o *FixedIncome) GetParValue() *ParValue {
	if o == nil {
		return nil
	}
	return o.ParValue
}

func (o *FixedIncome) GetPerpetual() *bool {
	if o == nil {
		return nil
	}
	return o.Perpetual
}

func (o *FixedIncome) GetPriceAtIssuance() *PriceAtIssuance {
	if o == nil {
		return nil
	}
	return o.PriceAtIssuance
}

func (o *FixedIncome) GetSpRating() *SpRating {
	if o == nil {
		return nil
	}
	return o.SpRating
}

func (o *FixedIncome) GetSpRatingDate() *SpRatingDate {
	if o == nil {
		return nil
	}
	return o.SpRatingDate
}

func (o *FixedIncome) GetUnderlyingSymbol() *string {
	if o == nil {
		return nil
	}
	return o.UnderlyingSymbol
}

// Index specific asset details
type Index struct {
}

// LargeOrderNotificationAmount - The threshold at which Apex would need to notify the fund family of an incoming large order.
type LargeOrderNotificationAmount struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *LargeOrderNotificationAmount) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// MutualFundType - Identifies type of mutual fund
type MutualFundType string

const (
	MutualFundTypeMutualFundTypeUnspecified MutualFundType = "MUTUAL_FUND_TYPE_UNSPECIFIED"
	MutualFundTypeBond                      MutualFundType = "BOND"
	MutualFundTypeMoneyMarketFund           MutualFundType = "MONEY_MARKET_FUND"
	MutualFundTypeEquity                    MutualFundType = "EQUITY"
)

func (e MutualFundType) ToPointer() *MutualFundType {
	return &e
}

// MutualFund specific asset details
type MutualFund struct {
	// Name of the fund company
	FundFamily *string `json:"fund_family,omitempty"`
	// The threshold at which Apex would need to notify the fund family of an incoming large order.
	LargeOrderNotificationAmount *LargeOrderNotificationAmount `json:"large_order_notification_amount,omitempty"`
	// Identifies type of mutual fund
	MutualFundType *MutualFundType `json:"mutual_fund_type,omitempty"`
	// Indicates the type and number of fees charged for the shares in a fund
	ShareClass *string `json:"share_class,omitempty"`
}

func (o *MutualFund) GetFundFamily() *string {
	if o == nil {
		return nil
	}
	return o.FundFamily
}

func (o *MutualFund) GetLargeOrderNotificationAmount() *LargeOrderNotificationAmount {
	if o == nil {
		return nil
	}
	return o.LargeOrderNotificationAmount
}

func (o *MutualFund) GetMutualFundType() *MutualFundType {
	if o == nil {
		return nil
	}
	return o.MutualFundType
}

func (o *MutualFund) GetShareClass() *string {
	if o == nil {
		return nil
	}
	return o.ShareClass
}

// CallPut - Indicates whether the option is a Call or a Put. A Put entitles the holder to sell shares at the specified strike_price, while a Call entitles the holder to buy shares at the specified strike_price.
type CallPut string

const (
	CallPutCallPutUnspecified CallPut = "CALL_PUT_UNSPECIFIED"
	CallPutCall               CallPut = "CALL"
	CallPutPut                CallPut = "PUT"
)

func (e CallPut) ToPointer() *CallPut {
	return &e
}

// ExerciseStyle - Indicates how and when an option can be exercised, either American (exercise any time before expiration) or European (exercise only at expiration).
type ExerciseStyle string

const (
	ExerciseStyleExerciseStyleUnspecified ExerciseStyle = "EXERCISE_STYLE_UNSPECIFIED"
	ExerciseStyleAmerican                 ExerciseStyle = "AMERICAN"
	ExerciseStyleEuropean                 ExerciseStyle = "EUROPEAN"
)

func (e ExerciseStyle) ToPointer() *ExerciseStyle {
	return &e
}

// AssetExpirationDate - The date when the option contract expires. This will typically match the series_date but can vary when the option expiration is accelerated for a given series. This field will represent the actual expiration date.
type AssetExpirationDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *AssetExpirationDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *AssetExpirationDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *AssetExpirationDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// Classification is the category of option that the option falls into These are based on how the contract was written. Only STANDARD is supported at this time.
type Classification string

const (
	ClassificationClassificationUnspecified Classification = "CLASSIFICATION_UNSPECIFIED"
	ClassificationStandard                  Classification = "STANDARD"
	ClassificationFlex                      Classification = "FLEX"
)

func (e Classification) ToPointer() *Classification {
	return &e
}

// PennyPilotIndicator - The penny pilot indicator of the option
type PennyPilotIndicator string

const (
	PennyPilotIndicatorPennyPilotIndicatorUnspecified PennyPilotIndicator = "PENNY_PILOT_INDICATOR_UNSPECIFIED"
	PennyPilotIndicatorPennyPilot                     PennyPilotIndicator = "PENNY_PILOT"
	PennyPilotIndicatorNonPennyPilot                  PennyPilotIndicator = "NON_PENNY_PILOT"
)

func (e PennyPilotIndicator) ToPointer() *PennyPilotIndicator {
	return &e
}

// PositionLimit - The position Limit for a given option set at the OCC.
type PositionLimit struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *PositionLimit) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// SettlementStyle - Indicates whether the option is designated to settle at the market's opening price on the expiration date.
type SettlementStyle string

const (
	SettlementStyleSettlementStyleUnspecified SettlementStyle = "SETTLEMENT_STYLE_UNSPECIFIED"
	SettlementStyleSettleOnOpen               SettlementStyle = "SETTLE_ON_OPEN"
	SettlementStyleSettleOnClose              SettlementStyle = "SETTLE_ON_CLOSE"
)

func (e SettlementStyle) ToPointer() *SettlementStyle {
	return &e
}

// StrikeMultiplier - A number that identifies where the decimal for a strike price should be within the OSI.  For example, in the OSI: AAPL 210416C00120000,   a strike_multiplier of 1 indicates that the strike price is $120.000 and a strike_multiplier of .1 indicates that the strike price is $12.00.
//
//	strike_multiplier is: always 1.0 for Equity Options, usually 1.0 for Index Options, but is 0.1 for “half-point” Index Options.
type StrikeMultiplier struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *StrikeMultiplier) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// StrikePriceMultiplier - A number defined as 1 unit of strike value.  For example, if the strike price multiplier = 100, then a strike of $17 equals $1,700. This field is used for  calculating extended strike values.  The number of units represented by the Strike Price Multiplier is comprised of:
//  1. Number of shares for Equity Options
//  2. A dollar amount for Index Options
//     The typical value of this multiplier for Equity and Index options is 100
//     For mini options the typical value is 10
type StrikePriceMultiplier struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *StrikePriceMultiplier) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// TradeValueMultiplier - A number defined as 1 unit of trade premium value.  For example, if the multiplier = 100, then a premium of $1.50 equals $150. This field is used for calculating premium money extensions.  The number of units represented by the multiplier is comprised of:
//  1. Number of shares for Equity Options
//  2. A dollar amount for Index Options
//     The typical value of this multiplier for Equity and Index options is 100. In the majority of cases,
//     the Trade Premium has to be extended to the same base as the Strike Price. Therefore, the
//     Trade Value is usually the same as the Strike Value.
//     For mini options the typical value is 10
type TradeValueMultiplier struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *TradeValueMultiplier) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// OptionRoot - The full option root information
type OptionRoot struct {
	// Classification is the category of option that the option falls into These are based on how the contract was written. Only STANDARD is supported at this time.
	Classification *Classification `json:"classification,omitempty"`
	// deliverables is the deliverables of the option More than 20 deliverable assets are not supported.
	Deliverables []OptionDeliverable `json:"deliverables,omitempty"`
	// The penny pilot indicator of the option
	PennyPilotIndicator *PennyPilotIndicator `json:"penny_pilot_indicator,omitempty"`
	// The position Limit for a given option set at the OCC.
	PositionLimit *PositionLimit `json:"position_limit,omitempty"`
	// Unique identifier for the underlying asset and its associated option contracts, which reflects any changes to the underlying asset caused by corporate actions such as mergers, splits, or spin-offs by updating the root with a numerical value to reflect the adjusted terms or entity.
	RootSymbol *string `json:"root_symbol,omitempty"`
	// Indicates whether the option is designated to settle at the market's opening price on the expiration date.
	SettlementStyle *SettlementStyle `json:"settlement_style,omitempty"`
	// A number that identifies where the decimal for a strike price should be within the OSI.  For example, in the OSI: AAPL 210416C00120000,   a strike_multiplier of 1 indicates that the strike price is $120.000 and a strike_multiplier of .1 indicates that the strike price is $12.00.
	//
	//  strike_multiplier is: always 1.0 for Equity Options, usually 1.0 for Index Options, but is 0.1 for “half-point” Index Options.
	StrikeMultiplier *StrikeMultiplier `json:"strike_multiplier,omitempty"`
	// A number defined as 1 unit of strike value.  For example, if the strike price multiplier = 100, then a strike of $17 equals $1,700. This field is used for  calculating extended strike values.  The number of units represented by the Strike Price Multiplier is comprised of:
	//    1) Number of shares for Equity Options
	//    2) A dollar amount for Index Options
	//  The typical value of this multiplier for Equity and Index options is 100
	//  For mini options the typical value is 10
	StrikePriceMultiplier *StrikePriceMultiplier `json:"strike_price_multiplier,omitempty"`
	// A number defined as 1 unit of trade premium value.  For example, if the multiplier = 100, then a premium of $1.50 equals $150. This field is used for calculating premium money extensions.  The number of units represented by the multiplier is comprised of:
	//   1) Number of shares for Equity Options
	//   2) A dollar amount for Index Options
	//  The typical value of this multiplier for Equity and Index options is 100. In the majority of cases,
	//  the Trade Premium has to be extended to the same base as the Strike Price. Therefore, the
	//   Trade Value is usually the same as the Strike Value.
	//  For mini options the typical value is 10
	TradeValueMultiplier *TradeValueMultiplier `json:"trade_value_multiplier,omitempty"`
}

func (o *OptionRoot) GetClassification() *Classification {
	if o == nil {
		return nil
	}
	return o.Classification
}

func (o *OptionRoot) GetDeliverables() []OptionDeliverable {
	if o == nil {
		return nil
	}
	return o.Deliverables
}

func (o *OptionRoot) GetPennyPilotIndicator() *PennyPilotIndicator {
	if o == nil {
		return nil
	}
	return o.PennyPilotIndicator
}

func (o *OptionRoot) GetPositionLimit() *PositionLimit {
	if o == nil {
		return nil
	}
	return o.PositionLimit
}

func (o *OptionRoot) GetRootSymbol() *string {
	if o == nil {
		return nil
	}
	return o.RootSymbol
}

func (o *OptionRoot) GetSettlementStyle() *SettlementStyle {
	if o == nil {
		return nil
	}
	return o.SettlementStyle
}

func (o *OptionRoot) GetStrikeMultiplier() *StrikeMultiplier {
	if o == nil {
		return nil
	}
	return o.StrikeMultiplier
}

func (o *OptionRoot) GetStrikePriceMultiplier() *StrikePriceMultiplier {
	if o == nil {
		return nil
	}
	return o.StrikePriceMultiplier
}

func (o *OptionRoot) GetTradeValueMultiplier() *TradeValueMultiplier {
	if o == nil {
		return nil
	}
	return o.TradeValueMultiplier
}

// OptionType - Type of deliverable asset the option is set to deliver upon expiry.
type OptionType string

const (
	OptionTypeOptionTypeUnspecified OptionType = "OPTION_TYPE_UNSPECIFIED"
	OptionTypeEquity                OptionType = "EQUITY"
	OptionTypeIndex                 OptionType = "INDEX"
)

func (e OptionType) ToPointer() *OptionType {
	return &e
}

// SeriesDate - The date of the option contract this is the value in the OSI and is typically the same as the expiration_date but can vary when the option expiration is accelerated.
type SeriesDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *SeriesDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *SeriesDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *SeriesDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// SettlementMethod - Specifies how an option is settled at expiration, either Physical (delivery of the underlying asset) or Cash (payment of the cash difference).
type SettlementMethod string

const (
	SettlementMethodSettlementMethodUnspecified SettlementMethod = "SETTLEMENT_METHOD_UNSPECIFIED"
	SettlementMethodCash                        SettlementMethod = "CASH"
	SettlementMethodPhysical                    SettlementMethod = "PHYSICAL"
)

func (e SettlementMethod) ToPointer() *SettlementMethod {
	return &e
}

// SettlementType - Indicates whether an option follows Standard settlement terms or has Non-Standard terms, often due to adjustments like corporate actions.
type SettlementType string

const (
	SettlementTypeSettlementTypeUnspecified SettlementType = "SETTLEMENT_TYPE_UNSPECIFIED"
	SettlementTypeStandard                  SettlementType = "STANDARD"
	SettlementTypeNonStandard               SettlementType = "NON_STANDARD"
)

func (e SettlementType) ToPointer() *SettlementType {
	return &e
}

// StrikePrice - The price at which the option holder can buy or sell the deliverable asset(s)
type StrikePrice struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *StrikePrice) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// Option specific asset details
type Option struct {
	// Indicates whether the option is a Call or a Put. A Put entitles the holder to sell shares at the specified strike_price, while a Call entitles the holder to buy shares at the specified strike_price.
	CallPut *CallPut `json:"call_put,omitempty"`
	// Indicates how and when an option can be exercised, either American (exercise any time before expiration) or European (exercise only at expiration).
	ExerciseStyle *ExerciseStyle `json:"exercise_style,omitempty"`
	// The date when the option contract expires. This will typically match the series_date but can vary when the option expiration is accelerated for a given series. This field will represent the actual expiration date.
	ExpirationDate *AssetExpirationDate `json:"expiration_date,omitempty"`
	// The full option root information
	OptionRoot *OptionRoot `json:"option_root,omitempty"`
	// Type of deliverable asset the option is set to deliver upon expiry.
	OptionType *OptionType `json:"option_type,omitempty"`
	// The leading segment of the OSI, which is typically the original deliverable symbol of the option. There are frequent exceptions to this rule, such as when there are multiple deliverables or the deliverable goes through a corporate action.
	RootSymbol *string `json:"root_symbol,omitempty"`
	// The date of the option contract this is the value in the OSI and is typically the same as the expiration_date but can vary when the option expiration is accelerated.
	SeriesDate *SeriesDate `json:"series_date,omitempty"`
	// Specifies how an option is settled at expiration, either Physical (delivery of the underlying asset) or Cash (payment of the cash difference).
	SettlementMethod *SettlementMethod `json:"settlement_method,omitempty"`
	// Indicates whether an option follows Standard settlement terms or has Non-Standard terms, often due to adjustments like corporate actions.
	SettlementType *SettlementType `json:"settlement_type,omitempty"`
	// The price at which the option holder can buy or sell the deliverable asset(s)
	StrikePrice *StrikePrice `json:"strike_price,omitempty"`
}

func (o *Option) GetCallPut() *CallPut {
	if o == nil {
		return nil
	}
	return o.CallPut
}

func (o *Option) GetExerciseStyle() *ExerciseStyle {
	if o == nil {
		return nil
	}
	return o.ExerciseStyle
}

func (o *Option) GetExpirationDate() *AssetExpirationDate {
	if o == nil {
		return nil
	}
	return o.ExpirationDate
}

func (o *Option) GetOptionRoot() *OptionRoot {
	if o == nil {
		return nil
	}
	return o.OptionRoot
}

func (o *Option) GetOptionType() *OptionType {
	if o == nil {
		return nil
	}
	return o.OptionType
}

func (o *Option) GetRootSymbol() *string {
	if o == nil {
		return nil
	}
	return o.RootSymbol
}

func (o *Option) GetSeriesDate() *SeriesDate {
	if o == nil {
		return nil
	}
	return o.SeriesDate
}

func (o *Option) GetSettlementMethod() *SettlementMethod {
	if o == nil {
		return nil
	}
	return o.SettlementMethod
}

func (o *Option) GetSettlementType() *SettlementType {
	if o == nil {
		return nil
	}
	return o.SettlementType
}

func (o *Option) GetStrikePrice() *StrikePrice {
	if o == nil {
		return nil
	}
	return o.StrikePrice
}

// AssetType1 - The type or category of the asset
type AssetType1 string

const (
	AssetType1TypeUnspecified AssetType1 = "TYPE_UNSPECIFIED"
	AssetType1Equity          AssetType1 = "EQUITY"
	AssetType1Option          AssetType1 = "OPTION"
	AssetType1Currency        AssetType1 = "CURRENCY"
	AssetType1Digital         AssetType1 = "DIGITAL"
	AssetType1FdicSynthetic   AssetType1 = "FDIC_SYNTHETIC"
	AssetType1FixedIncome     AssetType1 = "FIXED_INCOME"
	AssetType1MutualFund      AssetType1 = "MUTUAL_FUND"
	AssetType1Index           AssetType1 = "INDEX"
)

func (e AssetType1) ToPointer() *AssetType1 {
	return &e
}

// Asset is the Apex representation of a security
type Asset struct {
	// Apex internal identifier assigned upon entry to every security.
	AssetID *string `json:"asset_id,omitempty"`
	// Currency specific asset details
	Currency *Currency `json:"currency,omitempty"`
	// Identifier assigned to a security by the CUSIP Service Bureau of Standard & Poor’s Corporation
	Cusip *string `json:"cusip,omitempty"`
	// Name of the issuer of a security and additional descriptive information about the particular issue
	Description *string `json:"description,omitempty"`
	// Equity specific asset details
	Equity *Equity `json:"equity,omitempty"`
	// FixedIncome specific asset details
	FixedIncome *FixedIncome `json:"fixed_income,omitempty"`
	// Index specific asset details
	Index *Index `json:"index,omitempty"`
	// isin is the International Securities Identification Number
	Isin *string `json:"isin,omitempty"`
	// A string attribute denoting the country of issuance or where the asset is trading.
	IssuingRegionCode *string `json:"issuing_region_code,omitempty"`
	// MutualFund specific asset details
	MutualFund *MutualFund `json:"mutual_fund,omitempty"`
	// assets/{asset_id}
	Name *string `json:"name,omitempty"`
	// Option specific asset details
	Option *Option `json:"option,omitempty"`
	// ISO code identifying the region in which the entity was incorporated
	OriginatingRegionCode *string `json:"originating_region_code,omitempty"`
	// An arrangement of characters—usually letters and or numbers — usually representing securities on an exchange
	Symbol *string `json:"symbol,omitempty"`
	// The type or category of the asset
	Type *AssetType1 `json:"type,omitempty"`
	// A usable asset is active in its respective market and can be traded and/or transferred
	Usable *bool `json:"usable,omitempty"`
}

func (o *Asset) GetAssetID() *string {
	if o == nil {
		return nil
	}
	return o.AssetID
}

func (o *Asset) GetCurrency() *Currency {
	if o == nil {
		return nil
	}
	return o.Currency
}

func (o *Asset) GetCusip() *string {
	if o == nil {
		return nil
	}
	return o.Cusip
}

func (o *Asset) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *Asset) GetEquity() *Equity {
	if o == nil {
		return nil
	}
	return o.Equity
}

func (o *Asset) GetFixedIncome() *FixedIncome {
	if o == nil {
		return nil
	}
	return o.FixedIncome
}

func (o *Asset) GetIndex() *Index {
	if o == nil {
		return nil
	}
	return o.Index
}

func (o *Asset) GetIsin() *string {
	if o == nil {
		return nil
	}
	return o.Isin
}

func (o *Asset) GetIssuingRegionCode() *string {
	if o == nil {
		return nil
	}
	return o.IssuingRegionCode
}

func (o *Asset) GetMutualFund() *MutualFund {
	if o == nil {
		return nil
	}
	return o.MutualFund
}

func (o *Asset) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Asset) GetOption() *Option {
	if o == nil {
		return nil
	}
	return o.Option
}

func (o *Asset) GetOriginatingRegionCode() *string {
	if o == nil {
		return nil
	}
	return o.OriginatingRegionCode
}

func (o *Asset) GetSymbol() *string {
	if o == nil {
		return nil
	}
	return o.Symbol
}

func (o *Asset) GetType() *AssetType1 {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Asset) GetUsable() *bool {
	if o == nil {
		return nil
	}
	return o.Usable
}
