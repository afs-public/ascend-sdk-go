// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/afs-public/ascend-sdk-go/internal/utils"
)

// CompressedOrderAssetType - The type of the asset in this order
type CompressedOrderAssetType string

const (
	CompressedOrderAssetTypeAssetTypeUnspecified CompressedOrderAssetType = "ASSET_TYPE_UNSPECIFIED"
	CompressedOrderAssetTypeEquity               CompressedOrderAssetType = "EQUITY"
	CompressedOrderAssetTypeMutualFund           CompressedOrderAssetType = "MUTUAL_FUND"
)

func (e CompressedOrderAssetType) ToPointer() *CompressedOrderAssetType {
	return &e
}

// CompressedOrderCumulativeNotionalValue - The product of order quantity & price, summed across all fills, reported in the currency specified in the order. (This will be rounded to 2 decimal places for USD currencies). Will be absent if an order has no fill information.
type CompressedOrderCumulativeNotionalValue struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *CompressedOrderCumulativeNotionalValue) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// CompressedOrderFilledQuantity - The summed quantity value across all fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no fill information.
type CompressedOrderFilledQuantity struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *CompressedOrderFilledQuantity) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// CompressedOrderIdentifierType - The identifier type of the asset being ordered. For Equities: only SYMBOL is supported
type CompressedOrderIdentifierType string

const (
	CompressedOrderIdentifierTypeSymbol CompressedOrderIdentifierType = "SYMBOL"
	CompressedOrderIdentifierTypeCusip  CompressedOrderIdentifierType = "CUSIP"
	CompressedOrderIdentifierTypeIsin   CompressedOrderIdentifierType = "ISIN"
)

func (e CompressedOrderIdentifierType) ToPointer() *CompressedOrderIdentifierType {
	return &e
}
func (e *CompressedOrderIdentifierType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SYMBOL":
		fallthrough
	case "CUSIP":
		fallthrough
	case "ISIN":
		*e = CompressedOrderIdentifierType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CompressedOrderIdentifierType: %v", v)
	}
}

// CompressedOrderAmount - The amount of the LOI. This is a monetary value in the same currency as the order.
type CompressedOrderAmount struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *CompressedOrderAmount) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// CompressedOrderPeriodStartDate - The period start date of the LOI.
type CompressedOrderPeriodStartDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *CompressedOrderPeriodStartDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *CompressedOrderPeriodStartDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *CompressedOrderPeriodStartDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// CompressedOrderLetterOfIntent - Letter of Intent (LOI). An LOI allows investors to receive sales charge discounts based on a commitment to buy a specified monetary amount of shares over a period of time, usually 13 months. Either ROA or LOI may be specified, but not both.
type CompressedOrderLetterOfIntent struct {
	// The amount of the LOI. This is a monetary value in the same currency as the order.
	Amount *CompressedOrderAmount `json:"amount,omitempty"`
	// The period start date of the LOI.
	PeriodStartDate *CompressedOrderPeriodStartDate `json:"period_start_date,omitempty"`
}

func (o *CompressedOrderLetterOfIntent) GetAmount() *CompressedOrderAmount {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *CompressedOrderLetterOfIntent) GetPeriodStartDate() *CompressedOrderPeriodStartDate {
	if o == nil {
		return nil
	}
	return o.PeriodStartDate
}

// CompressedOrderNotionalValue - Notional quantity of the order, measured in USD. Maximum 2 decimal place precision. Either a quantity or notional_value MUST be specified (but not both). For Equities: currently not supported yet For Mutual Funds: Only supported for BUY orders. The order will be transacted at the full notional amount specified.
type CompressedOrderNotionalValue struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *CompressedOrderNotionalValue) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// CompressedOrderOrderRejectedReason - When an order has the REJECTED status, this will be populated with a system code describing the rejection.
type CompressedOrderOrderRejectedReason string

const (
	CompressedOrderOrderRejectedReasonOrderRejectReasonUnspecified                      CompressedOrderOrderRejectedReason = "ORDER_REJECT_REASON_UNSPECIFIED"
	CompressedOrderOrderRejectedReasonBrokerOption                                      CompressedOrderOrderRejectedReason = "BROKER_OPTION"
	CompressedOrderOrderRejectedReasonUnknownSecurity                                   CompressedOrderOrderRejectedReason = "UNKNOWN_SECURITY"
	CompressedOrderOrderRejectedReasonExchangeClosed                                    CompressedOrderOrderRejectedReason = "EXCHANGE_CLOSED"
	CompressedOrderOrderRejectedReasonTooLateToEnter                                    CompressedOrderOrderRejectedReason = "TOO_LATE_TO_ENTER"
	CompressedOrderOrderRejectedReasonUnknownOrder                                      CompressedOrderOrderRejectedReason = "UNKNOWN_ORDER"
	CompressedOrderOrderRejectedReasonDuplicateOrder                                    CompressedOrderOrderRejectedReason = "DUPLICATE_ORDER"
	CompressedOrderOrderRejectedReasonStaleOrder                                        CompressedOrderOrderRejectedReason = "STALE_ORDER"
	CompressedOrderOrderRejectedReasonBelowNotionalMinimum                              CompressedOrderOrderRejectedReason = "BELOW_NOTIONAL_MINIMUM"
	CompressedOrderOrderRejectedReasonAccountNotEntitled                                CompressedOrderOrderRejectedReason = "ACCOUNT_NOT_ENTITLED"
	CompressedOrderOrderRejectedReasonSystemError                                       CompressedOrderOrderRejectedReason = "SYSTEM_ERROR"
	CompressedOrderOrderRejectedReasonBlockingCorporateAction                           CompressedOrderOrderRejectedReason = "BLOCKING_CORPORATE_ACTION"
	CompressedOrderOrderRejectedReasonUnavailablePriceQuote                             CompressedOrderOrderRejectedReason = "UNAVAILABLE_PRICE_QUOTE"
	CompressedOrderOrderRejectedReasonExecutionMisconfiguredClient                      CompressedOrderOrderRejectedReason = "EXECUTION_MISCONFIGURED_CLIENT"
	CompressedOrderOrderRejectedReasonFractionalQuantityNotAllowedForSecurity           CompressedOrderOrderRejectedReason = "FRACTIONAL_QUANTITY_NOT_ALLOWED_FOR_SECURITY"
	CompressedOrderOrderRejectedReasonOnlyFractionalSellOrWholeOrdersAllowedForSecurity CompressedOrderOrderRejectedReason = "ONLY_FRACTIONAL_SELL_OR_WHOLE_ORDERS_ALLOWED_FOR_SECURITY"
	CompressedOrderOrderRejectedReasonSymbolNotTradeable                                CompressedOrderOrderRejectedReason = "SYMBOL_NOT_TRADEABLE"
	CompressedOrderOrderRejectedReasonAboveNotionalMaximum                              CompressedOrderOrderRejectedReason = "ABOVE_NOTIONAL_MAXIMUM"
	CompressedOrderOrderRejectedReasonAboveShareMaximum                                 CompressedOrderOrderRejectedReason = "ABOVE_SHARE_MAXIMUM"
	CompressedOrderOrderRejectedReasonMaxSellQuantityRequired                           CompressedOrderOrderRejectedReason = "MAX_SELL_QUANTITY_REQUIRED"
	CompressedOrderOrderRejectedReasonMaxSellQuantityProhibited                         CompressedOrderOrderRejectedReason = "MAX_SELL_QUANTITY_PROHIBITED"
	CompressedOrderOrderRejectedReasonStockTradesDisabled                               CompressedOrderOrderRejectedReason = "STOCK_TRADES_DISABLED"
	CompressedOrderOrderRejectedReasonAssetNotSetUpToTrade                              CompressedOrderOrderRejectedReason = "ASSET_NOT_SET_UP_TO_TRADE"
	CompressedOrderOrderRejectedReasonAnotherBasketOrderForAccountHasFailedRiskChecks   CompressedOrderOrderRejectedReason = "ANOTHER_BASKET_ORDER_FOR_ACCOUNT_HAS_FAILED_RISK_CHECKS"
)

func (e CompressedOrderOrderRejectedReason) ToPointer() *CompressedOrderOrderRejectedReason {
	return &e
}

// CompressedOrderOrderStatus - The processing status of the order
type CompressedOrderOrderStatus string

const (
	CompressedOrderOrderStatusOrderStatusUnspecified CompressedOrderOrderStatus = "ORDER_STATUS_UNSPECIFIED"
	CompressedOrderOrderStatusPendingNew             CompressedOrderOrderStatus = "PENDING_NEW"
	CompressedOrderOrderStatusNew                    CompressedOrderOrderStatus = "NEW"
	CompressedOrderOrderStatusPartiallyFilled        CompressedOrderOrderStatus = "PARTIALLY_FILLED"
	CompressedOrderOrderStatusFilled                 CompressedOrderOrderStatus = "FILLED"
	CompressedOrderOrderStatusRejected               CompressedOrderOrderStatus = "REJECTED"
)

func (e CompressedOrderOrderStatus) ToPointer() *CompressedOrderOrderStatus {
	return &e
}

// CompressedOrderOrderType - The execution type of this order. Only MARKET is supported.
type CompressedOrderOrderType string

const (
	CompressedOrderOrderTypeOrderTypeUnspecified CompressedOrderOrderType = "ORDER_TYPE_UNSPECIFIED"
	CompressedOrderOrderTypeMarket               CompressedOrderOrderType = "MARKET"
)

func (e CompressedOrderOrderType) ToPointer() *CompressedOrderOrderType {
	return &e
}

// CompressedOrderQuantity - Numeric quantity of the order. Either a quantity or notional_value MUST be specified (but not both). For Equities: Represents the number of shares, must be greater than zero and may not exceed 5 decimal places. For Mutual Funds: Only supported for SELL orders. Represents the number of shares, up to a maximum of 3 decimal places.
type CompressedOrderQuantity struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *CompressedOrderQuantity) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// CompressedOrderRightsOfAccumulationAmount - The amount of the ROA. This is a monetary value in the same currency as the order. Only 9,999,999.99 is supported.
type CompressedOrderRightsOfAccumulationAmount struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *CompressedOrderRightsOfAccumulationAmount) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// CompressedOrderRightsOfAccumulation - Rights of Accumulation (ROA). An ROA allows an investor to aggregate their own fund shares with the holdings of certain related parties toward achieving the investment thresholds at which sales charge discounts become available. Either ROA or LOI may be specified, but not both.
type CompressedOrderRightsOfAccumulation struct {
	// The amount of the ROA. This is a monetary value in the same currency as the order. Only 9,999,999.99 is supported.
	Amount *CompressedOrderRightsOfAccumulationAmount `json:"amount,omitempty"`
}

func (o *CompressedOrderRightsOfAccumulation) GetAmount() *CompressedOrderRightsOfAccumulationAmount {
	if o == nil {
		return nil
	}
	return o.Amount
}

// CompressedOrderSide - The side of this order.
type CompressedOrderSide string

const (
	CompressedOrderSideSideUnspecified CompressedOrderSide = "SIDE_UNSPECIFIED"
	CompressedOrderSideBuy             CompressedOrderSide = "BUY"
	CompressedOrderSideSell            CompressedOrderSide = "SELL"
)

func (e CompressedOrderSide) ToPointer() *CompressedOrderSide {
	return &e
}

// CompressedOrderTimeInForce - Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
type CompressedOrderTimeInForce string

const (
	CompressedOrderTimeInForceTimeInForceUnspecified CompressedOrderTimeInForce = "TIME_IN_FORCE_UNSPECIFIED"
	CompressedOrderTimeInForceDay                    CompressedOrderTimeInForce = "DAY"
)

func (e CompressedOrderTimeInForce) ToPointer() *CompressedOrderTimeInForce {
	return &e
}

// CompressedOrder - The message describing an orders that have been compressed into a single order
type CompressedOrder struct {
	// Apex Asset ID for this asset. This will not be returned in the initial CreateOrder response and will be available after an order completes validation. If the provided identifier does not match any Apex asset available for trading, an OrderRejectReason of "UNKNOWN_SECURITY" will be returned and the asset_id will not be set.
	AssetID *string `json:"asset_id,omitempty"`
	// The type of the asset in this order
	AssetType *CompressedOrderAssetType `json:"asset_type,omitempty"`
	// The identifier of the account transacting this order
	AveragePriceAccountID *string `json:"average_price_account_id,omitempty"`
	// The average prices, as weighted averages, across all executions in this order. Will be absent if an order has no executions.
	//
	//  When asset_type = EQUITY, there will be at most one value present, with a type of PRICE_PER_UNIT. This will have up to 4 decimal places for USD amounts less than $1, and a maximum of two for larger USD amounts.
	AveragePrices []ExecutedPrice `json:"average_prices,omitempty"`
	// System generated unique id for the compressed order.
	CompressedOrderID *string `json:"compressed_order_id,omitempty"`
	// Time of the order creation
	CreateTime *time.Time `json:"create_time,omitempty"`
	// The product of order quantity & price, summed across all fills, reported in the currency specified in the order. (This will be rounded to 2 decimal places for USD currencies). Will be absent if an order has no fill information.
	CumulativeNotionalValue *CompressedOrderCumulativeNotionalValue `json:"cumulative_notional_value,omitempty"`
	// Defaults to "USD". Only "USD" is supported. Full list of currency codes is defined at: https://en.wikipedia.org/wiki/ISO_4217
	CurrencyCode *string `json:"currency_code,omitempty"`
	// The execution-level details that compose this order
	Executions []Executions `json:"executions,omitempty"`
	// Fees that will be applied to this order.
	Fees []Fee `json:"fees,omitempty"`
	// The summed quantity value across all fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no fill information.
	FilledQuantity *CompressedOrderFilledQuantity `json:"filled_quantity,omitempty"`
	// Identifier of the asset (of the type specified in `identifier_type`).
	Identifier *string `json:"identifier,omitempty"`
	// The identifier type of the asset being ordered. For Equities: only SYMBOL is supported
	IdentifierType *CompressedOrderIdentifierType `json:"identifier_type,omitempty"`
	// Time of the last order update
	LastUpdateTime *time.Time `json:"last_update_time,omitempty"`
	// Letter of Intent (LOI). An LOI allows investors to receive sales charge discounts based on a commitment to buy a specified monetary amount of shares over a period of time, usually 13 months. Either ROA or LOI may be specified, but not both.
	LetterOfIntent *CompressedOrderLetterOfIntent `json:"letter_of_intent,omitempty"`
	// System generated name of the order.
	Name *string `json:"name,omitempty"`
	// Notional quantity of the order, measured in USD. Maximum 2 decimal place precision. Either a quantity or notional_value MUST be specified (but not both). For Equities: currently not supported yet For Mutual Funds: Only supported for BUY orders. The order will be transacted at the full notional amount specified.
	NotionalValue *CompressedOrderNotionalValue `json:"notional_value,omitempty"`
	// When an order has the REJECTED status, this will be populated with a system code describing the rejection.
	OrderRejectedReason *CompressedOrderOrderRejectedReason `json:"order_rejected_reason,omitempty"`
	// The processing status of the order
	OrderStatus *CompressedOrderOrderStatus `json:"order_status,omitempty"`
	// The execution type of this order. Only MARKET is supported.
	OrderType *CompressedOrderOrderType `json:"order_type,omitempty"`
	// Numeric quantity of the order. Either a quantity or notional_value MUST be specified (but not both). For Equities: Represents the number of shares, must be greater than zero and may not exceed 5 decimal places. For Mutual Funds: Only supported for SELL orders. Represents the number of shares, up to a maximum of 3 decimal places.
	Quantity *CompressedOrderQuantity `json:"quantity,omitempty"`
	// Rights of Accumulation (ROA). An ROA allows an investor to aggregate their own fund shares with the holdings of certain related parties toward achieving the investment thresholds at which sales charge discounts become available. Either ROA or LOI may be specified, but not both.
	RightsOfAccumulation *CompressedOrderRightsOfAccumulation `json:"rights_of_accumulation,omitempty"`
	// The side of this order.
	Side *CompressedOrderSide `json:"side,omitempty"`
	// Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
	TimeInForce *CompressedOrderTimeInForce `json:"time_in_force,omitempty"`
}

func (c CompressedOrder) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CompressedOrder) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CompressedOrder) GetAssetID() *string {
	if o == nil {
		return nil
	}
	return o.AssetID
}

func (o *CompressedOrder) GetAssetType() *CompressedOrderAssetType {
	if o == nil {
		return nil
	}
	return o.AssetType
}

func (o *CompressedOrder) GetAveragePriceAccountID() *string {
	if o == nil {
		return nil
	}
	return o.AveragePriceAccountID
}

func (o *CompressedOrder) GetAveragePrices() []ExecutedPrice {
	if o == nil {
		return nil
	}
	return o.AveragePrices
}

func (o *CompressedOrder) GetCompressedOrderID() *string {
	if o == nil {
		return nil
	}
	return o.CompressedOrderID
}

func (o *CompressedOrder) GetCreateTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreateTime
}

func (o *CompressedOrder) GetCumulativeNotionalValue() *CompressedOrderCumulativeNotionalValue {
	if o == nil {
		return nil
	}
	return o.CumulativeNotionalValue
}

func (o *CompressedOrder) GetCurrencyCode() *string {
	if o == nil {
		return nil
	}
	return o.CurrencyCode
}

func (o *CompressedOrder) GetExecutions() []Executions {
	if o == nil {
		return nil
	}
	return o.Executions
}

func (o *CompressedOrder) GetFees() []Fee {
	if o == nil {
		return nil
	}
	return o.Fees
}

func (o *CompressedOrder) GetFilledQuantity() *CompressedOrderFilledQuantity {
	if o == nil {
		return nil
	}
	return o.FilledQuantity
}

func (o *CompressedOrder) GetIdentifier() *string {
	if o == nil {
		return nil
	}
	return o.Identifier
}

func (o *CompressedOrder) GetIdentifierType() *CompressedOrderIdentifierType {
	if o == nil {
		return nil
	}
	return o.IdentifierType
}

func (o *CompressedOrder) GetLastUpdateTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.LastUpdateTime
}

func (o *CompressedOrder) GetLetterOfIntent() *CompressedOrderLetterOfIntent {
	if o == nil {
		return nil
	}
	return o.LetterOfIntent
}

func (o *CompressedOrder) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *CompressedOrder) GetNotionalValue() *CompressedOrderNotionalValue {
	if o == nil {
		return nil
	}
	return o.NotionalValue
}

func (o *CompressedOrder) GetOrderRejectedReason() *CompressedOrderOrderRejectedReason {
	if o == nil {
		return nil
	}
	return o.OrderRejectedReason
}

func (o *CompressedOrder) GetOrderStatus() *CompressedOrderOrderStatus {
	if o == nil {
		return nil
	}
	return o.OrderStatus
}

func (o *CompressedOrder) GetOrderType() *CompressedOrderOrderType {
	if o == nil {
		return nil
	}
	return o.OrderType
}

func (o *CompressedOrder) GetQuantity() *CompressedOrderQuantity {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *CompressedOrder) GetRightsOfAccumulation() *CompressedOrderRightsOfAccumulation {
	if o == nil {
		return nil
	}
	return o.RightsOfAccumulation
}

func (o *CompressedOrder) GetSide() *CompressedOrderSide {
	if o == nil {
		return nil
	}
	return o.Side
}

func (o *CompressedOrder) GetTimeInForce() *CompressedOrderTimeInForce {
	if o == nil {
		return nil
	}
	return o.TimeInForce
}
