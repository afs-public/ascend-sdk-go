// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
)

type PartyBusinessIndustrialClassification string

const (
	PartyBusinessIndustrialClassificationBusinessIndustrialClassificationUnspecified                PartyBusinessIndustrialClassification = "BUSINESS_INDUSTRIAL_CLASSIFICATION_UNSPECIFIED"
	PartyBusinessIndustrialClassificationAgricultureForestryAndFishing                              PartyBusinessIndustrialClassification = "AGRICULTURE_FORESTRY_AND_FISHING"
	PartyBusinessIndustrialClassificationMining                                                     PartyBusinessIndustrialClassification = "MINING"
	PartyBusinessIndustrialClassificationConstruction                                               PartyBusinessIndustrialClassification = "CONSTRUCTION"
	PartyBusinessIndustrialClassificationManufacturing                                              PartyBusinessIndustrialClassification = "MANUFACTURING"
	PartyBusinessIndustrialClassificationTransportationCommunicationsElectricGasAndSanitaryServices PartyBusinessIndustrialClassification = "TRANSPORTATION_COMMUNICATIONS_ELECTRIC_GAS_AND_SANITARY_SERVICES"
	PartyBusinessIndustrialClassificationWholesaleTrade                                             PartyBusinessIndustrialClassification = "WHOLESALE_TRADE"
	PartyBusinessIndustrialClassificationRetailTrade                                                PartyBusinessIndustrialClassification = "RETAIL_TRADE"
	PartyBusinessIndustrialClassificationFinanceInsuranceAndRealEstate                              PartyBusinessIndustrialClassification = "FINANCE_INSURANCE_AND_REAL_ESTATE"
	PartyBusinessIndustrialClassificationServices                                                   PartyBusinessIndustrialClassification = "SERVICES"
	PartyBusinessIndustrialClassificationPublicAdministration                                       PartyBusinessIndustrialClassification = "PUBLIC_ADMINISTRATION"
)

func (e PartyBusinessIndustrialClassification) ToPointer() *PartyBusinessIndustrialClassification {
	return &e
}
func (e *PartyBusinessIndustrialClassification) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "BUSINESS_INDUSTRIAL_CLASSIFICATION_UNSPECIFIED":
		fallthrough
	case "AGRICULTURE_FORESTRY_AND_FISHING":
		fallthrough
	case "MINING":
		fallthrough
	case "CONSTRUCTION":
		fallthrough
	case "MANUFACTURING":
		fallthrough
	case "TRANSPORTATION_COMMUNICATIONS_ELECTRIC_GAS_AND_SANITARY_SERVICES":
		fallthrough
	case "WHOLESALE_TRADE":
		fallthrough
	case "RETAIL_TRADE":
		fallthrough
	case "FINANCE_INSURANCE_AND_REAL_ESTATE":
		fallthrough
	case "SERVICES":
		fallthrough
	case "PUBLIC_ADMINISTRATION":
		*e = PartyBusinessIndustrialClassification(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyBusinessIndustrialClassification: %v", v)
	}
}

// PartyCorporateStructure - Corporate structure of the entity.
type PartyCorporateStructure string

const (
	PartyCorporateStructureEntityCorporateStructureUnspecified PartyCorporateStructure = "ENTITY_CORPORATE_STRUCTURE_UNSPECIFIED"
	PartyCorporateStructureCorporationCCorp                    PartyCorporateStructure = "CORPORATION_C_CORP"
	PartyCorporateStructureCorporationSCorp                    PartyCorporateStructure = "CORPORATION_S_CORP"
	PartyCorporateStructureCorporationBCorp                    PartyCorporateStructure = "CORPORATION_B_CORP"
	PartyCorporateStructureCorporationNonprofit                PartyCorporateStructure = "CORPORATION_NONPROFIT"
)

func (e PartyCorporateStructure) ToPointer() *PartyCorporateStructure {
	return &e
}
func (e *PartyCorporateStructure) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ENTITY_CORPORATE_STRUCTURE_UNSPECIFIED":
		fallthrough
	case "CORPORATION_C_CORP":
		fallthrough
	case "CORPORATION_S_CORP":
		fallthrough
	case "CORPORATION_B_CORP":
		fallthrough
	case "CORPORATION_NONPROFIT":
		*e = PartyCorporateStructure(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyCorporateStructure: %v", v)
	}
}

// PartyNegativeNews - Information about any negative news against related parties and entities
type PartyNegativeNews struct {
	// Indicates whether there is negative news against related parties
	NegativeNewsAgainstRelatedParties *bool `json:"negative_news_against_related_parties,omitempty"`
	// Description of the negative news against related parties
	NegativeNewsAgainstRelatedPartiesDescription *string `json:"negative_news_against_related_parties_description,omitempty"`
}

func (o *PartyNegativeNews) GetNegativeNewsAgainstRelatedParties() *bool {
	if o == nil {
		return nil
	}
	return o.NegativeNewsAgainstRelatedParties
}

func (o *PartyNegativeNews) GetNegativeNewsAgainstRelatedPartiesDescription() *string {
	if o == nil {
		return nil
	}
	return o.NegativeNewsAgainstRelatedPartiesDescription
}

// PartyEntityDueDiligence - Due Diligence for Legal Entities
type PartyEntityDueDiligence struct {
	// Indicates whether the entity issues bearer shares
	EntityIssuesBearerShares *bool `json:"entity_issues_bearer_shares,omitempty"`
	// Information about any negative news against related parties and entities
	NegativeNews *PartyNegativeNews `json:"negative_news,omitempty"`
}

func (o *PartyEntityDueDiligence) GetEntityIssuesBearerShares() *bool {
	if o == nil {
		return nil
	}
	return o.EntityIssuesBearerShares
}

func (o *PartyEntityDueDiligence) GetNegativeNews() *PartyNegativeNews {
	if o == nil {
		return nil
	}
	return o.NegativeNews
}

// PartyEntityType - The entity type.
type PartyEntityType string

const (
	PartyEntityTypeEntityTypeUnspecified               PartyEntityType = "ENTITY_TYPE_UNSPECIFIED"
	PartyEntityTypeCorporation                         PartyEntityType = "CORPORATION"
	PartyEntityTypeLimitedLiabilityCompany             PartyEntityType = "LIMITED_LIABILITY_COMPANY"
	PartyEntityTypePartnership                         PartyEntityType = "PARTNERSHIP"
	PartyEntityTypeSoleProprietorshipOrSingleMemberLlc PartyEntityType = "SOLE_PROPRIETORSHIP_OR_SINGLE_MEMBER_LLC"
	PartyEntityTypeTrust                               PartyEntityType = "TRUST"
	PartyEntityTypeEstate                              PartyEntityType = "ESTATE"
)

func (e PartyEntityType) ToPointer() *PartyEntityType {
	return &e
}
func (e *PartyEntityType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ENTITY_TYPE_UNSPECIFIED":
		fallthrough
	case "CORPORATION":
		fallthrough
	case "LIMITED_LIABILITY_COMPANY":
		fallthrough
	case "PARTNERSHIP":
		fallthrough
	case "SOLE_PROPRIETORSHIP_OR_SINGLE_MEMBER_LLC":
		fallthrough
	case "TRUST":
		fallthrough
	case "ESTATE":
		*e = PartyEntityType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyEntityType: %v", v)
	}
}

// PartyExemptCustomerReason - The reason the customer is exempt from verifying beneficial owners, if applicable.
type PartyExemptCustomerReason string

const (
	PartyExemptCustomerReasonExemptReasonUnspecified                        PartyExemptCustomerReason = "EXEMPT_REASON_UNSPECIFIED"
	PartyExemptCustomerReasonRegulatedFinancialInstitution                  PartyExemptCustomerReason = "REGULATED_FINANCIAL_INSTITUTION"
	PartyExemptCustomerReasonDepartmentOrAgencyOfFederalStateOrSubdivision  PartyExemptCustomerReason = "DEPARTMENT_OR_AGENCY_OF_FEDERAL_STATE_OR_SUBDIVISION"
	PartyExemptCustomerReasonNonBankListedEntity                            PartyExemptCustomerReason = "NON_BANK_LISTED_ENTITY"
	PartyExemptCustomerReasonSection12SecuritiesExchangeAct1934Or15D        PartyExemptCustomerReason = "SECTION_12_SECURITIES_EXCHANGE_ACT_1934_OR_15D"
	PartyExemptCustomerReasonSection3InvestmentCompanyAct1940               PartyExemptCustomerReason = "SECTION_3_INVESTMENT_COMPANY_ACT_1940"
	PartyExemptCustomerReasonSection202AInvestmentAdvisorsAct1940           PartyExemptCustomerReason = "SECTION_202A_INVESTMENT_ADVISORS_ACT_1940"
	PartyExemptCustomerReasonSection3SecuritiesExchangeAct1934Section6Or17A PartyExemptCustomerReason = "SECTION_3_SECURITIES_EXCHANGE_ACT_1934_SECTION_6_OR_17A"
	PartyExemptCustomerReasonAnyOtherSecuritiesExchangeAct1934              PartyExemptCustomerReason = "ANY_OTHER_SECURITIES_EXCHANGE_ACT_1934"
	PartyExemptCustomerReasonCommodityFuturesTradingCommissionRegistered    PartyExemptCustomerReason = "COMMODITY_FUTURES_TRADING_COMMISSION_REGISTERED"
	PartyExemptCustomerReasonPublicAccountingFirmSection102SarbanesOxley    PartyExemptCustomerReason = "PUBLIC_ACCOUNTING_FIRM_SECTION_102_SARBANES_OXLEY"
	PartyExemptCustomerReasonStateRegulatedInsuranceCompany                 PartyExemptCustomerReason = "STATE_REGULATED_INSURANCE_COMPANY"
)

func (e PartyExemptCustomerReason) ToPointer() *PartyExemptCustomerReason {
	return &e
}
func (e *PartyExemptCustomerReason) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EXEMPT_REASON_UNSPECIFIED":
		fallthrough
	case "REGULATED_FINANCIAL_INSTITUTION":
		fallthrough
	case "DEPARTMENT_OR_AGENCY_OF_FEDERAL_STATE_OR_SUBDIVISION":
		fallthrough
	case "NON_BANK_LISTED_ENTITY":
		fallthrough
	case "SECTION_12_SECURITIES_EXCHANGE_ACT_1934_OR_15D":
		fallthrough
	case "SECTION_3_INVESTMENT_COMPANY_ACT_1940":
		fallthrough
	case "SECTION_202A_INVESTMENT_ADVISORS_ACT_1940":
		fallthrough
	case "SECTION_3_SECURITIES_EXCHANGE_ACT_1934_SECTION_6_OR_17A":
		fallthrough
	case "ANY_OTHER_SECURITIES_EXCHANGE_ACT_1934":
		fallthrough
	case "COMMODITY_FUTURES_TRADING_COMMISSION_REGISTERED":
		fallthrough
	case "PUBLIC_ACCOUNTING_FIRM_SECTION_102_SARBANES_OXLEY":
		fallthrough
	case "STATE_REGULATED_INSURANCE_COMPANY":
		*e = PartyExemptCustomerReason(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyExemptCustomerReason: %v", v)
	}
}

// PartyFormationDate - If the legal entity is a trust, the formation date is required.
type PartyFormationDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PartyFormationDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PartyFormationDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PartyFormationDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// PartyEffectiveDate - The date on which the trader meets or exceeds the large trader reporting threshold, which is defined by the U.S. Securities and Exchange Commission (SEC) as trades of 2 million shares or $20 million in a single day or 20 million shares or $200 million during a calendar month
type PartyEffectiveDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PartyEffectiveDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PartyEffectiveDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PartyEffectiveDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// PartyLargeTrader - Large trader for the legal entity.
type PartyLargeTrader struct {
	// The date on which the trader meets or exceeds the large trader reporting threshold, which is defined by the U.S. Securities and Exchange Commission (SEC) as trades of 2 million shares or $20 million in a single day or 20 million shares or $200 million during a calendar month
	EffectiveDate *PartyEffectiveDate `json:"effective_date,omitempty"`
	// SEC-issued ID signifying the person/entity as a large trader; Required for CAIS regulatory reporting.
	LargeTraderID *string `json:"large_trader_id,omitempty"`
}

func (o *PartyLargeTrader) GetEffectiveDate() *PartyEffectiveDate {
	if o == nil {
		return nil
	}
	return o.EffectiveDate
}

func (o *PartyLargeTrader) GetLargeTraderID() *string {
	if o == nil {
		return nil
	}
	return o.LargeTraderID
}

// PartyLegalAddress - The mailing address of the legal entity. Required fields within the `legal_address` object include:
//   - `administrative_area`
//   - `region_code` - 2 character CLDR Code
//   - `postal_code`
//   - `locality`
//   - `address_lines` - max 5 lines
type PartyLegalAddress struct {
	// Unstructured address lines describing the lower levels of an address.
	//
	//  Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language.
	//
	//  The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved.
	//
	//  Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
	AddressLines []string `json:"address_lines,omitempty"`
	// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
	AdministrativeArea *string `json:"administrative_area,omitempty"`
	// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations.
	//
	//  If this value is not known, it should be omitted (rather than specifying a possibly incorrect default).
	//
	//  Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode *string `json:"language_code,omitempty"`
	// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
	Locality *string `json:"locality,omitempty"`
	// Optional. The name of the organization at the address.
	Organization *string `json:"organization,omitempty"`
	// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode *string `json:"postal_code,omitempty"`
	// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
	Recipients []string `json:"recipients,omitempty"`
	// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
	RegionCode *string `json:"region_code,omitempty"`
	// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision.
	//
	//  All new revisions **must** be backward compatible with old revisions.
	Revision *int `json:"revision,omitempty"`
	// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
	SortingCode *string `json:"sorting_code,omitempty"`
	// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
	Sublocality *string `json:"sublocality,omitempty"`
}

func (o *PartyLegalAddress) GetAddressLines() []string {
	if o == nil {
		return nil
	}
	return o.AddressLines
}

func (o *PartyLegalAddress) GetAdministrativeArea() *string {
	if o == nil {
		return nil
	}
	return o.AdministrativeArea
}

func (o *PartyLegalAddress) GetLanguageCode() *string {
	if o == nil {
		return nil
	}
	return o.LanguageCode
}

func (o *PartyLegalAddress) GetLocality() *string {
	if o == nil {
		return nil
	}
	return o.Locality
}

func (o *PartyLegalAddress) GetOrganization() *string {
	if o == nil {
		return nil
	}
	return o.Organization
}

func (o *PartyLegalAddress) GetPostalCode() *string {
	if o == nil {
		return nil
	}
	return o.PostalCode
}

func (o *PartyLegalAddress) GetRecipients() []string {
	if o == nil {
		return nil
	}
	return o.Recipients
}

func (o *PartyLegalAddress) GetRegionCode() *string {
	if o == nil {
		return nil
	}
	return o.RegionCode
}

func (o *PartyLegalAddress) GetRevision() *int {
	if o == nil {
		return nil
	}
	return o.Revision
}

func (o *PartyLegalAddress) GetSortingCode() *string {
	if o == nil {
		return nil
	}
	return o.SortingCode
}

func (o *PartyLegalAddress) GetSublocality() *string {
	if o == nil {
		return nil
	}
	return o.Sublocality
}

// PartyTaxIDType - The nature of the U.S. Tax ID indicated in the related tax_id field; Examples include ITIN, SSN, EIN.
type PartyTaxIDType string

const (
	PartyTaxIDTypeTaxIDTypeUnspecified PartyTaxIDType = "TAX_ID_TYPE_UNSPECIFIED"
	PartyTaxIDTypeTaxIDTypeSsn         PartyTaxIDType = "TAX_ID_TYPE_SSN"
	PartyTaxIDTypeTaxIDTypeItin        PartyTaxIDType = "TAX_ID_TYPE_ITIN"
	PartyTaxIDTypeTaxIDTypeEin         PartyTaxIDType = "TAX_ID_TYPE_EIN"
)

func (e PartyTaxIDType) ToPointer() *PartyTaxIDType {
	return &e
}
func (e *PartyTaxIDType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TAX_ID_TYPE_UNSPECIFIED":
		fallthrough
	case "TAX_ID_TYPE_SSN":
		fallthrough
	case "TAX_ID_TYPE_ITIN":
		fallthrough
	case "TAX_ID_TYPE_EIN":
		*e = PartyTaxIDType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyTaxIDType: %v", v)
	}
}

// PartyCNoticeDate - C Notice date.
type PartyCNoticeDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PartyCNoticeDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PartyCNoticeDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PartyCNoticeDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// PartyFederalTaxClassification - Federal tax classification.
type PartyFederalTaxClassification string

const (
	PartyFederalTaxClassificationFederalTaxClassificationUnspecified PartyFederalTaxClassification = "FEDERAL_TAX_CLASSIFICATION_UNSPECIFIED"
	PartyFederalTaxClassificationIndivSolepropOrSinglememberllc      PartyFederalTaxClassification = "INDIV_SOLEPROP_OR_SINGLEMEMBERLLC"
	PartyFederalTaxClassificationPartnership                         PartyFederalTaxClassification = "PARTNERSHIP"
	PartyFederalTaxClassificationCCorporation                        PartyFederalTaxClassification = "C_CORPORATION"
	PartyFederalTaxClassificationSCorporation                        PartyFederalTaxClassification = "S_CORPORATION"
	PartyFederalTaxClassificationTrustEstate                         PartyFederalTaxClassification = "TRUST_ESTATE"
	PartyFederalTaxClassificationLlcTaxedAsCCorp                     PartyFederalTaxClassification = "LLC_TAXED_AS_C_CORP"
	PartyFederalTaxClassificationLlcTaxedAsSCorp                     PartyFederalTaxClassification = "LLC_TAXED_AS_S_CORP"
	PartyFederalTaxClassificationLlcTaxedAsPartnership               PartyFederalTaxClassification = "LLC_TAXED_AS_PARTNERSHIP"
	PartyFederalTaxClassificationOther                               PartyFederalTaxClassification = "OTHER"
)

func (e PartyFederalTaxClassification) ToPointer() *PartyFederalTaxClassification {
	return &e
}
func (e *PartyFederalTaxClassification) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FEDERAL_TAX_CLASSIFICATION_UNSPECIFIED":
		fallthrough
	case "INDIV_SOLEPROP_OR_SINGLEMEMBERLLC":
		fallthrough
	case "PARTNERSHIP":
		fallthrough
	case "C_CORPORATION":
		fallthrough
	case "S_CORPORATION":
		fallthrough
	case "TRUST_ESTATE":
		fallthrough
	case "LLC_TAXED_AS_C_CORP":
		fallthrough
	case "LLC_TAXED_AS_S_CORP":
		fallthrough
	case "LLC_TAXED_AS_PARTNERSHIP":
		fallthrough
	case "OTHER":
		*e = PartyFederalTaxClassification(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyFederalTaxClassification: %v", v)
	}
}

// PartyFirstBNoticeDate - Initial B Notice date.
type PartyFirstBNoticeDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PartyFirstBNoticeDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PartyFirstBNoticeDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PartyFirstBNoticeDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// PartyIrsFormType - IRS form type.
type PartyIrsFormType string

const (
	PartyIrsFormTypeIrsFormTypeUnspecified PartyIrsFormType = "IRS_FORM_TYPE_UNSPECIFIED"
	PartyIrsFormTypeW9                     PartyIrsFormType = "W_9"
)

func (e PartyIrsFormType) ToPointer() *PartyIrsFormType {
	return &e
}
func (e *PartyIrsFormType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "IRS_FORM_TYPE_UNSPECIFIED":
		fallthrough
	case "W_9":
		*e = PartyIrsFormType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyIrsFormType: %v", v)
	}
}

// PartyReportingEligibility - Tax reporting eligibility.
type PartyReportingEligibility string

const (
	PartyReportingEligibilityTaxReportingEligibilityUnspecified PartyReportingEligibility = "TAX_REPORTING_ELIGIBILITY_UNSPECIFIED"
	PartyReportingEligibilityEligible                           PartyReportingEligibility = "ELIGIBLE"
	PartyReportingEligibilityIneligible                         PartyReportingEligibility = "INELIGIBLE"
)

func (e PartyReportingEligibility) ToPointer() *PartyReportingEligibility {
	return &e
}
func (e *PartyReportingEligibility) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TAX_REPORTING_ELIGIBILITY_UNSPECIFIED":
		fallthrough
	case "ELIGIBLE":
		fallthrough
	case "INELIGIBLE":
		*e = PartyReportingEligibility(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyReportingEligibility: %v", v)
	}
}

// PartyTaxCertificationDate - Tax Certification date.
type PartyTaxCertificationDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PartyTaxCertificationDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PartyTaxCertificationDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PartyTaxCertificationDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// PartyTaxpayerCertificationState - Taxpayer certification status.
type PartyTaxpayerCertificationState string

const (
	PartyTaxpayerCertificationStateTaxpayerCertificationStateUnspecified PartyTaxpayerCertificationState = "TAXPAYER_CERTIFICATION_STATE_UNSPECIFIED"
	PartyTaxpayerCertificationStateCertified                             PartyTaxpayerCertificationState = "CERTIFIED"
	PartyTaxpayerCertificationStateUncertified                           PartyTaxpayerCertificationState = "UNCERTIFIED"
)

func (e PartyTaxpayerCertificationState) ToPointer() *PartyTaxpayerCertificationState {
	return &e
}
func (e *PartyTaxpayerCertificationState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TAXPAYER_CERTIFICATION_STATE_UNSPECIFIED":
		fallthrough
	case "CERTIFIED":
		fallthrough
	case "UNCERTIFIED":
		*e = PartyTaxpayerCertificationState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyTaxpayerCertificationState: %v", v)
	}
}

// PartyUsTinStatus - United States Individual Taxpayer Identification Number (ITIN) status.
type PartyUsTinStatus string

const (
	PartyUsTinStatusUsTinStatusUnspecified PartyUsTinStatus = "US_TIN_STATUS_UNSPECIFIED"
	PartyUsTinStatusPassing                PartyUsTinStatus = "PASSING"
	PartyUsTinStatusFailing                PartyUsTinStatus = "FAILING"
)

func (e PartyUsTinStatus) ToPointer() *PartyUsTinStatus {
	return &e
}
func (e *PartyUsTinStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "US_TIN_STATUS_UNSPECIFIED":
		fallthrough
	case "PASSING":
		fallthrough
	case "FAILING":
		*e = PartyUsTinStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyUsTinStatus: %v", v)
	}
}

// PartyWithholdingState - B/C Notice status.
type PartyWithholdingState string

const (
	PartyWithholdingStateWithholdingStateUnspecified PartyWithholdingState = "WITHHOLDING_STATE_UNSPECIFIED"
	PartyWithholdingStateFirstBNoticeReceived        PartyWithholdingState = "FIRST_B_NOTICE_RECEIVED"
	PartyWithholdingStateSecondBNoticeReceived       PartyWithholdingState = "SECOND_B_NOTICE_RECEIVED"
	PartyWithholdingStateCNoticeReceived             PartyWithholdingState = "C_NOTICE_RECEIVED"
	PartyWithholdingStateCNoticeIndicatedByCustomer  PartyWithholdingState = "C_NOTICE_INDICATED_BY_CUSTOMER"
)

func (e PartyWithholdingState) ToPointer() *PartyWithholdingState {
	return &e
}
func (e *PartyWithholdingState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "WITHHOLDING_STATE_UNSPECIFIED":
		fallthrough
	case "FIRST_B_NOTICE_RECEIVED":
		fallthrough
	case "SECOND_B_NOTICE_RECEIVED":
		fallthrough
	case "C_NOTICE_RECEIVED":
		fallthrough
	case "C_NOTICE_INDICATED_BY_CUSTOMER":
		*e = PartyWithholdingState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyWithholdingState: %v", v)
	}
}

// PartyTaxProfile - The tax profile for the legal entity.
type PartyTaxProfile struct {
	// C Notice date.
	CNoticeDate *PartyCNoticeDate `json:"c_notice_date,omitempty"`
	// Federal tax classification.
	FederalTaxClassification *PartyFederalTaxClassification `json:"federal_tax_classification,omitempty"`
	// Initial B Notice date.
	FirstBNoticeDate *PartyFirstBNoticeDate `json:"first_b_notice_date,omitempty"`
	// IRS form type.
	IrsFormType *PartyIrsFormType `json:"irs_form_type,omitempty"`
	// Legal tax region must be "US" if provided W-9, otherwise must be a non-US country.
	LegalTaxRegionCode *string `json:"legal_tax_region_code,omitempty"`
	// Tax reporting eligibility.
	ReportingEligibility *PartyReportingEligibility `json:"reporting_eligibility,omitempty"`
	// Tax Certification date.
	TaxCertificationDate *PartyTaxCertificationDate `json:"tax_certification_date,omitempty"`
	// Taxpayer certification status.
	TaxpayerCertificationState *PartyTaxpayerCertificationState `json:"taxpayer_certification_state,omitempty"`
	// United States Individual Taxpayer Identification Number (ITIN) status.
	UsTinStatus *PartyUsTinStatus `json:"us_tin_status,omitempty"`
	// B/C Notice status.
	WithholdingState *PartyWithholdingState `json:"withholding_state,omitempty"`
}

func (o *PartyTaxProfile) GetCNoticeDate() *PartyCNoticeDate {
	if o == nil {
		return nil
	}
	return o.CNoticeDate
}

func (o *PartyTaxProfile) GetFederalTaxClassification() *PartyFederalTaxClassification {
	if o == nil {
		return nil
	}
	return o.FederalTaxClassification
}

func (o *PartyTaxProfile) GetFirstBNoticeDate() *PartyFirstBNoticeDate {
	if o == nil {
		return nil
	}
	return o.FirstBNoticeDate
}

func (o *PartyTaxProfile) GetIrsFormType() *PartyIrsFormType {
	if o == nil {
		return nil
	}
	return o.IrsFormType
}

func (o *PartyTaxProfile) GetLegalTaxRegionCode() *string {
	if o == nil {
		return nil
	}
	return o.LegalTaxRegionCode
}

func (o *PartyTaxProfile) GetReportingEligibility() *PartyReportingEligibility {
	if o == nil {
		return nil
	}
	return o.ReportingEligibility
}

func (o *PartyTaxProfile) GetTaxCertificationDate() *PartyTaxCertificationDate {
	if o == nil {
		return nil
	}
	return o.TaxCertificationDate
}

func (o *PartyTaxProfile) GetTaxpayerCertificationState() *PartyTaxpayerCertificationState {
	if o == nil {
		return nil
	}
	return o.TaxpayerCertificationState
}

func (o *PartyTaxProfile) GetUsTinStatus() *PartyUsTinStatus {
	if o == nil {
		return nil
	}
	return o.UsTinStatus
}

func (o *PartyTaxProfile) GetWithholdingState() *PartyWithholdingState {
	if o == nil {
		return nil
	}
	return o.WithholdingState
}

// PartyLegalEntity - Legal entity.
type PartyLegalEntity struct {
	// Indicates whether the entity is an accredited investor. By default, this is set to `false`.
	AccreditedInvestor *bool `json:"accredited_investor,omitempty"`
	// Indicates whether the entity is an adviser. By default, this is set to `false`.
	Adviser *bool `json:"adviser,omitempty"`
	// Indicates whether the entity is a broker dealer. By default, this is set to `false`.
	BrokerDealer                     *bool                                  `json:"broker_dealer,omitempty"`
	BusinessIndustrialClassification *PartyBusinessIndustrialClassification `json:"business_industrial_classification,omitempty"`
	// Corporate structure of the entity.
	CorporateStructure *PartyCorporateStructure `json:"corporate_structure,omitempty"`
	// The correspondent id associated with the legal entity.
	CorrespondentID *string `json:"correspondent_id,omitempty"`
	// DBA (Doing Business As) names. Can list up to 5 associated with the Legal Entity
	DoingBusinessAs []string `json:"doing_business_as,omitempty"`
	// Due Diligence for Legal Entities
	EntityDueDiligence *PartyEntityDueDiligence `json:"entity_due_diligence,omitempty"`
	// The legal entity name.
	EntityName *string `json:"entity_name,omitempty"`
	// The entity type.
	EntityType *PartyEntityType `json:"entity_type,omitempty"`
	// The reason the customer is exempt from verifying beneficial owners, if applicable.
	ExemptCustomerReason *PartyExemptCustomerReason `json:"exempt_customer_reason,omitempty"`
	// Indicates whether the entity is exempt from verifying beneficial owners. By default, this is set to `false`.
	ExemptVerifyingBeneficialOwners *bool `json:"exempt_verifying_beneficial_owners,omitempty"`
	// If the legal entity is a trust, they may set this field to convey ownership and value to a trustee.
	ForTheBenefitOf *string `json:"for_the_benefit_of,omitempty"`
	// Indicates whether the entity is a foreign entity. By default, this is set to `false`.
	ForeignEntity *bool `json:"foreign_entity,omitempty"`
	// Indicates whether the entity is a foreign financial institution. By default, this is set to `false`.
	ForeignFinancialInstitution *bool `json:"foreign_financial_institution,omitempty"`
	// If the legal entity is a trust, the formation date is required.
	FormationDate *PartyFormationDate `json:"formation_date,omitempty"`
	// Globally Unique identifier for a legal natural person
	GlobalPersonID *string `json:"global_person_id,omitempty"`
	// Indicates whether the entity is an institutional customer
	InstitutionalCustomer *bool `json:"institutional_customer,omitempty"`
	// Investigation id relating to the Customer Identification Program (CIP) and Customer Due Diligence (CDD).
	InvestigationID *string `json:"investigation_id,omitempty"`
	// Large trader for the legal entity.
	LargeTrader *PartyLargeTrader `json:"large_trader,omitempty"`
	// The mailing address of the legal entity. Required fields within the `legal_address` object include:
	//  - `administrative_area`
	//  - `region_code` - 2 character CLDR Code
	//  - `postal_code`
	//  - `locality`
	//  - `address_lines` - max 5 lines
	LegalAddress *PartyLegalAddress `json:"legal_address,omitempty"`
	// A system-generated unique identifier referencing a single juridical (non-natural) person (e.g., a corporation); Used to access the record after creation
	LegalEntityID *string `json:"legal_entity_id,omitempty"`
	// The Legal Entity Identifier (LEI) is the financial industry term for a unique global identifier for legal entities participating in financial transactions
	LeiCode *string `json:"lei_code,omitempty"`
	// The name field Format: legalEntities/{legalEntity}
	Name *string `json:"name,omitempty"`
	// The operational footprint of an entity. Operating regions encompass all countries and regions where a company has a significant business presence This includes locations with physical offices, manufacturing plants, service centers, and sales and marketing activities Regions must be provided as two-character CLDR country codes
	OperatingRegions []string `json:"operating_regions,omitempty"`
	// The legal home of an entity. A region of registration, in the context of a corporation, refers to the specific geographic area where the corporation is legally registered and incorporated Defines the legal jurisdiction and framework under which the corporation operates, including legal regulations, tax obligations, and compliance requirements Region must be provided as a two-character CLDR country code
	RegistrationRegion *string `json:"registration_region,omitempty"`
	// Indicates whether the entity is a regulated investment company. By default, this is set to `false`.
	RegulatedInvestmentCompany *bool `json:"regulated_investment_company,omitempty"`
	// Document ids related to the legal entity. At least one is required for RIA correspondents when creating Estate or Trust accounts.
	RelatedDocumentIds []string `json:"related_document_ids,omitempty"`
	// Indicates whether the trust is a revocable trust. By default, this is set to `false`.
	RevocableTrust *bool `json:"revocable_trust,omitempty"`
	// The full U.S. tax ID for a related entity; Must be provided with `EIN` tax ID type
	TaxID *string `json:"tax_id,omitempty"`
	// The last four characters of the related person's tax identifier; Masked/truncated to "last four" in most usage contexts to preserve data privacy.
	TaxIDLastFour *string `json:"tax_id_last_four,omitempty"`
	// The nature of the U.S. Tax ID indicated in the related tax_id field; Examples include ITIN, SSN, EIN.
	TaxIDType *PartyTaxIDType `json:"tax_id_type,omitempty"`
	// The tax profile for the legal entity.
	TaxProfile *PartyTaxProfile `json:"tax_profile,omitempty"`
}

func (o *PartyLegalEntity) GetAccreditedInvestor() *bool {
	if o == nil {
		return nil
	}
	return o.AccreditedInvestor
}

func (o *PartyLegalEntity) GetAdviser() *bool {
	if o == nil {
		return nil
	}
	return o.Adviser
}

func (o *PartyLegalEntity) GetBrokerDealer() *bool {
	if o == nil {
		return nil
	}
	return o.BrokerDealer
}

func (o *PartyLegalEntity) GetBusinessIndustrialClassification() *PartyBusinessIndustrialClassification {
	if o == nil {
		return nil
	}
	return o.BusinessIndustrialClassification
}

func (o *PartyLegalEntity) GetCorporateStructure() *PartyCorporateStructure {
	if o == nil {
		return nil
	}
	return o.CorporateStructure
}

func (o *PartyLegalEntity) GetCorrespondentID() *string {
	if o == nil {
		return nil
	}
	return o.CorrespondentID
}

func (o *PartyLegalEntity) GetDoingBusinessAs() []string {
	if o == nil {
		return nil
	}
	return o.DoingBusinessAs
}

func (o *PartyLegalEntity) GetEntityDueDiligence() *PartyEntityDueDiligence {
	if o == nil {
		return nil
	}
	return o.EntityDueDiligence
}

func (o *PartyLegalEntity) GetEntityName() *string {
	if o == nil {
		return nil
	}
	return o.EntityName
}

func (o *PartyLegalEntity) GetEntityType() *PartyEntityType {
	if o == nil {
		return nil
	}
	return o.EntityType
}

func (o *PartyLegalEntity) GetExemptCustomerReason() *PartyExemptCustomerReason {
	if o == nil {
		return nil
	}
	return o.ExemptCustomerReason
}

func (o *PartyLegalEntity) GetExemptVerifyingBeneficialOwners() *bool {
	if o == nil {
		return nil
	}
	return o.ExemptVerifyingBeneficialOwners
}

func (o *PartyLegalEntity) GetForTheBenefitOf() *string {
	if o == nil {
		return nil
	}
	return o.ForTheBenefitOf
}

func (o *PartyLegalEntity) GetForeignEntity() *bool {
	if o == nil {
		return nil
	}
	return o.ForeignEntity
}

func (o *PartyLegalEntity) GetForeignFinancialInstitution() *bool {
	if o == nil {
		return nil
	}
	return o.ForeignFinancialInstitution
}

func (o *PartyLegalEntity) GetFormationDate() *PartyFormationDate {
	if o == nil {
		return nil
	}
	return o.FormationDate
}

func (o *PartyLegalEntity) GetGlobalPersonID() *string {
	if o == nil {
		return nil
	}
	return o.GlobalPersonID
}

func (o *PartyLegalEntity) GetInstitutionalCustomer() *bool {
	if o == nil {
		return nil
	}
	return o.InstitutionalCustomer
}

func (o *PartyLegalEntity) GetInvestigationID() *string {
	if o == nil {
		return nil
	}
	return o.InvestigationID
}

func (o *PartyLegalEntity) GetLargeTrader() *PartyLargeTrader {
	if o == nil {
		return nil
	}
	return o.LargeTrader
}

func (o *PartyLegalEntity) GetLegalAddress() *PartyLegalAddress {
	if o == nil {
		return nil
	}
	return o.LegalAddress
}

func (o *PartyLegalEntity) GetLegalEntityID() *string {
	if o == nil {
		return nil
	}
	return o.LegalEntityID
}

func (o *PartyLegalEntity) GetLeiCode() *string {
	if o == nil {
		return nil
	}
	return o.LeiCode
}

func (o *PartyLegalEntity) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *PartyLegalEntity) GetOperatingRegions() []string {
	if o == nil {
		return nil
	}
	return o.OperatingRegions
}

func (o *PartyLegalEntity) GetRegistrationRegion() *string {
	if o == nil {
		return nil
	}
	return o.RegistrationRegion
}

func (o *PartyLegalEntity) GetRegulatedInvestmentCompany() *bool {
	if o == nil {
		return nil
	}
	return o.RegulatedInvestmentCompany
}

func (o *PartyLegalEntity) GetRelatedDocumentIds() []string {
	if o == nil {
		return nil
	}
	return o.RelatedDocumentIds
}

func (o *PartyLegalEntity) GetRevocableTrust() *bool {
	if o == nil {
		return nil
	}
	return o.RevocableTrust
}

func (o *PartyLegalEntity) GetTaxID() *string {
	if o == nil {
		return nil
	}
	return o.TaxID
}

func (o *PartyLegalEntity) GetTaxIDLastFour() *string {
	if o == nil {
		return nil
	}
	return o.TaxIDLastFour
}

func (o *PartyLegalEntity) GetTaxIDType() *PartyTaxIDType {
	if o == nil {
		return nil
	}
	return o.TaxIDType
}

func (o *PartyLegalEntity) GetTaxProfile() *PartyTaxProfile {
	if o == nil {
		return nil
	}
	return o.TaxProfile
}

// PartyBirthDate - The legal day, month, and year of birth for a natural person.
type PartyBirthDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PartyBirthDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PartyBirthDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PartyBirthDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// PartyDeathDate - The day, month, and year of death of a legal natural person
type PartyDeathDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PartyDeathDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PartyDeathDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PartyDeathDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// PartyEmployerAddress - The data structure containing attributes describing the location of an investor's employer. If input, the required fields within the `employer_address` object include:
//   - `administrative_area`
//   - `region_code` - 2 character CLDR Code
//   - `postal_code`
//   - `locality`
//   - `address_lines` - max 5 lines
type PartyEmployerAddress struct {
	// Unstructured address lines describing the lower levels of an address.
	//
	//  Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language.
	//
	//  The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved.
	//
	//  Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
	AddressLines []string `json:"address_lines,omitempty"`
	// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
	AdministrativeArea *string `json:"administrative_area,omitempty"`
	// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations.
	//
	//  If this value is not known, it should be omitted (rather than specifying a possibly incorrect default).
	//
	//  Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode *string `json:"language_code,omitempty"`
	// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
	Locality *string `json:"locality,omitempty"`
	// Optional. The name of the organization at the address.
	Organization *string `json:"organization,omitempty"`
	// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode *string `json:"postal_code,omitempty"`
	// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
	Recipients []string `json:"recipients,omitempty"`
	// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
	RegionCode *string `json:"region_code,omitempty"`
	// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision.
	//
	//  All new revisions **must** be backward compatible with old revisions.
	Revision *int `json:"revision,omitempty"`
	// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
	SortingCode *string `json:"sorting_code,omitempty"`
	// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
	Sublocality *string `json:"sublocality,omitempty"`
}

func (o *PartyEmployerAddress) GetAddressLines() []string {
	if o == nil {
		return nil
	}
	return o.AddressLines
}

func (o *PartyEmployerAddress) GetAdministrativeArea() *string {
	if o == nil {
		return nil
	}
	return o.AdministrativeArea
}

func (o *PartyEmployerAddress) GetLanguageCode() *string {
	if o == nil {
		return nil
	}
	return o.LanguageCode
}

func (o *PartyEmployerAddress) GetLocality() *string {
	if o == nil {
		return nil
	}
	return o.Locality
}

func (o *PartyEmployerAddress) GetOrganization() *string {
	if o == nil {
		return nil
	}
	return o.Organization
}

func (o *PartyEmployerAddress) GetPostalCode() *string {
	if o == nil {
		return nil
	}
	return o.PostalCode
}

func (o *PartyEmployerAddress) GetRecipients() []string {
	if o == nil {
		return nil
	}
	return o.Recipients
}

func (o *PartyEmployerAddress) GetRegionCode() *string {
	if o == nil {
		return nil
	}
	return o.RegionCode
}

func (o *PartyEmployerAddress) GetRevision() *int {
	if o == nil {
		return nil
	}
	return o.Revision
}

func (o *PartyEmployerAddress) GetSortingCode() *string {
	if o == nil {
		return nil
	}
	return o.SortingCode
}

func (o *PartyEmployerAddress) GetSublocality() *string {
	if o == nil {
		return nil
	}
	return o.Sublocality
}

// PartyEmploymentStatus - Classifies in what capacity (or if) the underlying natural person holds a job
type PartyEmploymentStatus string

const (
	PartyEmploymentStatusStatusUnspecified PartyEmploymentStatus = "STATUS_UNSPECIFIED"
	PartyEmploymentStatusEmployed          PartyEmploymentStatus = "EMPLOYED"
	PartyEmploymentStatusSelfEmployed      PartyEmploymentStatus = "SELF_EMPLOYED"
	PartyEmploymentStatusUnemployed        PartyEmploymentStatus = "UNEMPLOYED"
	PartyEmploymentStatusRetired           PartyEmploymentStatus = "RETIRED"
	PartyEmploymentStatusStudent           PartyEmploymentStatus = "STUDENT"
)

func (e PartyEmploymentStatus) ToPointer() *PartyEmploymentStatus {
	return &e
}
func (e *PartyEmploymentStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STATUS_UNSPECIFIED":
		fallthrough
	case "EMPLOYED":
		fallthrough
	case "SELF_EMPLOYED":
		fallthrough
	case "UNEMPLOYED":
		fallthrough
	case "RETIRED":
		fallthrough
	case "STUDENT":
		*e = PartyEmploymentStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyEmploymentStatus: %v", v)
	}
}

// PartyEmployment - Object containing information pertaining to a investor's current employer including the name, address, and duration of employment.
type PartyEmployment struct {
	// The business name of an investor's employer.
	Employer *string `json:"employer,omitempty"`
	// The data structure containing attributes describing the location of an investor's employer. If input, the required fields within the `employer_address` object include:
	//  - `administrative_area`
	//  - `region_code` - 2 character CLDR Code
	//  - `postal_code`
	//  - `locality`
	//  - `address_lines` - max 5 lines
	EmployerAddress *PartyEmployerAddress `json:"employer_address,omitempty"`
	// System-generated GUID representing the employment record of a natural person
	EmploymentID *string `json:"employment_id,omitempty"`
	// Classifies in what capacity (or if) the underlying natural person holds a job
	EmploymentStatus *PartyEmploymentStatus `json:"employment_status,omitempty"`
	// The nature of work performed at an investor's place of employment.
	Occupation *string `json:"occupation,omitempty"`
	// The start year of employment related to a person's stated employer Must be from birth year to current year, or 0 to clear start year value
	StartYear *int `json:"start_year,omitempty"`
}

func (o *PartyEmployment) GetEmployer() *string {
	if o == nil {
		return nil
	}
	return o.Employer
}

func (o *PartyEmployment) GetEmployerAddress() *PartyEmployerAddress {
	if o == nil {
		return nil
	}
	return o.EmployerAddress
}

func (o *PartyEmployment) GetEmploymentID() *string {
	if o == nil {
		return nil
	}
	return o.EmploymentID
}

func (o *PartyEmployment) GetEmploymentStatus() *PartyEmploymentStatus {
	if o == nil {
		return nil
	}
	return o.EmploymentStatus
}

func (o *PartyEmployment) GetOccupation() *string {
	if o == nil {
		return nil
	}
	return o.Occupation
}

func (o *PartyEmployment) GetStartYear() *int {
	if o == nil {
		return nil
	}
	return o.StartYear
}

// PartyExpirationDate - Identification expiration date
type PartyExpirationDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PartyExpirationDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PartyExpirationDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PartyExpirationDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// PartyIssueDate - Identification issue date
type PartyIssueDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PartyIssueDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PartyIssueDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PartyIssueDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// PartyLegalNaturalPersonType - Identification type
type PartyLegalNaturalPersonType string

const (
	PartyLegalNaturalPersonTypeIdentificationTypeUnspecified PartyLegalNaturalPersonType = "IDENTIFICATION_TYPE_UNSPECIFIED"
	PartyLegalNaturalPersonTypePassport                      PartyLegalNaturalPersonType = "PASSPORT"
	PartyLegalNaturalPersonTypeNationalID                    PartyLegalNaturalPersonType = "NATIONAL_ID"
	PartyLegalNaturalPersonTypeDriversLicense                PartyLegalNaturalPersonType = "DRIVERS_LICENSE"
)

func (e PartyLegalNaturalPersonType) ToPointer() *PartyLegalNaturalPersonType {
	return &e
}
func (e *PartyLegalNaturalPersonType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "IDENTIFICATION_TYPE_UNSPECIFIED":
		fallthrough
	case "PASSPORT":
		fallthrough
	case "NATIONAL_ID":
		fallthrough
	case "DRIVERS_LICENSE":
		*e = PartyLegalNaturalPersonType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyLegalNaturalPersonType: %v", v)
	}
}

// PartyForeignIdentification - Foreign identification. Must be provided if the person does not have a U.S. tax ID
type PartyForeignIdentification struct {
	// Identification expiration date
	ExpirationDate *PartyExpirationDate `json:"expiration_date,omitempty"`
	// Denotes if the identification is a tax id or other
	Ftin *bool `json:"ftin,omitempty"`
	// Identification number
	IdentificationNumber *string `json:"identification_number,omitempty"`
	// Identification issue date
	IssueDate *PartyIssueDate `json:"issue_date,omitempty"`
	// Region of issuance must be provided as a two-character CLDR country code
	IssuingRegionCode *string `json:"issuing_region_code,omitempty"`
	// Identification type
	Type *PartyLegalNaturalPersonType `json:"type,omitempty"`
}

func (o *PartyForeignIdentification) GetExpirationDate() *PartyExpirationDate {
	if o == nil {
		return nil
	}
	return o.ExpirationDate
}

func (o *PartyForeignIdentification) GetFtin() *bool {
	if o == nil {
		return nil
	}
	return o.Ftin
}

func (o *PartyForeignIdentification) GetIdentificationNumber() *string {
	if o == nil {
		return nil
	}
	return o.IdentificationNumber
}

func (o *PartyForeignIdentification) GetIssueDate() *PartyIssueDate {
	if o == nil {
		return nil
	}
	return o.IssueDate
}

func (o *PartyForeignIdentification) GetIssuingRegionCode() *string {
	if o == nil {
		return nil
	}
	return o.IssuingRegionCode
}

func (o *PartyForeignIdentification) GetType() *PartyLegalNaturalPersonType {
	if o == nil {
		return nil
	}
	return o.Type
}

// PartyExecutionDate - The datetime external identity verification results were run on a natural person
type PartyExecutionDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PartyExecutionDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PartyExecutionDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PartyExecutionDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// PartyIdentityVerificationResult - Third-party data result used to verify the identity of an introduced investor. If the client identity_verification_model is PROVIDED_BY_CLIENT, this field is required
type PartyIdentityVerificationResult struct {
	// Attestation that external result and review have verified the supplied investor's address has been verified in conjunction with other PII
	AddressVerified *bool `json:"address_verified,omitempty"`
	// Attestation that external result and review have verified the supplied investor's date of birth has been verified in conjunction with other PII
	BirthDateVerified *bool `json:"birth_date_verified,omitempty"`
	// The datetime external identity verification results were run on a natural person
	ExecutionDate *PartyExecutionDate `json:"execution_date,omitempty"`
	// Client-generated identifier associated with the KYC results for the appropriate case
	ExternalCaseID *string `json:"external_case_id,omitempty"`
	// System generated document IDs returned after uploading identity documents to the Documents API
	IdentityVerificationDocumentIds []string `json:"identity_verification_document_ids,omitempty"`
	// System-generated GUID used to uniquely identify the verification_result
	IdentityVerificationResultID *string `json:"identity_verification_result_id,omitempty"`
	// Attestation that external result and review have verified the supplied investor's name has been verified in conjunction with other PII
	NameVerified *bool `json:"name_verified,omitempty"`
	// A system-generated document ID assigned when raw vendor results are uploaded to the Documents API; This field is optional for person record creation, but required for account creation if the Correspondent provides IDV results
	RawVendorDataDocumentID *string `json:"raw_vendor_data_document_id,omitempty"`
	// Attestation that external result and review have verified the supplied investor's Tax ID has been verified in conjunction with other PII
	TaxIDVerified *bool `json:"tax_id_verified,omitempty"`
	// The name(s) of the vendor(s) used to externally verify and screen a natural person; relates to the identity_verification_result
	Vendor *string `json:"vendor,omitempty"`
}

func (o *PartyIdentityVerificationResult) GetAddressVerified() *bool {
	if o == nil {
		return nil
	}
	return o.AddressVerified
}

func (o *PartyIdentityVerificationResult) GetBirthDateVerified() *bool {
	if o == nil {
		return nil
	}
	return o.BirthDateVerified
}

func (o *PartyIdentityVerificationResult) GetExecutionDate() *PartyExecutionDate {
	if o == nil {
		return nil
	}
	return o.ExecutionDate
}

func (o *PartyIdentityVerificationResult) GetExternalCaseID() *string {
	if o == nil {
		return nil
	}
	return o.ExternalCaseID
}

func (o *PartyIdentityVerificationResult) GetIdentityVerificationDocumentIds() []string {
	if o == nil {
		return nil
	}
	return o.IdentityVerificationDocumentIds
}

func (o *PartyIdentityVerificationResult) GetIdentityVerificationResultID() *string {
	if o == nil {
		return nil
	}
	return o.IdentityVerificationResultID
}

func (o *PartyIdentityVerificationResult) GetNameVerified() *bool {
	if o == nil {
		return nil
	}
	return o.NameVerified
}

func (o *PartyIdentityVerificationResult) GetRawVendorDataDocumentID() *string {
	if o == nil {
		return nil
	}
	return o.RawVendorDataDocumentID
}

func (o *PartyIdentityVerificationResult) GetTaxIDVerified() *bool {
	if o == nil {
		return nil
	}
	return o.TaxIDVerified
}

func (o *PartyIdentityVerificationResult) GetVendor() *string {
	if o == nil {
		return nil
	}
	return o.Vendor
}

// PartyLegalNaturalPersonEffectiveDate - The date on which the trader meets or exceeds the large trader reporting threshold, which is defined by the U.S. Securities and Exchange Commission (SEC) as trades of 2 million shares or $20 million in a single day or 20 million shares or $200 million during a calendar month
type PartyLegalNaturalPersonEffectiveDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PartyLegalNaturalPersonEffectiveDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PartyLegalNaturalPersonEffectiveDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PartyLegalNaturalPersonEffectiveDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// PartyLegalNaturalPersonLargeTrader - Indicates if the person is recognized as a "Large Trader" by the SEC.
type PartyLegalNaturalPersonLargeTrader struct {
	// The date on which the trader meets or exceeds the large trader reporting threshold, which is defined by the U.S. Securities and Exchange Commission (SEC) as trades of 2 million shares or $20 million in a single day or 20 million shares or $200 million during a calendar month
	EffectiveDate *PartyLegalNaturalPersonEffectiveDate `json:"effective_date,omitempty"`
	// SEC-issued ID signifying the person/entity as a large trader; Required for CAIS regulatory reporting.
	LargeTraderID *string `json:"large_trader_id,omitempty"`
}

func (o *PartyLegalNaturalPersonLargeTrader) GetEffectiveDate() *PartyLegalNaturalPersonEffectiveDate {
	if o == nil {
		return nil
	}
	return o.EffectiveDate
}

func (o *PartyLegalNaturalPersonLargeTrader) GetLargeTraderID() *string {
	if o == nil {
		return nil
	}
	return o.LargeTraderID
}

// PartyMaritalStatus - The legal marital status of an account-holder; Used in combination with state of domicile to determine qualification for account types and beneficiary exclusion rules.
type PartyMaritalStatus string

const (
	PartyMaritalStatusMaritalStatusUnspecified PartyMaritalStatus = "MARITAL_STATUS_UNSPECIFIED"
	PartyMaritalStatusSingle                   PartyMaritalStatus = "SINGLE"
	PartyMaritalStatusMarried                  PartyMaritalStatus = "MARRIED"
	PartyMaritalStatusDivorced                 PartyMaritalStatus = "DIVORCED"
	PartyMaritalStatusWidowed                  PartyMaritalStatus = "WIDOWED"
)

func (e PartyMaritalStatus) ToPointer() *PartyMaritalStatus {
	return &e
}
func (e *PartyMaritalStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MARITAL_STATUS_UNSPECIFIED":
		fallthrough
	case "SINGLE":
		fallthrough
	case "MARRIED":
		fallthrough
	case "DIVORCED":
		fallthrough
	case "WIDOWED":
		*e = PartyMaritalStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyMaritalStatus: %v", v)
	}
}

// PartyNameSuffix - The suffix of a natural person; A suffix in a name is any part of the name that comes after the last name
type PartyNameSuffix string

const (
	PartyNameSuffixNameSuffixUnspecified PartyNameSuffix = "NAME_SUFFIX_UNSPECIFIED"
	PartyNameSuffixSr                    PartyNameSuffix = "SR"
	PartyNameSuffixJr                    PartyNameSuffix = "JR"
	PartyNameSuffixIii                   PartyNameSuffix = "III"
	PartyNameSuffixIv                    PartyNameSuffix = "IV"
	PartyNameSuffixV                     PartyNameSuffix = "V"
)

func (e PartyNameSuffix) ToPointer() *PartyNameSuffix {
	return &e
}
func (e *PartyNameSuffix) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "NAME_SUFFIX_UNSPECIFIED":
		fallthrough
	case "SR":
		fallthrough
	case "JR":
		fallthrough
	case "III":
		fallthrough
	case "IV":
		fallthrough
	case "V":
		*e = PartyNameSuffix(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyNameSuffix: %v", v)
	}
}

// PartyCustomerReferralSource - Customer Referral Source
type PartyCustomerReferralSource struct {
	// The name of the referrer
	Name *string `json:"name,omitempty"`
	// The relationship of the referrer to the applicant
	RelationshipToApplicant *string `json:"relationship_to_applicant,omitempty"`
	// The years the referrer has known the applicant If the referrer has known the applicant for less than a year, they must specify 1
	RelationshipYearsWithApplicant *int `json:"relationship_years_with_applicant,omitempty"`
	// The years the referrer has known the broker If the referrer has known the broker for less than a year, they must specify 1
	RelationshipYearsWithBroker *int `json:"relationship_years_with_broker,omitempty"`
}

func (o *PartyCustomerReferralSource) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *PartyCustomerReferralSource) GetRelationshipToApplicant() *string {
	if o == nil {
		return nil
	}
	return o.RelationshipToApplicant
}

func (o *PartyCustomerReferralSource) GetRelationshipYearsWithApplicant() *int {
	if o == nil {
		return nil
	}
	return o.RelationshipYearsWithApplicant
}

func (o *PartyCustomerReferralSource) GetRelationshipYearsWithBroker() *int {
	if o == nil {
		return nil
	}
	return o.RelationshipYearsWithBroker
}

// PartyLegalNaturalPersonNegativeNews - Information about any negative news against the client, or any immediate family members, close associates, or related entities
type PartyLegalNaturalPersonNegativeNews struct {
	// Indicates whether there is negative news against related parties
	NegativeNewsAgainstRelatedParties *bool `json:"negative_news_against_related_parties,omitempty"`
	// Description of the negative news against related parties
	NegativeNewsAgainstRelatedPartiesDescription *string `json:"negative_news_against_related_parties_description,omitempty"`
}

func (o *PartyLegalNaturalPersonNegativeNews) GetNegativeNewsAgainstRelatedParties() *bool {
	if o == nil {
		return nil
	}
	return o.NegativeNewsAgainstRelatedParties
}

func (o *PartyLegalNaturalPersonNegativeNews) GetNegativeNewsAgainstRelatedPartiesDescription() *string {
	if o == nil {
		return nil
	}
	return o.NegativeNewsAgainstRelatedPartiesDescription
}

// PartyOtherSourcesOfWealth - The applicant's other source of wealth
type PartyOtherSourcesOfWealth struct {
	// Indicates whether the applicant has other sources of wealth.
	ApplicantHasOtherSourcesOfWealth *bool `json:"applicant_has_other_sources_of_wealth,omitempty"`
	// The applicant's other source of wealth description. If the applicant has no other sources of wealth, they must specify "N/A."
	OtherSourcesOfWealth *string `json:"other_sources_of_wealth,omitempty"`
	// The applicant's other source of wealth verification. If the applicant has no other sources of wealth, they must specify "N/A."
	OtherSourcesOfWealthVerification *string `json:"other_sources_of_wealth_verification,omitempty"`
}

func (o *PartyOtherSourcesOfWealth) GetApplicantHasOtherSourcesOfWealth() *bool {
	if o == nil {
		return nil
	}
	return o.ApplicantHasOtherSourcesOfWealth
}

func (o *PartyOtherSourcesOfWealth) GetOtherSourcesOfWealth() *string {
	if o == nil {
		return nil
	}
	return o.OtherSourcesOfWealth
}

func (o *PartyOtherSourcesOfWealth) GetOtherSourcesOfWealthVerification() *string {
	if o == nil {
		return nil
	}
	return o.OtherSourcesOfWealthVerification
}

// PartyNaturalPersonFdd - Foreign Due Diligence (FDD) information for Legal Natural Person
type PartyNaturalPersonFdd struct {
	// Customer Non-referral Source
	CustomerNonReferralSource *string `json:"customer_non_referral_source,omitempty"`
	// Customer Referral Source
	CustomerReferralSource *PartyCustomerReferralSource `json:"customer_referral_source,omitempty"`
	// The description of the applicant's source of wealth
	EmploymentAndEmployerDescription *string `json:"employment_and_employer_description,omitempty"`
	// Information about any negative news against the client, or any immediate family members, close associates, or related entities
	NegativeNews *PartyLegalNaturalPersonNegativeNews `json:"negative_news,omitempty"`
	// The applicant's other source of wealth
	OtherSourcesOfWealth *PartyOtherSourcesOfWealth `json:"other_sources_of_wealth,omitempty"`
}

func (o *PartyNaturalPersonFdd) GetCustomerNonReferralSource() *string {
	if o == nil {
		return nil
	}
	return o.CustomerNonReferralSource
}

func (o *PartyNaturalPersonFdd) GetCustomerReferralSource() *PartyCustomerReferralSource {
	if o == nil {
		return nil
	}
	return o.CustomerReferralSource
}

func (o *PartyNaturalPersonFdd) GetEmploymentAndEmployerDescription() *string {
	if o == nil {
		return nil
	}
	return o.EmploymentAndEmployerDescription
}

func (o *PartyNaturalPersonFdd) GetNegativeNews() *PartyLegalNaturalPersonNegativeNews {
	if o == nil {
		return nil
	}
	return o.NegativeNews
}

func (o *PartyNaturalPersonFdd) GetOtherSourcesOfWealth() *PartyOtherSourcesOfWealth {
	if o == nil {
		return nil
	}
	return o.OtherSourcesOfWealth
}

type PartyResidencyStatus string

const (
	PartyResidencyStatusResidencyStatusUnspecified PartyResidencyStatus = "RESIDENCY_STATUS_UNSPECIFIED"
	PartyResidencyStatusUsPermanentResident        PartyResidencyStatus = "US_PERMANENT_RESIDENT"
	PartyResidencyStatusUsTemporaryResident        PartyResidencyStatus = "US_TEMPORARY_RESIDENT"
	PartyResidencyStatusUsNonResident              PartyResidencyStatus = "US_NON_RESIDENT"
)

func (e PartyResidencyStatus) ToPointer() *PartyResidencyStatus {
	return &e
}
func (e *PartyResidencyStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "RESIDENCY_STATUS_UNSPECIFIED":
		fallthrough
	case "US_PERMANENT_RESIDENT":
		fallthrough
	case "US_TEMPORARY_RESIDENT":
		fallthrough
	case "US_NON_RESIDENT":
		*e = PartyResidencyStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyResidencyStatus: %v", v)
	}
}

// PartyNonCitizenResidency - Facilitates non-citizen lawful US residents to open domestic accounts
type PartyNonCitizenResidency struct {
	ResidencyStatus *PartyResidencyStatus `json:"residency_status,omitempty"`
}

func (o *PartyNonCitizenResidency) GetResidencyStatus() *PartyResidencyStatus {
	if o == nil {
		return nil
	}
	return o.ResidencyStatus
}

// PartyPersonalAddress - The legal street number and street name for an account Party. Required fields within the `personal_address` object include:
//   - `administrative_area`
//   - `region_code` - 2 character CLDR Code
//   - `postal_code`
//   - `locality`
//   - `address_lines` - max 5 lines
type PartyPersonalAddress struct {
	// Unstructured address lines describing the lower levels of an address.
	//
	//  Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language.
	//
	//  The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved.
	//
	//  Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
	AddressLines []string `json:"address_lines,omitempty"`
	// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
	AdministrativeArea *string `json:"administrative_area,omitempty"`
	// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations.
	//
	//  If this value is not known, it should be omitted (rather than specifying a possibly incorrect default).
	//
	//  Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode *string `json:"language_code,omitempty"`
	// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
	Locality *string `json:"locality,omitempty"`
	// Optional. The name of the organization at the address.
	Organization *string `json:"organization,omitempty"`
	// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode *string `json:"postal_code,omitempty"`
	// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
	Recipients []string `json:"recipients,omitempty"`
	// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
	RegionCode *string `json:"region_code,omitempty"`
	// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision.
	//
	//  All new revisions **must** be backward compatible with old revisions.
	Revision *int `json:"revision,omitempty"`
	// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
	SortingCode *string `json:"sorting_code,omitempty"`
	// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
	Sublocality *string `json:"sublocality,omitempty"`
}

func (o *PartyPersonalAddress) GetAddressLines() []string {
	if o == nil {
		return nil
	}
	return o.AddressLines
}

func (o *PartyPersonalAddress) GetAdministrativeArea() *string {
	if o == nil {
		return nil
	}
	return o.AdministrativeArea
}

func (o *PartyPersonalAddress) GetLanguageCode() *string {
	if o == nil {
		return nil
	}
	return o.LanguageCode
}

func (o *PartyPersonalAddress) GetLocality() *string {
	if o == nil {
		return nil
	}
	return o.Locality
}

func (o *PartyPersonalAddress) GetOrganization() *string {
	if o == nil {
		return nil
	}
	return o.Organization
}

func (o *PartyPersonalAddress) GetPostalCode() *string {
	if o == nil {
		return nil
	}
	return o.PostalCode
}

func (o *PartyPersonalAddress) GetRecipients() []string {
	if o == nil {
		return nil
	}
	return o.Recipients
}

func (o *PartyPersonalAddress) GetRegionCode() *string {
	if o == nil {
		return nil
	}
	return o.RegionCode
}

func (o *PartyPersonalAddress) GetRevision() *int {
	if o == nil {
		return nil
	}
	return o.Revision
}

func (o *PartyPersonalAddress) GetSortingCode() *string {
	if o == nil {
		return nil
	}
	return o.SortingCode
}

func (o *PartyPersonalAddress) GetSublocality() *string {
	if o == nil {
		return nil
	}
	return o.Sublocality
}

// PartyLegalNaturalPersonTaxIDType - The nature of the U.S. Tax ID indicated in the related tax_id field; Examples include ITIN, SSN, EIN.
type PartyLegalNaturalPersonTaxIDType string

const (
	PartyLegalNaturalPersonTaxIDTypeTaxIDTypeUnspecified PartyLegalNaturalPersonTaxIDType = "TAX_ID_TYPE_UNSPECIFIED"
	PartyLegalNaturalPersonTaxIDTypeTaxIDTypeSsn         PartyLegalNaturalPersonTaxIDType = "TAX_ID_TYPE_SSN"
	PartyLegalNaturalPersonTaxIDTypeTaxIDTypeItin        PartyLegalNaturalPersonTaxIDType = "TAX_ID_TYPE_ITIN"
	PartyLegalNaturalPersonTaxIDTypeTaxIDTypeEin         PartyLegalNaturalPersonTaxIDType = "TAX_ID_TYPE_EIN"
)

func (e PartyLegalNaturalPersonTaxIDType) ToPointer() *PartyLegalNaturalPersonTaxIDType {
	return &e
}
func (e *PartyLegalNaturalPersonTaxIDType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TAX_ID_TYPE_UNSPECIFIED":
		fallthrough
	case "TAX_ID_TYPE_SSN":
		fallthrough
	case "TAX_ID_TYPE_ITIN":
		fallthrough
	case "TAX_ID_TYPE_EIN":
		*e = PartyLegalNaturalPersonTaxIDType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyLegalNaturalPersonTaxIDType: %v", v)
	}
}

// PartyLegalNaturalPersonCNoticeDate - C Notice date.
type PartyLegalNaturalPersonCNoticeDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PartyLegalNaturalPersonCNoticeDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PartyLegalNaturalPersonCNoticeDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PartyLegalNaturalPersonCNoticeDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// PartyLegalNaturalPersonFederalTaxClassification - Federal tax classification.
type PartyLegalNaturalPersonFederalTaxClassification string

const (
	PartyLegalNaturalPersonFederalTaxClassificationFederalTaxClassificationUnspecified PartyLegalNaturalPersonFederalTaxClassification = "FEDERAL_TAX_CLASSIFICATION_UNSPECIFIED"
	PartyLegalNaturalPersonFederalTaxClassificationIndivSolepropOrSinglememberllc      PartyLegalNaturalPersonFederalTaxClassification = "INDIV_SOLEPROP_OR_SINGLEMEMBERLLC"
	PartyLegalNaturalPersonFederalTaxClassificationPartnership                         PartyLegalNaturalPersonFederalTaxClassification = "PARTNERSHIP"
	PartyLegalNaturalPersonFederalTaxClassificationCCorporation                        PartyLegalNaturalPersonFederalTaxClassification = "C_CORPORATION"
	PartyLegalNaturalPersonFederalTaxClassificationSCorporation                        PartyLegalNaturalPersonFederalTaxClassification = "S_CORPORATION"
	PartyLegalNaturalPersonFederalTaxClassificationTrustEstate                         PartyLegalNaturalPersonFederalTaxClassification = "TRUST_ESTATE"
	PartyLegalNaturalPersonFederalTaxClassificationLlcTaxedAsCCorp                     PartyLegalNaturalPersonFederalTaxClassification = "LLC_TAXED_AS_C_CORP"
	PartyLegalNaturalPersonFederalTaxClassificationLlcTaxedAsSCorp                     PartyLegalNaturalPersonFederalTaxClassification = "LLC_TAXED_AS_S_CORP"
	PartyLegalNaturalPersonFederalTaxClassificationLlcTaxedAsPartnership               PartyLegalNaturalPersonFederalTaxClassification = "LLC_TAXED_AS_PARTNERSHIP"
	PartyLegalNaturalPersonFederalTaxClassificationOther                               PartyLegalNaturalPersonFederalTaxClassification = "OTHER"
)

func (e PartyLegalNaturalPersonFederalTaxClassification) ToPointer() *PartyLegalNaturalPersonFederalTaxClassification {
	return &e
}
func (e *PartyLegalNaturalPersonFederalTaxClassification) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FEDERAL_TAX_CLASSIFICATION_UNSPECIFIED":
		fallthrough
	case "INDIV_SOLEPROP_OR_SINGLEMEMBERLLC":
		fallthrough
	case "PARTNERSHIP":
		fallthrough
	case "C_CORPORATION":
		fallthrough
	case "S_CORPORATION":
		fallthrough
	case "TRUST_ESTATE":
		fallthrough
	case "LLC_TAXED_AS_C_CORP":
		fallthrough
	case "LLC_TAXED_AS_S_CORP":
		fallthrough
	case "LLC_TAXED_AS_PARTNERSHIP":
		fallthrough
	case "OTHER":
		*e = PartyLegalNaturalPersonFederalTaxClassification(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyLegalNaturalPersonFederalTaxClassification: %v", v)
	}
}

// PartyLegalNaturalPersonFirstBNoticeDate - Initial B Notice date.
type PartyLegalNaturalPersonFirstBNoticeDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PartyLegalNaturalPersonFirstBNoticeDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PartyLegalNaturalPersonFirstBNoticeDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PartyLegalNaturalPersonFirstBNoticeDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// PartyLegalNaturalPersonIrsFormType - IRS form type.
type PartyLegalNaturalPersonIrsFormType string

const (
	PartyLegalNaturalPersonIrsFormTypeIrsFormTypeUnspecified PartyLegalNaturalPersonIrsFormType = "IRS_FORM_TYPE_UNSPECIFIED"
	PartyLegalNaturalPersonIrsFormTypeW9                     PartyLegalNaturalPersonIrsFormType = "W_9"
)

func (e PartyLegalNaturalPersonIrsFormType) ToPointer() *PartyLegalNaturalPersonIrsFormType {
	return &e
}
func (e *PartyLegalNaturalPersonIrsFormType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "IRS_FORM_TYPE_UNSPECIFIED":
		fallthrough
	case "W_9":
		*e = PartyLegalNaturalPersonIrsFormType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyLegalNaturalPersonIrsFormType: %v", v)
	}
}

// PartyLegalNaturalPersonReportingEligibility - Tax reporting eligibility.
type PartyLegalNaturalPersonReportingEligibility string

const (
	PartyLegalNaturalPersonReportingEligibilityTaxReportingEligibilityUnspecified PartyLegalNaturalPersonReportingEligibility = "TAX_REPORTING_ELIGIBILITY_UNSPECIFIED"
	PartyLegalNaturalPersonReportingEligibilityEligible                           PartyLegalNaturalPersonReportingEligibility = "ELIGIBLE"
	PartyLegalNaturalPersonReportingEligibilityIneligible                         PartyLegalNaturalPersonReportingEligibility = "INELIGIBLE"
)

func (e PartyLegalNaturalPersonReportingEligibility) ToPointer() *PartyLegalNaturalPersonReportingEligibility {
	return &e
}
func (e *PartyLegalNaturalPersonReportingEligibility) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TAX_REPORTING_ELIGIBILITY_UNSPECIFIED":
		fallthrough
	case "ELIGIBLE":
		fallthrough
	case "INELIGIBLE":
		*e = PartyLegalNaturalPersonReportingEligibility(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyLegalNaturalPersonReportingEligibility: %v", v)
	}
}

// PartyLegalNaturalPersonTaxCertificationDate - Tax Certification date.
type PartyLegalNaturalPersonTaxCertificationDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *PartyLegalNaturalPersonTaxCertificationDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *PartyLegalNaturalPersonTaxCertificationDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *PartyLegalNaturalPersonTaxCertificationDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// PartyLegalNaturalPersonTaxpayerCertificationState - Taxpayer certification status.
type PartyLegalNaturalPersonTaxpayerCertificationState string

const (
	PartyLegalNaturalPersonTaxpayerCertificationStateTaxpayerCertificationStateUnspecified PartyLegalNaturalPersonTaxpayerCertificationState = "TAXPAYER_CERTIFICATION_STATE_UNSPECIFIED"
	PartyLegalNaturalPersonTaxpayerCertificationStateCertified                             PartyLegalNaturalPersonTaxpayerCertificationState = "CERTIFIED"
	PartyLegalNaturalPersonTaxpayerCertificationStateUncertified                           PartyLegalNaturalPersonTaxpayerCertificationState = "UNCERTIFIED"
)

func (e PartyLegalNaturalPersonTaxpayerCertificationState) ToPointer() *PartyLegalNaturalPersonTaxpayerCertificationState {
	return &e
}
func (e *PartyLegalNaturalPersonTaxpayerCertificationState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TAXPAYER_CERTIFICATION_STATE_UNSPECIFIED":
		fallthrough
	case "CERTIFIED":
		fallthrough
	case "UNCERTIFIED":
		*e = PartyLegalNaturalPersonTaxpayerCertificationState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyLegalNaturalPersonTaxpayerCertificationState: %v", v)
	}
}

// PartyLegalNaturalPersonUsTinStatus - United States Individual Taxpayer Identification Number (ITIN) status.
type PartyLegalNaturalPersonUsTinStatus string

const (
	PartyLegalNaturalPersonUsTinStatusUsTinStatusUnspecified PartyLegalNaturalPersonUsTinStatus = "US_TIN_STATUS_UNSPECIFIED"
	PartyLegalNaturalPersonUsTinStatusPassing                PartyLegalNaturalPersonUsTinStatus = "PASSING"
	PartyLegalNaturalPersonUsTinStatusFailing                PartyLegalNaturalPersonUsTinStatus = "FAILING"
)

func (e PartyLegalNaturalPersonUsTinStatus) ToPointer() *PartyLegalNaturalPersonUsTinStatus {
	return &e
}
func (e *PartyLegalNaturalPersonUsTinStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "US_TIN_STATUS_UNSPECIFIED":
		fallthrough
	case "PASSING":
		fallthrough
	case "FAILING":
		*e = PartyLegalNaturalPersonUsTinStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyLegalNaturalPersonUsTinStatus: %v", v)
	}
}

// PartyLegalNaturalPersonWithholdingState - B/C Notice status.
type PartyLegalNaturalPersonWithholdingState string

const (
	PartyLegalNaturalPersonWithholdingStateWithholdingStateUnspecified PartyLegalNaturalPersonWithholdingState = "WITHHOLDING_STATE_UNSPECIFIED"
	PartyLegalNaturalPersonWithholdingStateFirstBNoticeReceived        PartyLegalNaturalPersonWithholdingState = "FIRST_B_NOTICE_RECEIVED"
	PartyLegalNaturalPersonWithholdingStateSecondBNoticeReceived       PartyLegalNaturalPersonWithholdingState = "SECOND_B_NOTICE_RECEIVED"
	PartyLegalNaturalPersonWithholdingStateCNoticeReceived             PartyLegalNaturalPersonWithholdingState = "C_NOTICE_RECEIVED"
	PartyLegalNaturalPersonWithholdingStateCNoticeIndicatedByCustomer  PartyLegalNaturalPersonWithholdingState = "C_NOTICE_INDICATED_BY_CUSTOMER"
)

func (e PartyLegalNaturalPersonWithholdingState) ToPointer() *PartyLegalNaturalPersonWithholdingState {
	return &e
}
func (e *PartyLegalNaturalPersonWithholdingState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "WITHHOLDING_STATE_UNSPECIFIED":
		fallthrough
	case "FIRST_B_NOTICE_RECEIVED":
		fallthrough
	case "SECOND_B_NOTICE_RECEIVED":
		fallthrough
	case "C_NOTICE_RECEIVED":
		fallthrough
	case "C_NOTICE_INDICATED_BY_CUSTOMER":
		*e = PartyLegalNaturalPersonWithholdingState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyLegalNaturalPersonWithholdingState: %v", v)
	}
}

// PartyLegalNaturalPersonTaxProfile - Tax-related attributes at the for the account; A tax profile with taxpayer attributes is located on the legal_natural_person or legal_entity objects elsewhere on the account record.
type PartyLegalNaturalPersonTaxProfile struct {
	// C Notice date.
	CNoticeDate *PartyLegalNaturalPersonCNoticeDate `json:"c_notice_date,omitempty"`
	// Federal tax classification.
	FederalTaxClassification *PartyLegalNaturalPersonFederalTaxClassification `json:"federal_tax_classification,omitempty"`
	// Initial B Notice date.
	FirstBNoticeDate *PartyLegalNaturalPersonFirstBNoticeDate `json:"first_b_notice_date,omitempty"`
	// IRS form type.
	IrsFormType *PartyLegalNaturalPersonIrsFormType `json:"irs_form_type,omitempty"`
	// Legal tax region must be "US" if provided W-9, otherwise must be a non-US country.
	LegalTaxRegionCode *string `json:"legal_tax_region_code,omitempty"`
	// Tax reporting eligibility.
	ReportingEligibility *PartyLegalNaturalPersonReportingEligibility `json:"reporting_eligibility,omitempty"`
	// Tax Certification date.
	TaxCertificationDate *PartyLegalNaturalPersonTaxCertificationDate `json:"tax_certification_date,omitempty"`
	// Taxpayer certification status.
	TaxpayerCertificationState *PartyLegalNaturalPersonTaxpayerCertificationState `json:"taxpayer_certification_state,omitempty"`
	// United States Individual Taxpayer Identification Number (ITIN) status.
	UsTinStatus *PartyLegalNaturalPersonUsTinStatus `json:"us_tin_status,omitempty"`
	// B/C Notice status.
	WithholdingState *PartyLegalNaturalPersonWithholdingState `json:"withholding_state,omitempty"`
}

func (o *PartyLegalNaturalPersonTaxProfile) GetCNoticeDate() *PartyLegalNaturalPersonCNoticeDate {
	if o == nil {
		return nil
	}
	return o.CNoticeDate
}

func (o *PartyLegalNaturalPersonTaxProfile) GetFederalTaxClassification() *PartyLegalNaturalPersonFederalTaxClassification {
	if o == nil {
		return nil
	}
	return o.FederalTaxClassification
}

func (o *PartyLegalNaturalPersonTaxProfile) GetFirstBNoticeDate() *PartyLegalNaturalPersonFirstBNoticeDate {
	if o == nil {
		return nil
	}
	return o.FirstBNoticeDate
}

func (o *PartyLegalNaturalPersonTaxProfile) GetIrsFormType() *PartyLegalNaturalPersonIrsFormType {
	if o == nil {
		return nil
	}
	return o.IrsFormType
}

func (o *PartyLegalNaturalPersonTaxProfile) GetLegalTaxRegionCode() *string {
	if o == nil {
		return nil
	}
	return o.LegalTaxRegionCode
}

func (o *PartyLegalNaturalPersonTaxProfile) GetReportingEligibility() *PartyLegalNaturalPersonReportingEligibility {
	if o == nil {
		return nil
	}
	return o.ReportingEligibility
}

func (o *PartyLegalNaturalPersonTaxProfile) GetTaxCertificationDate() *PartyLegalNaturalPersonTaxCertificationDate {
	if o == nil {
		return nil
	}
	return o.TaxCertificationDate
}

func (o *PartyLegalNaturalPersonTaxProfile) GetTaxpayerCertificationState() *PartyLegalNaturalPersonTaxpayerCertificationState {
	if o == nil {
		return nil
	}
	return o.TaxpayerCertificationState
}

func (o *PartyLegalNaturalPersonTaxProfile) GetUsTinStatus() *PartyLegalNaturalPersonUsTinStatus {
	if o == nil {
		return nil
	}
	return o.UsTinStatus
}

func (o *PartyLegalNaturalPersonTaxProfile) GetWithholdingState() *PartyLegalNaturalPersonWithholdingState {
	if o == nil {
		return nil
	}
	return o.WithholdingState
}

// PartyLegalNaturalPerson - Legal natural person.
type PartyLegalNaturalPerson struct {
	// Indicates whether the person is an accredited investor
	AccreditedInvestor *bool `json:"accredited_investor,omitempty"`
	// Indicates whether the person is an adviser
	Adviser *bool `json:"adviser,omitempty"`
	// The legal day, month, and year of birth for a natural person.
	BirthDate *PartyBirthDate `json:"birth_date,omitempty"`
	// This is used for tax (treaty) and country block list considerations Maximum list of two 2-char CLDR Code citizenship countries, e.g. US, CA
	CitizenshipCountries []string `json:"citizenship_countries,omitempty"`
	// A list of ticker symbols in which the underlying person is a control person; control persons are defined as having significant influence over a company’s management and operations, typically through ownership of a large percentage of the company’s voting stock or through positions on the company’s board of directors or executive team
	ControlPersonCompanySymbols *string `json:"control_person_company_symbols,omitempty"`
	// Indicates the related owner record is an employee of the clearing broker's correspondent customer.
	CorrespondentEmployee *bool `json:"correspondent_employee,omitempty"`
	// A unique identifier referencing a Correspondent; A Client may have several operating Correspondents within its purview.
	CorrespondentID *string `json:"correspondent_id,omitempty"`
	// A flag to indicate whether this person is an employee of the correspondent.
	CustodianEmployee *bool `json:"custodian_employee,omitempty"`
	// The day, month, and year of death of a legal natural person
	DeathDate *PartyDeathDate `json:"death_date,omitempty"`
	// DBA (Doing Business As) names. Can list up to 5 associated with the Legal Natural Person
	DoingBusinessAs []string `json:"doing_business_as,omitempty"`
	// Object containing information pertaining to a investor's current employer including the name, address, and duration of employment.
	Employment *PartyEmployment `json:"employment,omitempty"`
	// Family name of a natural person.
	FamilyName *string `json:"family_name,omitempty"`
	// The name of the FINRA-associated entity the underlying natural person is affiliated with.
	FinraAssociatedEntity *string `json:"finra_associated_entity,omitempty"`
	// Foreign identification. Must be provided if the person does not have a U.S. tax ID
	ForeignIdentification *PartyForeignIdentification `json:"foreign_identification,omitempty"`
	// The given name of a natural person; Conventionally known as 'first name' in most English-speaking countries.
	GivenName *string `json:"given_name,omitempty"`
	// Globally Unique identifier for a legal natural person
	GlobalPersonID *string `json:"global_person_id,omitempty"`
	// Third-party data result used to verify the identity of an introduced investor. If the client identity_verification_model is PROVIDED_BY_CLIENT, this field is required
	IdentityVerificationResult *PartyIdentityVerificationResult `json:"identity_verification_result,omitempty"`
	// Indicates whether the person is an institutional customer
	InstitutionalCustomer *bool `json:"institutional_customer,omitempty"`
	// Investigation id relating to the Customer Identification Program (CIP) and Customer Due Diligence (CDD).
	InvestigationID *string `json:"investigation_id,omitempty"`
	// Indicates if the person is recognized as a "Large Trader" by the SEC.
	LargeTrader *PartyLegalNaturalPersonLargeTrader `json:"large_trader,omitempty"`
	// A system-generated unique identifier referencing a single natural person; Used to access the record after creation.
	LegalNaturalPersonID *string `json:"legal_natural_person_id,omitempty"`
	// The legal marital status of an account-holder; Used in combination with state of domicile to determine qualification for account types and beneficiary exclusion rules.
	MaritalStatus *PartyMaritalStatus `json:"marital_status,omitempty"`
	// Non-primary names representing a natural person; Name attributed to a person other than "Given" and "Family" names.
	MiddleNames *string `json:"middle_names,omitempty"`
	// The name field Format: legalNaturalPersons/{legalNaturalPerson}
	Name *string `json:"name,omitempty"`
	// The suffix of a natural person; A suffix in a name is any part of the name that comes after the last name
	NameSuffix *PartyNameSuffix `json:"name_suffix,omitempty"`
	// Foreign Due Diligence (FDD) information for Legal Natural Person
	NaturalPersonFdd *PartyNaturalPersonFdd `json:"natural_person_fdd,omitempty"`
	// Facilitates non-citizen lawful US residents to open domestic accounts
	NonCitizenResidency *PartyNonCitizenResidency `json:"non_citizen_residency,omitempty"`
	// The legal street number and street name for an account Party. Required fields within the `personal_address` object include:
	//  - `administrative_area`
	//  - `region_code` - 2 character CLDR Code
	//  - `postal_code`
	//  - `locality`
	//  - `address_lines` - max 5 lines
	PersonalAddress *PartyPersonalAddress `json:"personal_address,omitempty"`
	// A Party's self-disclosed list of names representing family members who are politically exposed.
	PoliticallyExposedImmediateFamilyNames []string `json:"politically_exposed_immediate_family_names,omitempty"`
	// A Party's self-disclosed list of named politically exposed organizations they are personally associated with.
	PoliticallyExposedOrganization *string `json:"politically_exposed_organization,omitempty"`
	// The full U.S. tax ID for a related person; Must be provided with `ITIN` or `SSN` tax ID type
	TaxID *string `json:"tax_id,omitempty"`
	// The last four characters of the related person's tax identifier; Masked/truncated to "last four" in most usage contexts to preserve data privacy.
	TaxIDLastFour *string `json:"tax_id_last_four,omitempty"`
	// The nature of the U.S. Tax ID indicated in the related tax_id field; Examples include ITIN, SSN, EIN.
	TaxIDType *PartyLegalNaturalPersonTaxIDType `json:"tax_id_type,omitempty"`
	// Tax-related attributes at the for the account; A tax profile with taxpayer attributes is located on the legal_natural_person or legal_entity objects elsewhere on the account record.
	TaxProfile *PartyLegalNaturalPersonTaxProfile `json:"tax_profile,omitempty"`
}

func (o *PartyLegalNaturalPerson) GetAccreditedInvestor() *bool {
	if o == nil {
		return nil
	}
	return o.AccreditedInvestor
}

func (o *PartyLegalNaturalPerson) GetAdviser() *bool {
	if o == nil {
		return nil
	}
	return o.Adviser
}

func (o *PartyLegalNaturalPerson) GetBirthDate() *PartyBirthDate {
	if o == nil {
		return nil
	}
	return o.BirthDate
}

func (o *PartyLegalNaturalPerson) GetCitizenshipCountries() []string {
	if o == nil {
		return nil
	}
	return o.CitizenshipCountries
}

func (o *PartyLegalNaturalPerson) GetControlPersonCompanySymbols() *string {
	if o == nil {
		return nil
	}
	return o.ControlPersonCompanySymbols
}

func (o *PartyLegalNaturalPerson) GetCorrespondentEmployee() *bool {
	if o == nil {
		return nil
	}
	return o.CorrespondentEmployee
}

func (o *PartyLegalNaturalPerson) GetCorrespondentID() *string {
	if o == nil {
		return nil
	}
	return o.CorrespondentID
}

func (o *PartyLegalNaturalPerson) GetCustodianEmployee() *bool {
	if o == nil {
		return nil
	}
	return o.CustodianEmployee
}

func (o *PartyLegalNaturalPerson) GetDeathDate() *PartyDeathDate {
	if o == nil {
		return nil
	}
	return o.DeathDate
}

func (o *PartyLegalNaturalPerson) GetDoingBusinessAs() []string {
	if o == nil {
		return nil
	}
	return o.DoingBusinessAs
}

func (o *PartyLegalNaturalPerson) GetEmployment() *PartyEmployment {
	if o == nil {
		return nil
	}
	return o.Employment
}

func (o *PartyLegalNaturalPerson) GetFamilyName() *string {
	if o == nil {
		return nil
	}
	return o.FamilyName
}

func (o *PartyLegalNaturalPerson) GetFinraAssociatedEntity() *string {
	if o == nil {
		return nil
	}
	return o.FinraAssociatedEntity
}

func (o *PartyLegalNaturalPerson) GetForeignIdentification() *PartyForeignIdentification {
	if o == nil {
		return nil
	}
	return o.ForeignIdentification
}

func (o *PartyLegalNaturalPerson) GetGivenName() *string {
	if o == nil {
		return nil
	}
	return o.GivenName
}

func (o *PartyLegalNaturalPerson) GetGlobalPersonID() *string {
	if o == nil {
		return nil
	}
	return o.GlobalPersonID
}

func (o *PartyLegalNaturalPerson) GetIdentityVerificationResult() *PartyIdentityVerificationResult {
	if o == nil {
		return nil
	}
	return o.IdentityVerificationResult
}

func (o *PartyLegalNaturalPerson) GetInstitutionalCustomer() *bool {
	if o == nil {
		return nil
	}
	return o.InstitutionalCustomer
}

func (o *PartyLegalNaturalPerson) GetInvestigationID() *string {
	if o == nil {
		return nil
	}
	return o.InvestigationID
}

func (o *PartyLegalNaturalPerson) GetLargeTrader() *PartyLegalNaturalPersonLargeTrader {
	if o == nil {
		return nil
	}
	return o.LargeTrader
}

func (o *PartyLegalNaturalPerson) GetLegalNaturalPersonID() *string {
	if o == nil {
		return nil
	}
	return o.LegalNaturalPersonID
}

func (o *PartyLegalNaturalPerson) GetMaritalStatus() *PartyMaritalStatus {
	if o == nil {
		return nil
	}
	return o.MaritalStatus
}

func (o *PartyLegalNaturalPerson) GetMiddleNames() *string {
	if o == nil {
		return nil
	}
	return o.MiddleNames
}

func (o *PartyLegalNaturalPerson) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *PartyLegalNaturalPerson) GetNameSuffix() *PartyNameSuffix {
	if o == nil {
		return nil
	}
	return o.NameSuffix
}

func (o *PartyLegalNaturalPerson) GetNaturalPersonFdd() *PartyNaturalPersonFdd {
	if o == nil {
		return nil
	}
	return o.NaturalPersonFdd
}

func (o *PartyLegalNaturalPerson) GetNonCitizenResidency() *PartyNonCitizenResidency {
	if o == nil {
		return nil
	}
	return o.NonCitizenResidency
}

func (o *PartyLegalNaturalPerson) GetPersonalAddress() *PartyPersonalAddress {
	if o == nil {
		return nil
	}
	return o.PersonalAddress
}

func (o *PartyLegalNaturalPerson) GetPoliticallyExposedImmediateFamilyNames() []string {
	if o == nil {
		return nil
	}
	return o.PoliticallyExposedImmediateFamilyNames
}

func (o *PartyLegalNaturalPerson) GetPoliticallyExposedOrganization() *string {
	if o == nil {
		return nil
	}
	return o.PoliticallyExposedOrganization
}

func (o *PartyLegalNaturalPerson) GetTaxID() *string {
	if o == nil {
		return nil
	}
	return o.TaxID
}

func (o *PartyLegalNaturalPerson) GetTaxIDLastFour() *string {
	if o == nil {
		return nil
	}
	return o.TaxIDLastFour
}

func (o *PartyLegalNaturalPerson) GetTaxIDType() *PartyLegalNaturalPersonTaxIDType {
	if o == nil {
		return nil
	}
	return o.TaxIDType
}

func (o *PartyLegalNaturalPerson) GetTaxProfile() *PartyLegalNaturalPersonTaxProfile {
	if o == nil {
		return nil
	}
	return o.TaxProfile
}

// PartyMailingAddress - The object containing data for the purpose of delivery physical mailings to a party; Typically used for statements, account updates, tax documents, and other postal mailings; May also be used as an alternative identity verification address to personalAddress. Required fields within the `mailing_address` object include:
//   - `administrative_area`
//   - `region_code` - 2 character CLDR Code
//   - `postal_code`
//   - `locality`
//   - `address_lines` - max 5 lines
type PartyMailingAddress struct {
	// Unstructured address lines describing the lower levels of an address.
	//
	//  Because values in address_lines do not have type information and may sometimes contain multiple values in a single field (e.g. "Austin, TX"), it is important that the line order is clear. The order of address lines should be "envelope order" for the country/region of the address. In places where this can vary (e.g. Japan), address_language is used to make it explicit (e.g. "ja" for large-to-small ordering and "ja-Latn" or "en" for small-to-large). This way, the most specific line of an address can be selected based on the language.
	//
	//  The minimum permitted structural representation of an address consists of a region_code with all remaining information placed in the address_lines. It would be possible to format such an address very approximately without geocoding, but no semantic reasoning could be made about any of the address components until it was at least partially resolved.
	//
	//  Creating an address only containing a region_code and address_lines, and then geocoding is the recommended way to handle completely unstructured addresses (as opposed to guessing which parts of the address should be localities or administrative areas).
	AddressLines []string `json:"address_lines,omitempty"`
	// Optional. Highest administrative subdivision which is used for postal addresses of a country or region. For example, this can be a state, a province, an oblast, or a prefecture. Specifically, for Spain this is the province and not the autonomous community (e.g. "Barcelona" and not "Catalonia"). Many countries don't use an administrative area in postal addresses. E.g. in Switzerland this should be left unpopulated.
	AdministrativeArea *string `json:"administrative_area,omitempty"`
	// Optional. BCP-47 language code of the contents of this address (if known). This is often the UI language of the input form or is expected to match one of the languages used in the address' country/region, or their transliterated equivalents. This can affect formatting in certain countries, but is not critical to the correctness of the data and will never affect any validation or other non-formatting related operations.
	//
	//  If this value is not known, it should be omitted (rather than specifying a possibly incorrect default).
	//
	//  Examples: "zh-Hant", "ja", "ja-Latn", "en".
	LanguageCode *string `json:"language_code,omitempty"`
	// Optional. Generally refers to the city/town portion of the address. Examples: US city, IT comune, UK post town. In regions of the world where localities are not well defined or do not fit into this structure well, leave locality empty and use address_lines.
	Locality *string `json:"locality,omitempty"`
	// Optional. The name of the organization at the address.
	Organization *string `json:"organization,omitempty"`
	// Optional. Postal code of the address. Not all countries use or require postal codes to be present, but where they are used, they may trigger additional validation with other parts of the address (e.g. state/zip validation in the U.S.A.).
	PostalCode *string `json:"postal_code,omitempty"`
	// Optional. The recipient at the address. This field may, under certain circumstances, contain multiline information. For example, it might contain "care of" information.
	Recipients []string `json:"recipients,omitempty"`
	// Required. CLDR region code of the country/region of the address. This is never inferred and it is up to the user to ensure the value is correct. See http://cldr.unicode.org/ and http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html for details. Example: "CH" for Switzerland.
	RegionCode *string `json:"region_code,omitempty"`
	// The schema revision of the `PostalAddress`. This must be set to 0, which is the latest revision.
	//
	//  All new revisions **must** be backward compatible with old revisions.
	Revision *int `json:"revision,omitempty"`
	// Optional. Additional, country-specific, sorting code. This is not used in most regions. Where it is used, the value is either a string like "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number alone, representing the "sector code" (Jamaica), "delivery area indicator" (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
	SortingCode *string `json:"sorting_code,omitempty"`
	// Optional. Sublocality of the address. For example, this can be neighborhoods, boroughs, districts.
	Sublocality *string `json:"sublocality,omitempty"`
}

func (o *PartyMailingAddress) GetAddressLines() []string {
	if o == nil {
		return nil
	}
	return o.AddressLines
}

func (o *PartyMailingAddress) GetAdministrativeArea() *string {
	if o == nil {
		return nil
	}
	return o.AdministrativeArea
}

func (o *PartyMailingAddress) GetLanguageCode() *string {
	if o == nil {
		return nil
	}
	return o.LanguageCode
}

func (o *PartyMailingAddress) GetLocality() *string {
	if o == nil {
		return nil
	}
	return o.Locality
}

func (o *PartyMailingAddress) GetOrganization() *string {
	if o == nil {
		return nil
	}
	return o.Organization
}

func (o *PartyMailingAddress) GetPostalCode() *string {
	if o == nil {
		return nil
	}
	return o.PostalCode
}

func (o *PartyMailingAddress) GetRecipients() []string {
	if o == nil {
		return nil
	}
	return o.Recipients
}

func (o *PartyMailingAddress) GetRegionCode() *string {
	if o == nil {
		return nil
	}
	return o.RegionCode
}

func (o *PartyMailingAddress) GetRevision() *int {
	if o == nil {
		return nil
	}
	return o.Revision
}

func (o *PartyMailingAddress) GetSortingCode() *string {
	if o == nil {
		return nil
	}
	return o.SortingCode
}

func (o *PartyMailingAddress) GetSublocality() *string {
	if o == nil {
		return nil
	}
	return o.Sublocality
}

// PartyShortCode - A short code.
//
//	Reference(s):
//	- https://en.wikipedia.org/wiki/Short_code
type PartyShortCode struct {
	// Required. The short code digits, without a leading plus ('+') or country calling code, e.g. "611".
	Number *string `json:"number,omitempty"`
	// Required. The BCP-47 region code of the location where calls to this short code can be made, such as "US" and "BB".
	//
	//  Reference(s):
	//  - http://www.unicode.org/reports/tr35/#unicode_region_subtag
	RegionCode *string `json:"region_code,omitempty"`
}

func (o *PartyShortCode) GetNumber() *string {
	if o == nil {
		return nil
	}
	return o.Number
}

func (o *PartyShortCode) GetRegionCode() *string {
	if o == nil {
		return nil
	}
	return o.RegionCode
}

// PartyPhoneNumber - The phone number for a party. Lives on the party record in the context of the account and does not commute to other accounts held by/for the person.
type PartyPhoneNumber struct {
	// The phone number, represented as a leading plus sign ('+'), followed by a phone number that uses a relaxed ITU E.164 format consisting of the country calling code (1 to 3 digits) and the subscriber number, with no additional spaces or formatting, e.g.: - correct: "+15552220123" - incorrect: "+1 (555) 222-01234 x123".
	//
	//  The ITU E.164 format limits the latter to 12 digits, but in practice not all countries respect that, so we relax that restriction here. National-only numbers are not allowed.
	//
	//  References: - https://www.itu.int/rec/T-REC-E.164-201011-I - https://en.wikipedia.org/wiki/E.164. - https://en.wikipedia.org/wiki/List_of_country_calling_codes
	E164Number *string `json:"e164_number,omitempty"`
	// The phone number's extension. The extension is not standardized in ITU recommendations, except for being defined as a series of numbers with a maximum length of 40 digits. Other than digits, some other dialing characters such as ',' (indicating a wait) or '#' may be stored here.
	//
	//  Note that no regions currently use extensions with short codes, so this field is normally only set in conjunction with an E.164 number. It is held separately from the E.164 number to allow for short code extensions in the future.
	Extension *string `json:"extension,omitempty"`
	// A short code.
	//
	//  Reference(s):
	//  - https://en.wikipedia.org/wiki/Short_code
	ShortCode *PartyShortCode `json:"short_code,omitempty"`
}

func (o *PartyPhoneNumber) GetE164Number() *string {
	if o == nil {
		return nil
	}
	return o.E164Number
}

func (o *PartyPhoneNumber) GetExtension() *string {
	if o == nil {
		return nil
	}
	return o.Extension
}

func (o *PartyPhoneNumber) GetShortCode() *PartyShortCode {
	if o == nil {
		return nil
	}
	return o.ShortCode
}

// PartyProspectusDeliveryPreference - Delivery method instruction for prospectuses for a given Party record; Can be `DIGITAL`, `PHYSICAL`, `SUPPRESS`; Defaults to `DIGITAL` on account creation but may be updated
type PartyProspectusDeliveryPreference string

const (
	PartyProspectusDeliveryPreferenceDeliveryPreferenceUnspecified PartyProspectusDeliveryPreference = "DELIVERY_PREFERENCE_UNSPECIFIED"
	PartyProspectusDeliveryPreferenceDigital                       PartyProspectusDeliveryPreference = "DIGITAL"
	PartyProspectusDeliveryPreferencePhysical                      PartyProspectusDeliveryPreference = "PHYSICAL"
	PartyProspectusDeliveryPreferenceSuppress                      PartyProspectusDeliveryPreference = "SUPPRESS"
)

func (e PartyProspectusDeliveryPreference) ToPointer() *PartyProspectusDeliveryPreference {
	return &e
}
func (e *PartyProspectusDeliveryPreference) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DELIVERY_PREFERENCE_UNSPECIFIED":
		fallthrough
	case "DIGITAL":
		fallthrough
	case "PHYSICAL":
		fallthrough
	case "SUPPRESS":
		*e = PartyProspectusDeliveryPreference(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyProspectusDeliveryPreference: %v", v)
	}
}

// PartyProxyDeliveryPreference - Delivery method instruction for proxy voting for a given Party record; Can be `DIGITAL`, `PHYSICAL`, `SUPPRESS`; Defaults to `DIGITAL` on account creation but may be updated
type PartyProxyDeliveryPreference string

const (
	PartyProxyDeliveryPreferenceDeliveryPreferenceUnspecified PartyProxyDeliveryPreference = "DELIVERY_PREFERENCE_UNSPECIFIED"
	PartyProxyDeliveryPreferenceDigital                       PartyProxyDeliveryPreference = "DIGITAL"
	PartyProxyDeliveryPreferencePhysical                      PartyProxyDeliveryPreference = "PHYSICAL"
	PartyProxyDeliveryPreferenceSuppress                      PartyProxyDeliveryPreference = "SUPPRESS"
)

func (e PartyProxyDeliveryPreference) ToPointer() *PartyProxyDeliveryPreference {
	return &e
}
func (e *PartyProxyDeliveryPreference) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DELIVERY_PREFERENCE_UNSPECIFIED":
		fallthrough
	case "DIGITAL":
		fallthrough
	case "PHYSICAL":
		fallthrough
	case "SUPPRESS":
		*e = PartyProxyDeliveryPreference(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyProxyDeliveryPreference: %v", v)
	}
}

// PartyRelationType - Conveys how a person is related to account; Located on each account Party record; Examples are `PRIMARY_OWNER`, `JOINT_OWNER`, `EXECUTOR`, etc.
type PartyRelationType string

const (
	PartyRelationTypePartyRelationTypeUnspecified PartyRelationType = "PARTY_RELATION_TYPE_UNSPECIFIED"
	PartyRelationTypePrimaryOwner                 PartyRelationType = "PRIMARY_OWNER"
	PartyRelationTypeJointOwner                   PartyRelationType = "JOINT_OWNER"
	PartyRelationTypeCustodian                    PartyRelationType = "CUSTODIAN"
	PartyRelationTypeGuardianConservator          PartyRelationType = "GUARDIAN_CONSERVATOR"
	PartyRelationTypePowerOfAttorney              PartyRelationType = "POWER_OF_ATTORNEY"
	PartyRelationTypeExecutor                     PartyRelationType = "EXECUTOR"
	PartyRelationTypeAuthorizedSigner             PartyRelationType = "AUTHORIZED_SIGNER"
	PartyRelationTypeBeneficialOwner              PartyRelationType = "BENEFICIAL_OWNER"
	PartyRelationTypeControlPerson                PartyRelationType = "CONTROL_PERSON"
	PartyRelationTypeAuthorizedRepresentative     PartyRelationType = "AUTHORIZED_REPRESENTATIVE"
	PartyRelationTypeTrustee                      PartyRelationType = "TRUSTEE"
	PartyRelationTypeAuthTrusteeRep               PartyRelationType = "AUTH_TRUSTEE_REP"
)

func (e PartyRelationType) ToPointer() *PartyRelationType {
	return &e
}
func (e *PartyRelationType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "PARTY_RELATION_TYPE_UNSPECIFIED":
		fallthrough
	case "PRIMARY_OWNER":
		fallthrough
	case "JOINT_OWNER":
		fallthrough
	case "CUSTODIAN":
		fallthrough
	case "GUARDIAN_CONSERVATOR":
		fallthrough
	case "POWER_OF_ATTORNEY":
		fallthrough
	case "EXECUTOR":
		fallthrough
	case "AUTHORIZED_SIGNER":
		fallthrough
	case "BENEFICIAL_OWNER":
		fallthrough
	case "CONTROL_PERSON":
		fallthrough
	case "AUTHORIZED_REPRESENTATIVE":
		fallthrough
	case "TRUSTEE":
		fallthrough
	case "AUTH_TRUSTEE_REP":
		*e = PartyRelationType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyRelationType: %v", v)
	}
}

// PartyStatementDeliveryPreference - Delivery method instruction for account statements for a given Party record; Can be `DIGITAL`, `PHYSICAL`, `SUPPRESS`; Defaults to `DIGITAL` on account creation but may be updated
type PartyStatementDeliveryPreference string

const (
	PartyStatementDeliveryPreferenceDeliveryPreferenceUnspecified PartyStatementDeliveryPreference = "DELIVERY_PREFERENCE_UNSPECIFIED"
	PartyStatementDeliveryPreferenceDigital                       PartyStatementDeliveryPreference = "DIGITAL"
	PartyStatementDeliveryPreferencePhysical                      PartyStatementDeliveryPreference = "PHYSICAL"
	PartyStatementDeliveryPreferenceSuppress                      PartyStatementDeliveryPreference = "SUPPRESS"
)

func (e PartyStatementDeliveryPreference) ToPointer() *PartyStatementDeliveryPreference {
	return &e
}
func (e *PartyStatementDeliveryPreference) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DELIVERY_PREFERENCE_UNSPECIFIED":
		fallthrough
	case "DIGITAL":
		fallthrough
	case "PHYSICAL":
		fallthrough
	case "SUPPRESS":
		*e = PartyStatementDeliveryPreference(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyStatementDeliveryPreference: %v", v)
	}
}

// PartyTaxDocumentDeliveryPreference - Delivery method instruction for tax documents for a given Party record; Can be `DIGITAL`, `PHYSICAL`, `SUPPRESS`; Defaults to `DIGITAL` on account creation but may be updated; Per regulation, selected tax forms will be mailed by regulation regardless of this setting
type PartyTaxDocumentDeliveryPreference string

const (
	PartyTaxDocumentDeliveryPreferenceDeliveryPreferenceUnspecified PartyTaxDocumentDeliveryPreference = "DELIVERY_PREFERENCE_UNSPECIFIED"
	PartyTaxDocumentDeliveryPreferenceDigital                       PartyTaxDocumentDeliveryPreference = "DIGITAL"
	PartyTaxDocumentDeliveryPreferencePhysical                      PartyTaxDocumentDeliveryPreference = "PHYSICAL"
	PartyTaxDocumentDeliveryPreferenceSuppress                      PartyTaxDocumentDeliveryPreference = "SUPPRESS"
)

func (e PartyTaxDocumentDeliveryPreference) ToPointer() *PartyTaxDocumentDeliveryPreference {
	return &e
}
func (e *PartyTaxDocumentDeliveryPreference) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DELIVERY_PREFERENCE_UNSPECIFIED":
		fallthrough
	case "DIGITAL":
		fallthrough
	case "PHYSICAL":
		fallthrough
	case "SUPPRESS":
		*e = PartyTaxDocumentDeliveryPreference(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyTaxDocumentDeliveryPreference: %v", v)
	}
}

// PartyTradeConfirmationDeliveryPreference - Delivery method instruction for trade confirmations for a given Party record; Can be `DIGITAL`, `PHYSICAL`, `SUPPRESS`; Defaults to `DIGITAL` on account creation but may be updated
type PartyTradeConfirmationDeliveryPreference string

const (
	PartyTradeConfirmationDeliveryPreferenceDeliveryPreferenceUnspecified PartyTradeConfirmationDeliveryPreference = "DELIVERY_PREFERENCE_UNSPECIFIED"
	PartyTradeConfirmationDeliveryPreferenceDigital                       PartyTradeConfirmationDeliveryPreference = "DIGITAL"
	PartyTradeConfirmationDeliveryPreferencePhysical                      PartyTradeConfirmationDeliveryPreference = "PHYSICAL"
	PartyTradeConfirmationDeliveryPreferenceSuppress                      PartyTradeConfirmationDeliveryPreference = "SUPPRESS"
)

func (e PartyTradeConfirmationDeliveryPreference) ToPointer() *PartyTradeConfirmationDeliveryPreference {
	return &e
}
func (e *PartyTradeConfirmationDeliveryPreference) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "DELIVERY_PREFERENCE_UNSPECIFIED":
		fallthrough
	case "DIGITAL":
		fallthrough
	case "PHYSICAL":
		fallthrough
	case "SUPPRESS":
		*e = PartyTradeConfirmationDeliveryPreference(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PartyTradeConfirmationDeliveryPreference: %v", v)
	}
}

// Party - A single record representing an owner or manager of an Account. Contains fully populated Party Identity object.
type Party struct {
	// An email address indicated for account communications.
	EmailAddress *string `json:"email_address,omitempty"`
	// Legal entity.
	LegalEntity *PartyLegalEntity `json:"legal_entity,omitempty"`
	// Legal natural person.
	LegalNaturalPerson *PartyLegalNaturalPerson `json:"legal_natural_person,omitempty"`
	// The object containing data for the purpose of delivery physical mailings to a party; Typically used for statements, account updates, tax documents, and other postal mailings; May also be used as an alternative identity verification address to personalAddress. Required fields within the `mailing_address` object include:
	//  - `administrative_area`
	//  - `region_code` - 2 character CLDR Code
	//  - `postal_code`
	//  - `locality`
	//  - `address_lines` - max 5 lines
	MailingAddress *PartyMailingAddress `json:"mailing_address,omitempty"`
	// The name field Format: {parent=account/*}/{name=party/*}
	Name *string `json:"name,omitempty"`
	// A system-generated unique identifier referencing a single owner or control person on an account; A Party contains account-specific information about a person whereas inside the Party is a reference to a reusable instance of a Person `legal_natural_person` or `legal_entity` which contains non-changing information about these persons; Used to access the record after creation
	PartyID *string `json:"party_id,omitempty"`
	// The phone number for a party. Lives on the party record in the context of the account and does not commute to other accounts held by/for the person.
	PhoneNumber *PartyPhoneNumber `json:"phone_number,omitempty"`
	// Delivery method instruction for prospectuses for a given Party record; Can be `DIGITAL`, `PHYSICAL`, `SUPPRESS`; Defaults to `DIGITAL` on account creation but may be updated
	ProspectusDeliveryPreference *PartyProspectusDeliveryPreference `json:"prospectus_delivery_preference,omitempty"`
	// Delivery method instruction for proxy voting for a given Party record; Can be `DIGITAL`, `PHYSICAL`, `SUPPRESS`; Defaults to `DIGITAL` on account creation but may be updated
	ProxyDeliveryPreference *PartyProxyDeliveryPreference `json:"proxy_delivery_preference,omitempty"`
	// Conveys how a person is related to account; Located on each account Party record; Examples are `PRIMARY_OWNER`, `JOINT_OWNER`, `EXECUTOR`, etc.
	RelationType *PartyRelationType `json:"relation_type,omitempty"`
	// Delivery method instruction for account statements for a given Party record; Can be `DIGITAL`, `PHYSICAL`, `SUPPRESS`; Defaults to `DIGITAL` on account creation but may be updated
	StatementDeliveryPreference *PartyStatementDeliveryPreference `json:"statement_delivery_preference,omitempty"`
	// Delivery method instruction for tax documents for a given Party record; Can be `DIGITAL`, `PHYSICAL`, `SUPPRESS`; Defaults to `DIGITAL` on account creation but may be updated; Per regulation, selected tax forms will be mailed by regulation regardless of this setting
	TaxDocumentDeliveryPreference *PartyTaxDocumentDeliveryPreference `json:"tax_document_delivery_preference,omitempty"`
	// Delivery method instruction for trade confirmations for a given Party record; Can be `DIGITAL`, `PHYSICAL`, `SUPPRESS`; Defaults to `DIGITAL` on account creation but may be updated
	TradeConfirmationDeliveryPreference *PartyTradeConfirmationDeliveryPreference `json:"trade_confirmation_delivery_preference,omitempty"`
}

func (o *Party) GetEmailAddress() *string {
	if o == nil {
		return nil
	}
	return o.EmailAddress
}

func (o *Party) GetLegalEntity() *PartyLegalEntity {
	if o == nil {
		return nil
	}
	return o.LegalEntity
}

func (o *Party) GetLegalNaturalPerson() *PartyLegalNaturalPerson {
	if o == nil {
		return nil
	}
	return o.LegalNaturalPerson
}

func (o *Party) GetMailingAddress() *PartyMailingAddress {
	if o == nil {
		return nil
	}
	return o.MailingAddress
}

func (o *Party) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Party) GetPartyID() *string {
	if o == nil {
		return nil
	}
	return o.PartyID
}

func (o *Party) GetPhoneNumber() *PartyPhoneNumber {
	if o == nil {
		return nil
	}
	return o.PhoneNumber
}

func (o *Party) GetProspectusDeliveryPreference() *PartyProspectusDeliveryPreference {
	if o == nil {
		return nil
	}
	return o.ProspectusDeliveryPreference
}

func (o *Party) GetProxyDeliveryPreference() *PartyProxyDeliveryPreference {
	if o == nil {
		return nil
	}
	return o.ProxyDeliveryPreference
}

func (o *Party) GetRelationType() *PartyRelationType {
	if o == nil {
		return nil
	}
	return o.RelationType
}

func (o *Party) GetStatementDeliveryPreference() *PartyStatementDeliveryPreference {
	if o == nil {
		return nil
	}
	return o.StatementDeliveryPreference
}

func (o *Party) GetTaxDocumentDeliveryPreference() *PartyTaxDocumentDeliveryPreference {
	if o == nil {
		return nil
	}
	return o.TaxDocumentDeliveryPreference
}

func (o *Party) GetTradeConfirmationDeliveryPreference() *PartyTradeConfirmationDeliveryPreference {
	if o == nil {
		return nil
	}
	return o.TradeConfirmationDeliveryPreference
}
