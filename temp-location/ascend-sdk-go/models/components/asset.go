// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
)

// CurrencyType - Indicates the type of currency
type CurrencyType string

const (
	CurrencyTypeCurrencyTypeUnspecified CurrencyType = "CURRENCY_TYPE_UNSPECIFIED"
	CurrencyTypeCurrency                CurrencyType = "CURRENCY"
	CurrencyTypeCurrencyEquivalent      CurrencyType = "CURRENCY_EQUIVALENT"
)

func (e CurrencyType) ToPointer() *CurrencyType {
	return &e
}
func (e *CurrencyType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CURRENCY_TYPE_UNSPECIFIED":
		fallthrough
	case "CURRENCY":
		fallthrough
	case "CURRENCY_EQUIVALENT":
		*e = CurrencyType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CurrencyType: %v", v)
	}
}

// Currency specific asset details
type Currency struct {
	// Indicates the type of currency
	CurrencyType *CurrencyType `json:"currency_type,omitempty"`
	// Indicates the name of asset for the underlying payment_currency when the `currency_type` is `CURRENCY_EQUIVALENT`
	PaymentCurrency *string `json:"payment_currency,omitempty"`
}

func (o *Currency) GetCurrencyType() *CurrencyType {
	if o == nil {
		return nil
	}
	return o.CurrencyType
}

func (o *Currency) GetPaymentCurrency() *string {
	if o == nil {
		return nil
	}
	return o.PaymentCurrency
}

// AssetEquityType - the code indicating the type of associated security.
type AssetEquityType string

const (
	AssetEquityTypeEquityTypeUnspecified      AssetEquityType = "EQUITY_TYPE_UNSPECIFIED"
	AssetEquityTypeCommonStock                AssetEquityType = "COMMON_STOCK"
	AssetEquityTypePreferredStock             AssetEquityType = "PREFERRED_STOCK"
	AssetEquityTypePreferredAdr               AssetEquityType = "PREFERRED_ADR"
	AssetEquityTypeSpecialStock               AssetEquityType = "SPECIAL_STOCK"
	AssetEquityTypeIndex                      AssetEquityType = "INDEX"
	AssetEquityTypeWarrant                    AssetEquityType = "WARRANT"
	AssetEquityTypeAdr                        AssetEquityType = "ADR"
	AssetEquityTypeRights                     AssetEquityType = "RIGHTS"
	AssetEquityTypeSharesOfBeneficialInterest AssetEquityType = "SHARES_OF_BENEFICIAL_INTEREST"
	AssetEquityTypeCertificates               AssetEquityType = "CERTIFICATES"
	AssetEquityTypeUnits                      AssetEquityType = "UNITS"
	AssetEquityTypeDebtIssue                  AssetEquityType = "DEBT_ISSUE"
	AssetEquityTypeEquityTypeOption           AssetEquityType = "EQUITY_TYPE_OPTION"
	AssetEquityTypeEtf                        AssetEquityType = "ETF"
)

func (e AssetEquityType) ToPointer() *AssetEquityType {
	return &e
}
func (e *AssetEquityType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "EQUITY_TYPE_UNSPECIFIED":
		fallthrough
	case "COMMON_STOCK":
		fallthrough
	case "PREFERRED_STOCK":
		fallthrough
	case "PREFERRED_ADR":
		fallthrough
	case "SPECIAL_STOCK":
		fallthrough
	case "INDEX":
		fallthrough
	case "WARRANT":
		fallthrough
	case "ADR":
		fallthrough
	case "RIGHTS":
		fallthrough
	case "SHARES_OF_BENEFICIAL_INTEREST":
		fallthrough
	case "CERTIFICATES":
		fallthrough
	case "UNITS":
		fallthrough
	case "DEBT_ISSUE":
		fallthrough
	case "EQUITY_TYPE_OPTION":
		fallthrough
	case "ETF":
		*e = AssetEquityType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AssetEquityType: %v", v)
	}
}

// Equity specific asset details
type Equity struct {
	// Indicates whether the symbol is eligible for fractional or notional execution for orders at Apex
	Fractionable *bool `json:"fractionable,omitempty"`
	// Indicates whether the symbol is designated as “Liquidate Only,” and, if so, the system rejects purchases
	Liquidate *bool `json:"liquidate,omitempty"`
	// the code indicating the type of associated security.
	Type *AssetEquityType `json:"type,omitempty"`
}

func (o *Equity) GetFractionable() *bool {
	if o == nil {
		return nil
	}
	return o.Fractionable
}

func (o *Equity) GetLiquidate() *bool {
	if o == nil {
		return nil
	}
	return o.Liquidate
}

func (o *Equity) GetType() *AssetEquityType {
	if o == nil {
		return nil
	}
	return o.Type
}

// CallType - The type of call
type CallType string

const (
	CallTypeCallTypeUnspecified CallType = "CALL_TYPE_UNSPECIFIED"
	CallTypeOrdinary            CallType = "ORDINARY"
	CallTypeSpecial             CallType = "SPECIAL"
	CallTypeMakeWhole           CallType = "MAKE_WHOLE"
	CallTypeRegulatory          CallType = "REGULATORY"
)

func (e CallType) ToPointer() *CallType {
	return &e
}
func (e *CallType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CALL_TYPE_UNSPECIFIED":
		fallthrough
	case "ORDINARY":
		fallthrough
	case "SPECIAL":
		fallthrough
	case "MAKE_WHOLE":
		fallthrough
	case "REGULATORY":
		*e = CallType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CallType: %v", v)
	}
}

// CouponFrequency - Frequency of payments
type CouponFrequency string

const (
	CouponFrequencyCouponFrequencyUnspecified CouponFrequency = "COUPON_FREQUENCY_UNSPECIFIED"
	CouponFrequencySemiAnnual                 CouponFrequency = "SEMI_ANNUAL"
	CouponFrequencyMonthly                    CouponFrequency = "MONTHLY"
	CouponFrequencyAtMaturity                 CouponFrequency = "AT_MATURITY"
	CouponFrequencyZero                       CouponFrequency = "ZERO"
	CouponFrequencyQuarterly                  CouponFrequency = "QUARTERLY"
	CouponFrequencyAnnual                     CouponFrequency = "ANNUAL"
)

func (e CouponFrequency) ToPointer() *CouponFrequency {
	return &e
}
func (e *CouponFrequency) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "COUPON_FREQUENCY_UNSPECIFIED":
		fallthrough
	case "SEMI_ANNUAL":
		fallthrough
	case "MONTHLY":
		fallthrough
	case "AT_MATURITY":
		fallthrough
	case "ZERO":
		fallthrough
	case "QUARTERLY":
		fallthrough
	case "ANNUAL":
		*e = CouponFrequency(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CouponFrequency: %v", v)
	}
}

// CouponRate - A measure of income an investor can expect to receive expressed as a percent
type CouponRate struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *CouponRate) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// CouponType - Type of coupon rate
type CouponType string

const (
	CouponTypeCouponTypeUnspecified CouponType = "COUPON_TYPE_UNSPECIFIED"
	CouponTypeCouponTypeFixed       CouponType = "COUPON_TYPE_FIXED"
	CouponTypeCouponTypeZero        CouponType = "COUPON_TYPE_ZERO"
)

func (e CouponType) ToPointer() *CouponType {
	return &e
}
func (e *CouponType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "COUPON_TYPE_UNSPECIFIED":
		fallthrough
	case "COUPON_TYPE_FIXED":
		fallthrough
	case "COUPON_TYPE_ZERO":
		*e = CouponType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CouponType: %v", v)
	}
}

// Duration - Weighted average time until a bond’s cash flows are received in years
type Duration struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *Duration) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// FirstCouponDate - date of first coupon
type FirstCouponDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *FirstCouponDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *FirstCouponDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *FirstCouponDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// FixedIncomeStatus - The status of the fixed income
type FixedIncomeStatus string

const (
	FixedIncomeStatusFixedIncomeStatusUnspecified FixedIncomeStatus = "FIXED_INCOME_STATUS_UNSPECIFIED"
	FixedIncomeStatusOutstanding                  FixedIncomeStatus = "OUTSTANDING"
	FixedIncomeStatusMatured                      FixedIncomeStatus = "MATURED"
	FixedIncomeStatusCalled                       FixedIncomeStatus = "CALLED"
	FixedIncomeStatusUnknown                      FixedIncomeStatus = "UNKNOWN"
	FixedIncomeStatusDefaulted                    FixedIncomeStatus = "DEFAULTED"
	FixedIncomeStatusConverted                    FixedIncomeStatus = "CONVERTED"
	FixedIncomeStatusTendered                     FixedIncomeStatus = "TENDERED"
	FixedIncomeStatusPreIssuance                  FixedIncomeStatus = "PRE_ISSUANCE"
	FixedIncomeStatusLiquidated                   FixedIncomeStatus = "LIQUIDATED"
	FixedIncomeStatusRepurchased                  FixedIncomeStatus = "REPURCHASED"
	FixedIncomeStatusRepaid                       FixedIncomeStatus = "REPAID"
	FixedIncomeStatusRestructured                 FixedIncomeStatus = "RESTRUCTURED"
	FixedIncomeStatusPut                          FixedIncomeStatus = "PUT"
	FixedIncomeStatusFunged                       FixedIncomeStatus = "FUNGED"
)

func (e FixedIncomeStatus) ToPointer() *FixedIncomeStatus {
	return &e
}
func (e *FixedIncomeStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FIXED_INCOME_STATUS_UNSPECIFIED":
		fallthrough
	case "OUTSTANDING":
		fallthrough
	case "MATURED":
		fallthrough
	case "CALLED":
		fallthrough
	case "UNKNOWN":
		fallthrough
	case "DEFAULTED":
		fallthrough
	case "CONVERTED":
		fallthrough
	case "TENDERED":
		fallthrough
	case "PRE_ISSUANCE":
		fallthrough
	case "LIQUIDATED":
		fallthrough
	case "REPURCHASED":
		fallthrough
	case "REPAID":
		fallthrough
	case "RESTRUCTURED":
		fallthrough
	case "PUT":
		fallthrough
	case "FUNGED":
		*e = FixedIncomeStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FixedIncomeStatus: %v", v)
	}
}

// FixedIncomeSubtype - The type of treasury
type FixedIncomeSubtype string

const (
	FixedIncomeSubtypeFixedIncomeSubtypeUnspecified FixedIncomeSubtype = "FIXED_INCOME_SUBTYPE_UNSPECIFIED"
	FixedIncomeSubtypeBond                          FixedIncomeSubtype = "BOND"
	FixedIncomeSubtypeStrips                        FixedIncomeSubtype = "STRIPS"
	FixedIncomeSubtypeBill                          FixedIncomeSubtype = "BILL"
	FixedIncomeSubtypeNote                          FixedIncomeSubtype = "NOTE"
	FixedIncomeSubtypeTips                          FixedIncomeSubtype = "TIPS"
)

func (e FixedIncomeSubtype) ToPointer() *FixedIncomeSubtype {
	return &e
}
func (e *FixedIncomeSubtype) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FIXED_INCOME_SUBTYPE_UNSPECIFIED":
		fallthrough
	case "BOND":
		fallthrough
	case "STRIPS":
		fallthrough
	case "BILL":
		fallthrough
	case "NOTE":
		fallthrough
	case "TIPS":
		*e = FixedIncomeSubtype(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FixedIncomeSubtype: %v", v)
	}
}

// FixedIncomeType - Type of fixed income security
type FixedIncomeType string

const (
	FixedIncomeTypeFixedIncomeTypeUnspecified FixedIncomeType = "FIXED_INCOME_TYPE_UNSPECIFIED"
	FixedIncomeTypeMunicipal                  FixedIncomeType = "MUNICIPAL"
	FixedIncomeTypeCorporate                  FixedIncomeType = "CORPORATE"
	FixedIncomeTypeCd                         FixedIncomeType = "CD"
	FixedIncomeTypeAgency                     FixedIncomeType = "AGENCY"
	FixedIncomeTypeTreasury                   FixedIncomeType = "TREASURY"
	FixedIncomeTypeGovernment                 FixedIncomeType = "GOVERNMENT"
	FixedIncomeTypeForeignGovernment          FixedIncomeType = "FOREIGN_GOVERNMENT"
)

func (e FixedIncomeType) ToPointer() *FixedIncomeType {
	return &e
}
func (e *FixedIncomeType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "FIXED_INCOME_TYPE_UNSPECIFIED":
		fallthrough
	case "MUNICIPAL":
		fallthrough
	case "CORPORATE":
		fallthrough
	case "CD":
		fallthrough
	case "AGENCY":
		fallthrough
	case "TREASURY":
		fallthrough
	case "GOVERNMENT":
		fallthrough
	case "FOREIGN_GOVERNMENT":
		*e = FixedIncomeType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FixedIncomeType: %v", v)
	}
}

// AssetIssueDate - The date of issuance
type AssetIssueDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *AssetIssueDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *AssetIssueDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *AssetIssueDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// IssueSize - Total size of the bond issue in the issuing currency
type IssueSize struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *IssueSize) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// LastCouponDate - date of last coupon
type LastCouponDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *LastCouponDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *LastCouponDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *LastCouponDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// MaturityDate - The date the fixed income security matures
type MaturityDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *MaturityDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *MaturityDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *MaturityDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// NextCallDate - The date of the next call
type NextCallDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *NextCallDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *NextCallDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *NextCallDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// NextCouponDate - Date of next coupon payment
type NextCouponDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *NextCouponDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *NextCouponDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *NextCouponDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// ParValue - The amount the issuer agrees to pay the investor upon maturity
type ParValue struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *ParValue) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// PriceAtIssuance - The price at which fixed income security was issued as a percentage of par value in %
type PriceAtIssuance struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *PriceAtIssuance) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// SpRating - Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field.
type SpRating string

const (
	SpRatingSpRatingUnspecified SpRating = "SP_RATING_UNSPECIFIED"
	SpRatingAaa                 SpRating = "AAA"
	SpRatingAaPlus              SpRating = "AA_PLUS"
	SpRatingAa                  SpRating = "AA"
	SpRatingAaMinus             SpRating = "AA_MINUS"
	SpRatingAPlus               SpRating = "A_PLUS"
	SpRatingA                   SpRating = "A"
	SpRatingAMinus              SpRating = "A_MINUS"
	SpRatingBbbPlus             SpRating = "BBB_PLUS"
	SpRatingBbb                 SpRating = "BBB"
	SpRatingBbbMinus            SpRating = "BBB_MINUS"
	SpRatingBbPlus              SpRating = "BB_PLUS"
	SpRatingBb                  SpRating = "BB"
	SpRatingBbMinus             SpRating = "BB_MINUS"
	SpRatingBPlus               SpRating = "B_PLUS"
	SpRatingB                   SpRating = "B"
	SpRatingBMinus              SpRating = "B_MINUS"
	SpRatingCccPlus             SpRating = "CCC_PLUS"
	SpRatingCcc                 SpRating = "CCC"
	SpRatingCccMinus            SpRating = "CCC_MINUS"
	SpRatingCc                  SpRating = "CC"
	SpRatingC                   SpRating = "C"
	SpRatingD                   SpRating = "D"
	SpRatingNr                  SpRating = "NR"
	SpRatingSp1Plus             SpRating = "SP_1_PLUS"
	SpRatingSp1                 SpRating = "SP_1"
	SpRatingSp1Minus            SpRating = "SP_1_MINUS"
	SpRatingA1Plus              SpRating = "A_1_PLUS"
	SpRatingA1                  SpRating = "A_1"
	SpRatingA1Minus             SpRating = "A_1_MINUS"
)

func (e SpRating) ToPointer() *SpRating {
	return &e
}
func (e *SpRating) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SP_RATING_UNSPECIFIED":
		fallthrough
	case "AAA":
		fallthrough
	case "AA_PLUS":
		fallthrough
	case "AA":
		fallthrough
	case "AA_MINUS":
		fallthrough
	case "A_PLUS":
		fallthrough
	case "A":
		fallthrough
	case "A_MINUS":
		fallthrough
	case "BBB_PLUS":
		fallthrough
	case "BBB":
		fallthrough
	case "BBB_MINUS":
		fallthrough
	case "BB_PLUS":
		fallthrough
	case "BB":
		fallthrough
	case "BB_MINUS":
		fallthrough
	case "B_PLUS":
		fallthrough
	case "B":
		fallthrough
	case "B_MINUS":
		fallthrough
	case "CCC_PLUS":
		fallthrough
	case "CCC":
		fallthrough
	case "CCC_MINUS":
		fallthrough
	case "CC":
		fallthrough
	case "C":
		fallthrough
	case "D":
		fallthrough
	case "NR":
		fallthrough
	case "SP_1_PLUS":
		fallthrough
	case "SP_1":
		fallthrough
	case "SP_1_MINUS":
		fallthrough
	case "A_1_PLUS":
		fallthrough
	case "A_1":
		fallthrough
	case "A_1_MINUS":
		*e = SpRating(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SpRating: %v", v)
	}
}

// SpRatingDate - The date of Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field.
type SpRatingDate struct {
	// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
	Day *int `json:"day,omitempty"`
	// Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
	Month *int `json:"month,omitempty"`
	// Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
	Year *int `json:"year,omitempty"`
}

func (o *SpRatingDate) GetDay() *int {
	if o == nil {
		return nil
	}
	return o.Day
}

func (o *SpRatingDate) GetMonth() *int {
	if o == nil {
		return nil
	}
	return o.Month
}

func (o *SpRatingDate) GetYear() *int {
	if o == nil {
		return nil
	}
	return o.Year
}

// FixedIncome specific asset details
type FixedIncome struct {
	// The type of call
	CallType *CallType `json:"call_type,omitempty"`
	// Boolean that indicates whether an issuer may redeem the security before its maturity date
	Callable *bool `json:"callable,omitempty"`
	// Boolean that indicates whether an investor may convert to a number of shares of issuer common stock
	Convertible *bool `json:"convertible,omitempty"`
	// Frequency of payments
	CouponFrequency *CouponFrequency `json:"coupon_frequency,omitempty"`
	// A measure of income an investor can expect to receive expressed as a percent
	CouponRate *CouponRate `json:"coupon_rate,omitempty"`
	// Type of coupon rate
	CouponType *CouponType `json:"coupon_type,omitempty"`
	// Weighted average time until a bond’s cash flows are received in years
	Duration *Duration `json:"duration,omitempty"`
	// date of first coupon
	FirstCouponDate *FirstCouponDate `json:"first_coupon_date,omitempty"`
	// The status of the fixed income
	FixedIncomeStatus *FixedIncomeStatus `json:"fixed_income_status,omitempty"`
	// The type of treasury
	FixedIncomeSubtype *FixedIncomeSubtype `json:"fixed_income_subtype,omitempty"`
	// Type of fixed income security
	FixedIncomeType *FixedIncomeType `json:"fixed_income_type,omitempty"`
	// Boolean that indicates whether a security is backed by an insurance policy
	Insured *bool `json:"insured,omitempty"`
	// The date of issuance
	IssueDate *AssetIssueDate `json:"issue_date,omitempty"`
	// Total size of the bond issue in the issuing currency
	IssueSize *IssueSize `json:"issue_size,omitempty"`
	// Name of the bond issuer
	Issuer *string `json:"issuer,omitempty"`
	// date of last coupon
	LastCouponDate *LastCouponDate `json:"last_coupon_date,omitempty"`
	// The date the fixed income security matures
	MaturityDate *MaturityDate `json:"maturity_date,omitempty"`
	// The date of the next call
	NextCallDate *NextCallDate `json:"next_call_date,omitempty"`
	// Date of next coupon payment
	NextCouponDate *NextCouponDate `json:"next_coupon_date,omitempty"`
	// The amount the issuer agrees to pay the investor upon maturity
	ParValue *ParValue `json:"par_value,omitempty"`
	// Indicates whether the bond is perpetual
	Perpetual *bool `json:"perpetual,omitempty"`
	// The price at which fixed income security was issued as a percentage of par value in %
	PriceAtIssuance *PriceAtIssuance `json:"price_at_issuance,omitempty"`
	// Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field.
	SpRating *SpRating `json:"sp_rating,omitempty"`
	// The date of Standard & Poor's (S&P) rating of the creditworthiness of borrowers. Correspondents must be configured to view this field.
	SpRatingDate *SpRatingDate `json:"sp_rating_date,omitempty"`
	// The symbol for the issuer’s equity
	UnderlyingSymbol *string `json:"underlying_symbol,omitempty"`
}

func (o *FixedIncome) GetCallType() *CallType {
	if o == nil {
		return nil
	}
	return o.CallType
}

func (o *FixedIncome) GetCallable() *bool {
	if o == nil {
		return nil
	}
	return o.Callable
}

func (o *FixedIncome) GetConvertible() *bool {
	if o == nil {
		return nil
	}
	return o.Convertible
}

func (o *FixedIncome) GetCouponFrequency() *CouponFrequency {
	if o == nil {
		return nil
	}
	return o.CouponFrequency
}

func (o *FixedIncome) GetCouponRate() *CouponRate {
	if o == nil {
		return nil
	}
	return o.CouponRate
}

func (o *FixedIncome) GetCouponType() *CouponType {
	if o == nil {
		return nil
	}
	return o.CouponType
}

func (o *FixedIncome) GetDuration() *Duration {
	if o == nil {
		return nil
	}
	return o.Duration
}

func (o *FixedIncome) GetFirstCouponDate() *FirstCouponDate {
	if o == nil {
		return nil
	}
	return o.FirstCouponDate
}

func (o *FixedIncome) GetFixedIncomeStatus() *FixedIncomeStatus {
	if o == nil {
		return nil
	}
	return o.FixedIncomeStatus
}

func (o *FixedIncome) GetFixedIncomeSubtype() *FixedIncomeSubtype {
	if o == nil {
		return nil
	}
	return o.FixedIncomeSubtype
}

func (o *FixedIncome) GetFixedIncomeType() *FixedIncomeType {
	if o == nil {
		return nil
	}
	return o.FixedIncomeType
}

func (o *FixedIncome) GetInsured() *bool {
	if o == nil {
		return nil
	}
	return o.Insured
}

func (o *FixedIncome) GetIssueDate() *AssetIssueDate {
	if o == nil {
		return nil
	}
	return o.IssueDate
}

func (o *FixedIncome) GetIssueSize() *IssueSize {
	if o == nil {
		return nil
	}
	return o.IssueSize
}

func (o *FixedIncome) GetIssuer() *string {
	if o == nil {
		return nil
	}
	return o.Issuer
}

func (o *FixedIncome) GetLastCouponDate() *LastCouponDate {
	if o == nil {
		return nil
	}
	return o.LastCouponDate
}

func (o *FixedIncome) GetMaturityDate() *MaturityDate {
	if o == nil {
		return nil
	}
	return o.MaturityDate
}

func (o *FixedIncome) GetNextCallDate() *NextCallDate {
	if o == nil {
		return nil
	}
	return o.NextCallDate
}

func (o *FixedIncome) GetNextCouponDate() *NextCouponDate {
	if o == nil {
		return nil
	}
	return o.NextCouponDate
}

func (o *FixedIncome) GetParValue() *ParValue {
	if o == nil {
		return nil
	}
	return o.ParValue
}

func (o *FixedIncome) GetPerpetual() *bool {
	if o == nil {
		return nil
	}
	return o.Perpetual
}

func (o *FixedIncome) GetPriceAtIssuance() *PriceAtIssuance {
	if o == nil {
		return nil
	}
	return o.PriceAtIssuance
}

func (o *FixedIncome) GetSpRating() *SpRating {
	if o == nil {
		return nil
	}
	return o.SpRating
}

func (o *FixedIncome) GetSpRatingDate() *SpRatingDate {
	if o == nil {
		return nil
	}
	return o.SpRatingDate
}

func (o *FixedIncome) GetUnderlyingSymbol() *string {
	if o == nil {
		return nil
	}
	return o.UnderlyingSymbol
}

// LargeOrderNotificationAmount - The threshold at which Apex would need to notify the fund family of an incoming large order.
type LargeOrderNotificationAmount struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *LargeOrderNotificationAmount) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// MutualFundType - Identifies type of mutual fund
type MutualFundType string

const (
	MutualFundTypeMutualFundTypeUnspecified MutualFundType = "MUTUAL_FUND_TYPE_UNSPECIFIED"
	MutualFundTypeBond                      MutualFundType = "BOND"
	MutualFundTypeMoneyMarketFund           MutualFundType = "MONEY_MARKET_FUND"
	MutualFundTypeEquity                    MutualFundType = "EQUITY"
)

func (e MutualFundType) ToPointer() *MutualFundType {
	return &e
}
func (e *MutualFundType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "MUTUAL_FUND_TYPE_UNSPECIFIED":
		fallthrough
	case "BOND":
		fallthrough
	case "MONEY_MARKET_FUND":
		fallthrough
	case "EQUITY":
		*e = MutualFundType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for MutualFundType: %v", v)
	}
}

// MutualFund specific asset details
type MutualFund struct {
	// Name of the fund company
	FundFamily *string `json:"fund_family,omitempty"`
	// The threshold at which Apex would need to notify the fund family of an incoming large order.
	LargeOrderNotificationAmount *LargeOrderNotificationAmount `json:"large_order_notification_amount,omitempty"`
	// Identifies type of mutual fund
	MutualFundType *MutualFundType `json:"mutual_fund_type,omitempty"`
	// Indicates the type and number of fees charged for the shares in a fund
	ShareClass *string `json:"share_class,omitempty"`
}

func (o *MutualFund) GetFundFamily() *string {
	if o == nil {
		return nil
	}
	return o.FundFamily
}

func (o *MutualFund) GetLargeOrderNotificationAmount() *LargeOrderNotificationAmount {
	if o == nil {
		return nil
	}
	return o.LargeOrderNotificationAmount
}

func (o *MutualFund) GetMutualFundType() *MutualFundType {
	if o == nil {
		return nil
	}
	return o.MutualFundType
}

func (o *MutualFund) GetShareClass() *string {
	if o == nil {
		return nil
	}
	return o.ShareClass
}

// AssetType1 - The type or category of the asset
type AssetType1 string

const (
	AssetType1TypeUnspecified AssetType1 = "TYPE_UNSPECIFIED"
	AssetType1Equity          AssetType1 = "EQUITY"
	AssetType1Option          AssetType1 = "OPTION"
	AssetType1Currency        AssetType1 = "CURRENCY"
	AssetType1Digital         AssetType1 = "DIGITAL"
	AssetType1FdicSynthetic   AssetType1 = "FDIC_SYNTHETIC"
	AssetType1FixedIncome     AssetType1 = "FIXED_INCOME"
	AssetType1MutualFund      AssetType1 = "MUTUAL_FUND"
)

func (e AssetType1) ToPointer() *AssetType1 {
	return &e
}
func (e *AssetType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TYPE_UNSPECIFIED":
		fallthrough
	case "EQUITY":
		fallthrough
	case "OPTION":
		fallthrough
	case "CURRENCY":
		fallthrough
	case "DIGITAL":
		fallthrough
	case "FDIC_SYNTHETIC":
		fallthrough
	case "FIXED_INCOME":
		fallthrough
	case "MUTUAL_FUND":
		*e = AssetType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AssetType1: %v", v)
	}
}

// Asset is the Apex representation of a security
type Asset struct {
	// Apex internal identifier assigned upon entry to every security.
	AssetID *string `json:"asset_id,omitempty"`
	// Currency specific asset details
	Currency *Currency `json:"currency,omitempty"`
	// Identifier assigned to a security by the CUSIP Service Bureau of Standard & Poor’s Corporation
	Cusip *string `json:"cusip,omitempty"`
	// Name of the issuer of a security and additional descriptive information about the particular issue
	Description *string `json:"description,omitempty"`
	// Equity specific asset details
	Equity *Equity `json:"equity,omitempty"`
	// FixedIncome specific asset details
	FixedIncome *FixedIncome `json:"fixed_income,omitempty"`
	// isin is the International Securities Identification Number
	Isin *string `json:"isin,omitempty"`
	// A string attribute denoting the country of issuance or where the asset is trading.
	IssuingRegionCode *string `json:"issuing_region_code,omitempty"`
	// MutualFund specific asset details
	MutualFund *MutualFund `json:"mutual_fund,omitempty"`
	// assets/{asset_id}
	Name *string `json:"name,omitempty"`
	// ISO code identifying the region in which the entity was incorporated
	OriginatingRegionCode *string `json:"originating_region_code,omitempty"`
	// An arrangement of characters—usually letters and or numbers — usually representing securities on an exchange
	Symbol *string `json:"symbol,omitempty"`
	// The type or category of the asset
	Type *AssetType1 `json:"type,omitempty"`
	// A usable asset is active in its respective market and can be traded and/or transferred
	Usable *bool `json:"usable,omitempty"`
}

func (o *Asset) GetAssetID() *string {
	if o == nil {
		return nil
	}
	return o.AssetID
}

func (o *Asset) GetCurrency() *Currency {
	if o == nil {
		return nil
	}
	return o.Currency
}

func (o *Asset) GetCusip() *string {
	if o == nil {
		return nil
	}
	return o.Cusip
}

func (o *Asset) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *Asset) GetEquity() *Equity {
	if o == nil {
		return nil
	}
	return o.Equity
}

func (o *Asset) GetFixedIncome() *FixedIncome {
	if o == nil {
		return nil
	}
	return o.FixedIncome
}

func (o *Asset) GetIsin() *string {
	if o == nil {
		return nil
	}
	return o.Isin
}

func (o *Asset) GetIssuingRegionCode() *string {
	if o == nil {
		return nil
	}
	return o.IssuingRegionCode
}

func (o *Asset) GetMutualFund() *MutualFund {
	if o == nil {
		return nil
	}
	return o.MutualFund
}

func (o *Asset) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Asset) GetOriginatingRegionCode() *string {
	if o == nil {
		return nil
	}
	return o.OriginatingRegionCode
}

func (o *Asset) GetSymbol() *string {
	if o == nil {
		return nil
	}
	return o.Symbol
}

func (o *Asset) GetType() *AssetType1 {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *Asset) GetUsable() *bool {
	if o == nil {
		return nil
	}
	return o.Usable
}
