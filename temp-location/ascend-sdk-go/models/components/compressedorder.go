// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/afs-public/ascend-sdk-go/internal/utils"
)

// CompressedOrderAssetType - The type of the asset in this order
type CompressedOrderAssetType string

const (
	CompressedOrderAssetTypeAssetTypeUnspecified CompressedOrderAssetType = "ASSET_TYPE_UNSPECIFIED"
	CompressedOrderAssetTypeEquity               CompressedOrderAssetType = "EQUITY"
)

func (e CompressedOrderAssetType) ToPointer() *CompressedOrderAssetType {
	return &e
}
func (e *CompressedOrderAssetType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ASSET_TYPE_UNSPECIFIED":
		fallthrough
	case "EQUITY":
		*e = CompressedOrderAssetType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CompressedOrderAssetType: %v", v)
	}
}

// CompressedOrderCumulativeNotionalValue - The product of order quantity & price, summed across all fills, reported in the currency specified in the order. (This will be rounded to 2 decimal places for USD currencies). Will be absent if an order has no fill information.
type CompressedOrderCumulativeNotionalValue struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *CompressedOrderCumulativeNotionalValue) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// CompressedOrderFilledQuantity - The summed quantity value across all fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no fill information.
type CompressedOrderFilledQuantity struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *CompressedOrderFilledQuantity) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// CompressedOrderIdentifierType - The identifier type of the asset being ordered. For Equities: only SYMBOL is supported
type CompressedOrderIdentifierType string

const (
	CompressedOrderIdentifierTypeSymbol CompressedOrderIdentifierType = "SYMBOL"
	CompressedOrderIdentifierTypeCusip  CompressedOrderIdentifierType = "CUSIP"
	CompressedOrderIdentifierTypeIsin   CompressedOrderIdentifierType = "ISIN"
)

func (e CompressedOrderIdentifierType) ToPointer() *CompressedOrderIdentifierType {
	return &e
}
func (e *CompressedOrderIdentifierType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SYMBOL":
		fallthrough
	case "CUSIP":
		fallthrough
	case "ISIN":
		*e = CompressedOrderIdentifierType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CompressedOrderIdentifierType: %v", v)
	}
}

// CompressedOrderOrderRejectedReason - When an order has the REJECTED status, this will be populated with a system code describing the rejection.
type CompressedOrderOrderRejectedReason string

const (
	CompressedOrderOrderRejectedReasonOrderRejectReasonUnspecified                      CompressedOrderOrderRejectedReason = "ORDER_REJECT_REASON_UNSPECIFIED"
	CompressedOrderOrderRejectedReasonBrokerOption                                      CompressedOrderOrderRejectedReason = "BROKER_OPTION"
	CompressedOrderOrderRejectedReasonUnknownSecurity                                   CompressedOrderOrderRejectedReason = "UNKNOWN_SECURITY"
	CompressedOrderOrderRejectedReasonExchangeClosed                                    CompressedOrderOrderRejectedReason = "EXCHANGE_CLOSED"
	CompressedOrderOrderRejectedReasonTooLateToEnter                                    CompressedOrderOrderRejectedReason = "TOO_LATE_TO_ENTER"
	CompressedOrderOrderRejectedReasonUnknownOrder                                      CompressedOrderOrderRejectedReason = "UNKNOWN_ORDER"
	CompressedOrderOrderRejectedReasonDuplicateOrder                                    CompressedOrderOrderRejectedReason = "DUPLICATE_ORDER"
	CompressedOrderOrderRejectedReasonStaleOrder                                        CompressedOrderOrderRejectedReason = "STALE_ORDER"
	CompressedOrderOrderRejectedReasonBelowNotionalMinimum                              CompressedOrderOrderRejectedReason = "BELOW_NOTIONAL_MINIMUM"
	CompressedOrderOrderRejectedReasonAccountNotEntitled                                CompressedOrderOrderRejectedReason = "ACCOUNT_NOT_ENTITLED"
	CompressedOrderOrderRejectedReasonSystemError                                       CompressedOrderOrderRejectedReason = "SYSTEM_ERROR"
	CompressedOrderOrderRejectedReasonBlockingCorporateAction                           CompressedOrderOrderRejectedReason = "BLOCKING_CORPORATE_ACTION"
	CompressedOrderOrderRejectedReasonUnavailablePriceQuote                             CompressedOrderOrderRejectedReason = "UNAVAILABLE_PRICE_QUOTE"
	CompressedOrderOrderRejectedReasonExecutionMisconfiguredClient                      CompressedOrderOrderRejectedReason = "EXECUTION_MISCONFIGURED_CLIENT"
	CompressedOrderOrderRejectedReasonFractionalQuantityNotAllowedForSecurity           CompressedOrderOrderRejectedReason = "FRACTIONAL_QUANTITY_NOT_ALLOWED_FOR_SECURITY"
	CompressedOrderOrderRejectedReasonOnlyFractionalSellOrWholeOrdersAllowedForSecurity CompressedOrderOrderRejectedReason = "ONLY_FRACTIONAL_SELL_OR_WHOLE_ORDERS_ALLOWED_FOR_SECURITY"
	CompressedOrderOrderRejectedReasonSymbolNotTradeable                                CompressedOrderOrderRejectedReason = "SYMBOL_NOT_TRADEABLE"
	CompressedOrderOrderRejectedReasonAboveNotionalMaximum                              CompressedOrderOrderRejectedReason = "ABOVE_NOTIONAL_MAXIMUM"
	CompressedOrderOrderRejectedReasonAboveShareMaximum                                 CompressedOrderOrderRejectedReason = "ABOVE_SHARE_MAXIMUM"
	CompressedOrderOrderRejectedReasonMaxSellQuantityRequired                           CompressedOrderOrderRejectedReason = "MAX_SELL_QUANTITY_REQUIRED"
	CompressedOrderOrderRejectedReasonMaxSellQuantityProhibited                         CompressedOrderOrderRejectedReason = "MAX_SELL_QUANTITY_PROHIBITED"
	CompressedOrderOrderRejectedReasonStockTradesDisabled                               CompressedOrderOrderRejectedReason = "STOCK_TRADES_DISABLED"
	CompressedOrderOrderRejectedReasonAssetNotSetUpToTrade                              CompressedOrderOrderRejectedReason = "ASSET_NOT_SET_UP_TO_TRADE"
	CompressedOrderOrderRejectedReasonAnotherBasketOrderForAccountHasFailedRiskChecks   CompressedOrderOrderRejectedReason = "ANOTHER_BASKET_ORDER_FOR_ACCOUNT_HAS_FAILED_RISK_CHECKS"
)

func (e CompressedOrderOrderRejectedReason) ToPointer() *CompressedOrderOrderRejectedReason {
	return &e
}
func (e *CompressedOrderOrderRejectedReason) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ORDER_REJECT_REASON_UNSPECIFIED":
		fallthrough
	case "BROKER_OPTION":
		fallthrough
	case "UNKNOWN_SECURITY":
		fallthrough
	case "EXCHANGE_CLOSED":
		fallthrough
	case "TOO_LATE_TO_ENTER":
		fallthrough
	case "UNKNOWN_ORDER":
		fallthrough
	case "DUPLICATE_ORDER":
		fallthrough
	case "STALE_ORDER":
		fallthrough
	case "BELOW_NOTIONAL_MINIMUM":
		fallthrough
	case "ACCOUNT_NOT_ENTITLED":
		fallthrough
	case "SYSTEM_ERROR":
		fallthrough
	case "BLOCKING_CORPORATE_ACTION":
		fallthrough
	case "UNAVAILABLE_PRICE_QUOTE":
		fallthrough
	case "EXECUTION_MISCONFIGURED_CLIENT":
		fallthrough
	case "FRACTIONAL_QUANTITY_NOT_ALLOWED_FOR_SECURITY":
		fallthrough
	case "ONLY_FRACTIONAL_SELL_OR_WHOLE_ORDERS_ALLOWED_FOR_SECURITY":
		fallthrough
	case "SYMBOL_NOT_TRADEABLE":
		fallthrough
	case "ABOVE_NOTIONAL_MAXIMUM":
		fallthrough
	case "ABOVE_SHARE_MAXIMUM":
		fallthrough
	case "MAX_SELL_QUANTITY_REQUIRED":
		fallthrough
	case "MAX_SELL_QUANTITY_PROHIBITED":
		fallthrough
	case "STOCK_TRADES_DISABLED":
		fallthrough
	case "ASSET_NOT_SET_UP_TO_TRADE":
		fallthrough
	case "ANOTHER_BASKET_ORDER_FOR_ACCOUNT_HAS_FAILED_RISK_CHECKS":
		*e = CompressedOrderOrderRejectedReason(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CompressedOrderOrderRejectedReason: %v", v)
	}
}

// CompressedOrderOrderStatus - The processing status of the order
type CompressedOrderOrderStatus string

const (
	CompressedOrderOrderStatusOrderStatusUnspecified CompressedOrderOrderStatus = "ORDER_STATUS_UNSPECIFIED"
	CompressedOrderOrderStatusPendingNew             CompressedOrderOrderStatus = "PENDING_NEW"
	CompressedOrderOrderStatusNew                    CompressedOrderOrderStatus = "NEW"
	CompressedOrderOrderStatusPartiallyFilled        CompressedOrderOrderStatus = "PARTIALLY_FILLED"
	CompressedOrderOrderStatusFilled                 CompressedOrderOrderStatus = "FILLED"
	CompressedOrderOrderStatusRejected               CompressedOrderOrderStatus = "REJECTED"
)

func (e CompressedOrderOrderStatus) ToPointer() *CompressedOrderOrderStatus {
	return &e
}
func (e *CompressedOrderOrderStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ORDER_STATUS_UNSPECIFIED":
		fallthrough
	case "PENDING_NEW":
		fallthrough
	case "NEW":
		fallthrough
	case "PARTIALLY_FILLED":
		fallthrough
	case "FILLED":
		fallthrough
	case "REJECTED":
		*e = CompressedOrderOrderStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CompressedOrderOrderStatus: %v", v)
	}
}

// CompressedOrderOrderType - The execution type of this order. Only MARKET is supported.
type CompressedOrderOrderType string

const (
	CompressedOrderOrderTypeOrderTypeUnspecified CompressedOrderOrderType = "ORDER_TYPE_UNSPECIFIED"
	CompressedOrderOrderTypeMarket               CompressedOrderOrderType = "MARKET"
)

func (e CompressedOrderOrderType) ToPointer() *CompressedOrderOrderType {
	return &e
}
func (e *CompressedOrderOrderType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ORDER_TYPE_UNSPECIFIED":
		fallthrough
	case "MARKET":
		*e = CompressedOrderOrderType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CompressedOrderOrderType: %v", v)
	}
}

// CompressedOrderQuantity - Numeric quantity of the order. For Equities: Represents the number of shares, must be greater than zero and may not exceed 5 decimal places. Either a quantity or notional_value MUST be specified (but not both).
type CompressedOrderQuantity struct {
	// The decimal value, as a string; Refer to [Google’s Decimal type protocol buffer](https://github.com/googleapis/googleapis/blob/40203ca1880849480bbff7b8715491060bbccdf1/google/type/decimal.proto#L33) for details
	Value *string `json:"value,omitempty"`
}

func (o *CompressedOrderQuantity) GetValue() *string {
	if o == nil {
		return nil
	}
	return o.Value
}

// CompressedOrderSide - The side of this order.
type CompressedOrderSide string

const (
	CompressedOrderSideSideUnspecified CompressedOrderSide = "SIDE_UNSPECIFIED"
	CompressedOrderSideBuy             CompressedOrderSide = "BUY"
	CompressedOrderSideSell            CompressedOrderSide = "SELL"
)

func (e CompressedOrderSide) ToPointer() *CompressedOrderSide {
	return &e
}
func (e *CompressedOrderSide) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SIDE_UNSPECIFIED":
		fallthrough
	case "BUY":
		fallthrough
	case "SELL":
		*e = CompressedOrderSide(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CompressedOrderSide: %v", v)
	}
}

// CompressedOrderTimeInForce - Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
type CompressedOrderTimeInForce string

const (
	CompressedOrderTimeInForceTimeInForceUnspecified CompressedOrderTimeInForce = "TIME_IN_FORCE_UNSPECIFIED"
	CompressedOrderTimeInForceDay                    CompressedOrderTimeInForce = "DAY"
)

func (e CompressedOrderTimeInForce) ToPointer() *CompressedOrderTimeInForce {
	return &e
}
func (e *CompressedOrderTimeInForce) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TIME_IN_FORCE_UNSPECIFIED":
		fallthrough
	case "DAY":
		*e = CompressedOrderTimeInForce(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CompressedOrderTimeInForce: %v", v)
	}
}

// CompressedOrder - The message describing an orders that have been compressed into a single order
type CompressedOrder struct {
	// Apex Asset ID for this asset. This will not be returned in the initial CreateOrder response and will be available after an order completes validation. If the provided identifier does not match any Apex asset available for trading, an OrderRejectReason of "UNKNOWN_SECURITY" will be returned and the asset_id will not be set.
	AssetID *string `json:"asset_id,omitempty"`
	// The type of the asset in this order
	AssetType *CompressedOrderAssetType `json:"asset_type,omitempty"`
	// The identifier of the account transacting this order
	AveragePriceAccountID *string `json:"average_price_account_id,omitempty"`
	// The average prices, as weighted averages, across all executions in this order. Will be absent if an order has no executions.
	//
	//  When asset_type = EQUITY, there will be at most one value present, with a type of PRICE_PER_UNIT. This will have up to 4 decimal places for USD amounts less than $1, and a maximum of two for larger USD amounts.
	AveragePrices []ExecutedPrice `json:"average_prices,omitempty"`
	// System generated unique id for the compressed order.
	CompressedOrderID *string `json:"compressed_order_id,omitempty"`
	// Time of the order creation
	CreateTime *time.Time `json:"create_time,omitempty"`
	// The product of order quantity & price, summed across all fills, reported in the currency specified in the order. (This will be rounded to 2 decimal places for USD currencies). Will be absent if an order has no fill information.
	CumulativeNotionalValue *CompressedOrderCumulativeNotionalValue `json:"cumulative_notional_value,omitempty"`
	// The execution-level details that compose this order
	Executions []Executions `json:"executions,omitempty"`
	// The summed quantity value across all fills in this order, up to a maximum of 5 decimal places. Will be absent if an order has no fill information.
	FilledQuantity *CompressedOrderFilledQuantity `json:"filled_quantity,omitempty"`
	// Identifier of the asset (of the type specified in `identifier_type`).
	Identifier *string `json:"identifier,omitempty"`
	// The identifier type of the asset being ordered. For Equities: only SYMBOL is supported
	IdentifierType *CompressedOrderIdentifierType `json:"identifier_type,omitempty"`
	// Time of the last order update
	LastUpdateTime *time.Time `json:"last_update_time,omitempty"`
	// System generated name of the order.
	Name *string `json:"name,omitempty"`
	// When an order has the REJECTED status, this will be populated with a system code describing the rejection.
	OrderRejectedReason *CompressedOrderOrderRejectedReason `json:"order_rejected_reason,omitempty"`
	// The processing status of the order
	OrderStatus *CompressedOrderOrderStatus `json:"order_status,omitempty"`
	// The execution type of this order. Only MARKET is supported.
	OrderType *CompressedOrderOrderType `json:"order_type,omitempty"`
	// Numeric quantity of the order. For Equities: Represents the number of shares, must be greater than zero and may not exceed 5 decimal places. Either a quantity or notional_value MUST be specified (but not both).
	Quantity *CompressedOrderQuantity `json:"quantity,omitempty"`
	// The side of this order.
	Side *CompressedOrderSide `json:"side,omitempty"`
	// Must be the value "DAY". Regulatory requirements dictate that the system capture the intended time_in_force, which is why this a mandatory field.
	TimeInForce *CompressedOrderTimeInForce `json:"time_in_force,omitempty"`
}

func (c CompressedOrder) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CompressedOrder) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *CompressedOrder) GetAssetID() *string {
	if o == nil {
		return nil
	}
	return o.AssetID
}

func (o *CompressedOrder) GetAssetType() *CompressedOrderAssetType {
	if o == nil {
		return nil
	}
	return o.AssetType
}

func (o *CompressedOrder) GetAveragePriceAccountID() *string {
	if o == nil {
		return nil
	}
	return o.AveragePriceAccountID
}

func (o *CompressedOrder) GetAveragePrices() []ExecutedPrice {
	if o == nil {
		return nil
	}
	return o.AveragePrices
}

func (o *CompressedOrder) GetCompressedOrderID() *string {
	if o == nil {
		return nil
	}
	return o.CompressedOrderID
}

func (o *CompressedOrder) GetCreateTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreateTime
}

func (o *CompressedOrder) GetCumulativeNotionalValue() *CompressedOrderCumulativeNotionalValue {
	if o == nil {
		return nil
	}
	return o.CumulativeNotionalValue
}

func (o *CompressedOrder) GetExecutions() []Executions {
	if o == nil {
		return nil
	}
	return o.Executions
}

func (o *CompressedOrder) GetFilledQuantity() *CompressedOrderFilledQuantity {
	if o == nil {
		return nil
	}
	return o.FilledQuantity
}

func (o *CompressedOrder) GetIdentifier() *string {
	if o == nil {
		return nil
	}
	return o.Identifier
}

func (o *CompressedOrder) GetIdentifierType() *CompressedOrderIdentifierType {
	if o == nil {
		return nil
	}
	return o.IdentifierType
}

func (o *CompressedOrder) GetLastUpdateTime() *time.Time {
	if o == nil {
		return nil
	}
	return o.LastUpdateTime
}

func (o *CompressedOrder) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *CompressedOrder) GetOrderRejectedReason() *CompressedOrderOrderRejectedReason {
	if o == nil {
		return nil
	}
	return o.OrderRejectedReason
}

func (o *CompressedOrder) GetOrderStatus() *CompressedOrderOrderStatus {
	if o == nil {
		return nil
	}
	return o.OrderStatus
}

func (o *CompressedOrder) GetOrderType() *CompressedOrderOrderType {
	if o == nil {
		return nil
	}
	return o.OrderType
}

func (o *CompressedOrder) GetQuantity() *CompressedOrderQuantity {
	if o == nil {
		return nil
	}
	return o.Quantity
}

func (o *CompressedOrder) GetSide() *CompressedOrderSide {
	if o == nil {
		return nil
	}
	return o.Side
}

func (o *CompressedOrder) GetTimeInForce() *CompressedOrderTimeInForce {
	if o == nil {
		return nil
	}
	return o.TimeInForce
}
